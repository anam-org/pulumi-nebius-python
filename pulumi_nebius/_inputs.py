# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import copy
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from . import _utilities

__all__ = [
    'ApplicationsV1alpha1K8sReleaseMetadataArgs',
    'ApplicationsV1alpha1K8sReleaseMetadataArgsDict',
    'ApplicationsV1alpha1K8sReleaseStatusArgs',
    'ApplicationsV1alpha1K8sReleaseStatusArgsDict',
    'ComputeV1DiskMetadataArgs',
    'ComputeV1DiskMetadataArgsDict',
    'ComputeV1DiskPlacementPolicyArgs',
    'ComputeV1DiskPlacementPolicyArgsDict',
    'ComputeV1DiskSourceImageFamilyArgs',
    'ComputeV1DiskSourceImageFamilyArgsDict',
    'ComputeV1DiskStatusArgs',
    'ComputeV1DiskStatusArgsDict',
    'ComputeV1FilesystemMetadataArgs',
    'ComputeV1FilesystemMetadataArgsDict',
    'ComputeV1FilesystemStatusArgs',
    'ComputeV1FilesystemStatusArgsDict',
    'ComputeV1GpuClusterMetadataArgs',
    'ComputeV1GpuClusterMetadataArgsDict',
    'ComputeV1GpuClusterStatusArgs',
    'ComputeV1GpuClusterStatusArgsDict',
    'ComputeV1InstanceBootDiskArgs',
    'ComputeV1InstanceBootDiskArgsDict',
    'ComputeV1InstanceBootDiskExistingDiskArgs',
    'ComputeV1InstanceBootDiskExistingDiskArgsDict',
    'ComputeV1InstanceFilesystemArgs',
    'ComputeV1InstanceFilesystemArgsDict',
    'ComputeV1InstanceFilesystemExistingFilesystemArgs',
    'ComputeV1InstanceFilesystemExistingFilesystemArgsDict',
    'ComputeV1InstanceGpuClusterArgs',
    'ComputeV1InstanceGpuClusterArgsDict',
    'ComputeV1InstanceMetadataArgs',
    'ComputeV1InstanceMetadataArgsDict',
    'ComputeV1InstanceNetworkInterfaceArgs',
    'ComputeV1InstanceNetworkInterfaceArgsDict',
    'ComputeV1InstanceNetworkInterfaceIpAddressArgs',
    'ComputeV1InstanceNetworkInterfaceIpAddressArgsDict',
    'ComputeV1InstanceNetworkInterfacePublicIpAddressArgs',
    'ComputeV1InstanceNetworkInterfacePublicIpAddressArgsDict',
    'ComputeV1InstanceResourcesArgs',
    'ComputeV1InstanceResourcesArgsDict',
    'ComputeV1InstanceSecondaryDiskArgs',
    'ComputeV1InstanceSecondaryDiskArgsDict',
    'ComputeV1InstanceSecondaryDiskExistingDiskArgs',
    'ComputeV1InstanceSecondaryDiskExistingDiskArgsDict',
    'ComputeV1InstanceStatusArgs',
    'ComputeV1InstanceStatusArgsDict',
    'ComputeV1InstanceStatusMaintenanceEventArgs',
    'ComputeV1InstanceStatusMaintenanceEventArgsDict',
    'ComputeV1InstanceStatusNetworkInterfaceArgs',
    'ComputeV1InstanceStatusNetworkInterfaceArgsDict',
    'ComputeV1InstanceStatusNetworkInterfaceIpAddressArgs',
    'ComputeV1InstanceStatusNetworkInterfaceIpAddressArgsDict',
    'ComputeV1InstanceStatusNetworkInterfacePublicIpAddressArgs',
    'ComputeV1InstanceStatusNetworkInterfacePublicIpAddressArgsDict',
    'ComputeV1alpha1DiskMetadataArgs',
    'ComputeV1alpha1DiskMetadataArgsDict',
    'ComputeV1alpha1DiskPlacementPolicyArgs',
    'ComputeV1alpha1DiskPlacementPolicyArgsDict',
    'ComputeV1alpha1DiskStatusArgs',
    'ComputeV1alpha1DiskStatusArgsDict',
    'ComputeV1alpha1FilesystemMetadataArgs',
    'ComputeV1alpha1FilesystemMetadataArgsDict',
    'ComputeV1alpha1FilesystemStatusArgs',
    'ComputeV1alpha1FilesystemStatusArgsDict',
    'ComputeV1alpha1GpuClusterMetadataArgs',
    'ComputeV1alpha1GpuClusterMetadataArgsDict',
    'ComputeV1alpha1GpuClusterStatusArgs',
    'ComputeV1alpha1GpuClusterStatusArgsDict',
    'ComputeV1alpha1InstanceBootDiskArgs',
    'ComputeV1alpha1InstanceBootDiskArgsDict',
    'ComputeV1alpha1InstanceBootDiskExistingDiskArgs',
    'ComputeV1alpha1InstanceBootDiskExistingDiskArgsDict',
    'ComputeV1alpha1InstanceFilesystemArgs',
    'ComputeV1alpha1InstanceFilesystemArgsDict',
    'ComputeV1alpha1InstanceFilesystemExistingFilesystemArgs',
    'ComputeV1alpha1InstanceFilesystemExistingFilesystemArgsDict',
    'ComputeV1alpha1InstanceGpuClusterArgs',
    'ComputeV1alpha1InstanceGpuClusterArgsDict',
    'ComputeV1alpha1InstanceMetadataArgs',
    'ComputeV1alpha1InstanceMetadataArgsDict',
    'ComputeV1alpha1InstanceNetworkInterfaceArgs',
    'ComputeV1alpha1InstanceNetworkInterfaceArgsDict',
    'ComputeV1alpha1InstanceNetworkInterfaceIpAddressArgs',
    'ComputeV1alpha1InstanceNetworkInterfaceIpAddressArgsDict',
    'ComputeV1alpha1InstanceNetworkInterfacePublicIpAddressArgs',
    'ComputeV1alpha1InstanceNetworkInterfacePublicIpAddressArgsDict',
    'ComputeV1alpha1InstanceResourcesArgs',
    'ComputeV1alpha1InstanceResourcesArgsDict',
    'ComputeV1alpha1InstanceSecondaryDiskArgs',
    'ComputeV1alpha1InstanceSecondaryDiskArgsDict',
    'ComputeV1alpha1InstanceSecondaryDiskExistingDiskArgs',
    'ComputeV1alpha1InstanceSecondaryDiskExistingDiskArgsDict',
    'ComputeV1alpha1InstanceStatusArgs',
    'ComputeV1alpha1InstanceStatusArgsDict',
    'ComputeV1alpha1InstanceStatusNetworkInterfaceArgs',
    'ComputeV1alpha1InstanceStatusNetworkInterfaceArgsDict',
    'ComputeV1alpha1InstanceStatusNetworkInterfaceIpAddressArgs',
    'ComputeV1alpha1InstanceStatusNetworkInterfaceIpAddressArgsDict',
    'ComputeV1alpha1InstanceStatusNetworkInterfacePublicIpAddressArgs',
    'ComputeV1alpha1InstanceStatusNetworkInterfacePublicIpAddressArgsDict',
    'IamV1AuthPublicKeyAccountArgs',
    'IamV1AuthPublicKeyAccountArgsDict',
    'IamV1AuthPublicKeyAccountAnonymousAccountArgs',
    'IamV1AuthPublicKeyAccountAnonymousAccountArgsDict',
    'IamV1AuthPublicKeyAccountServiceAccountArgs',
    'IamV1AuthPublicKeyAccountServiceAccountArgsDict',
    'IamV1AuthPublicKeyAccountUserAccountArgs',
    'IamV1AuthPublicKeyAccountUserAccountArgsDict',
    'IamV1AuthPublicKeyMetadataArgs',
    'IamV1AuthPublicKeyMetadataArgsDict',
    'IamV1AuthPublicKeyStatusArgs',
    'IamV1AuthPublicKeyStatusArgsDict',
    'IamV1FederationCertificateMetadataArgs',
    'IamV1FederationCertificateMetadataArgsDict',
    'IamV1FederationCertificateStatusArgs',
    'IamV1FederationCertificateStatusArgsDict',
    'IamV1FederationMetadataArgs',
    'IamV1FederationMetadataArgsDict',
    'IamV1FederationSamlSettingsArgs',
    'IamV1FederationSamlSettingsArgsDict',
    'IamV1FederationStatusArgs',
    'IamV1FederationStatusArgsDict',
    'IamV1GroupMembershipMetadataArgs',
    'IamV1GroupMembershipMetadataArgsDict',
    'IamV1GroupMembershipStatusArgs',
    'IamV1GroupMembershipStatusArgsDict',
    'IamV1InvitationMetadataArgs',
    'IamV1InvitationMetadataArgsDict',
    'IamV1InvitationStatusArgs',
    'IamV1InvitationStatusArgsDict',
    'IamV1ServiceAccountMetadataArgs',
    'IamV1ServiceAccountMetadataArgsDict',
    'IamV1ServiceAccountStatusArgs',
    'IamV1ServiceAccountStatusArgsDict',
    'Mk8sV1ClusterControlPlaneArgs',
    'Mk8sV1ClusterControlPlaneArgsDict',
    'Mk8sV1ClusterControlPlaneEndpointsArgs',
    'Mk8sV1ClusterControlPlaneEndpointsArgsDict',
    'Mk8sV1ClusterControlPlaneEndpointsPublicEndpointArgs',
    'Mk8sV1ClusterControlPlaneEndpointsPublicEndpointArgsDict',
    'Mk8sV1ClusterKubeNetworkArgs',
    'Mk8sV1ClusterKubeNetworkArgsDict',
    'Mk8sV1ClusterMetadataArgs',
    'Mk8sV1ClusterMetadataArgsDict',
    'Mk8sV1ClusterStatusArgs',
    'Mk8sV1ClusterStatusArgsDict',
    'Mk8sV1ClusterStatusControlPlaneArgs',
    'Mk8sV1ClusterStatusControlPlaneArgsDict',
    'Mk8sV1ClusterStatusControlPlaneAuthArgs',
    'Mk8sV1ClusterStatusControlPlaneAuthArgsDict',
    'Mk8sV1ClusterStatusControlPlaneEndpointsArgs',
    'Mk8sV1ClusterStatusControlPlaneEndpointsArgsDict',
    'Mk8sV1NodeGroupAutoscalingArgs',
    'Mk8sV1NodeGroupAutoscalingArgsDict',
    'Mk8sV1NodeGroupMetadataArgs',
    'Mk8sV1NodeGroupMetadataArgsDict',
    'Mk8sV1NodeGroupStatusArgs',
    'Mk8sV1NodeGroupStatusArgsDict',
    'Mk8sV1NodeGroupStrategyArgs',
    'Mk8sV1NodeGroupStrategyArgsDict',
    'Mk8sV1NodeGroupStrategyMaxSurgeArgs',
    'Mk8sV1NodeGroupStrategyMaxSurgeArgsDict',
    'Mk8sV1NodeGroupStrategyMaxUnavailableArgs',
    'Mk8sV1NodeGroupStrategyMaxUnavailableArgsDict',
    'Mk8sV1NodeGroupTemplateArgs',
    'Mk8sV1NodeGroupTemplateArgsDict',
    'Mk8sV1NodeGroupTemplateBootDiskArgs',
    'Mk8sV1NodeGroupTemplateBootDiskArgsDict',
    'Mk8sV1NodeGroupTemplateFilesystemArgs',
    'Mk8sV1NodeGroupTemplateFilesystemArgsDict',
    'Mk8sV1NodeGroupTemplateFilesystemExistingFilesystemArgs',
    'Mk8sV1NodeGroupTemplateFilesystemExistingFilesystemArgsDict',
    'Mk8sV1NodeGroupTemplateGpuClusterArgs',
    'Mk8sV1NodeGroupTemplateGpuClusterArgsDict',
    'Mk8sV1NodeGroupTemplateMetadataArgs',
    'Mk8sV1NodeGroupTemplateMetadataArgsDict',
    'Mk8sV1NodeGroupTemplateNetworkInterfaceArgs',
    'Mk8sV1NodeGroupTemplateNetworkInterfaceArgsDict',
    'Mk8sV1NodeGroupTemplateNetworkInterfacePublicIpAddressArgs',
    'Mk8sV1NodeGroupTemplateNetworkInterfacePublicIpAddressArgsDict',
    'Mk8sV1NodeGroupTemplateResourcesArgs',
    'Mk8sV1NodeGroupTemplateResourcesArgsDict',
    'Mk8sV1NodeGroupTemplateTaintArgs',
    'Mk8sV1NodeGroupTemplateTaintArgsDict',
    'Mk8sV1alpha1ClusterControlPlaneArgs',
    'Mk8sV1alpha1ClusterControlPlaneArgsDict',
    'Mk8sV1alpha1ClusterControlPlaneEndpointsArgs',
    'Mk8sV1alpha1ClusterControlPlaneEndpointsArgsDict',
    'Mk8sV1alpha1ClusterControlPlaneEndpointsPublicEndpointArgs',
    'Mk8sV1alpha1ClusterControlPlaneEndpointsPublicEndpointArgsDict',
    'Mk8sV1alpha1ClusterKubeNetworkArgs',
    'Mk8sV1alpha1ClusterKubeNetworkArgsDict',
    'Mk8sV1alpha1ClusterMetadataArgs',
    'Mk8sV1alpha1ClusterMetadataArgsDict',
    'Mk8sV1alpha1ClusterStatusArgs',
    'Mk8sV1alpha1ClusterStatusArgsDict',
    'Mk8sV1alpha1ClusterStatusControlPlaneArgs',
    'Mk8sV1alpha1ClusterStatusControlPlaneArgsDict',
    'Mk8sV1alpha1ClusterStatusControlPlaneAuthArgs',
    'Mk8sV1alpha1ClusterStatusControlPlaneAuthArgsDict',
    'Mk8sV1alpha1ClusterStatusControlPlaneEndpointsArgs',
    'Mk8sV1alpha1ClusterStatusControlPlaneEndpointsArgsDict',
    'Mk8sV1alpha1NodeGroupAutoscalingArgs',
    'Mk8sV1alpha1NodeGroupAutoscalingArgsDict',
    'Mk8sV1alpha1NodeGroupMetadataArgs',
    'Mk8sV1alpha1NodeGroupMetadataArgsDict',
    'Mk8sV1alpha1NodeGroupStatusArgs',
    'Mk8sV1alpha1NodeGroupStatusArgsDict',
    'Mk8sV1alpha1NodeGroupStrategyArgs',
    'Mk8sV1alpha1NodeGroupStrategyArgsDict',
    'Mk8sV1alpha1NodeGroupStrategyMaxSurgeArgs',
    'Mk8sV1alpha1NodeGroupStrategyMaxSurgeArgsDict',
    'Mk8sV1alpha1NodeGroupStrategyMaxUnavailableArgs',
    'Mk8sV1alpha1NodeGroupStrategyMaxUnavailableArgsDict',
    'Mk8sV1alpha1NodeGroupTemplateArgs',
    'Mk8sV1alpha1NodeGroupTemplateArgsDict',
    'Mk8sV1alpha1NodeGroupTemplateBootDiskArgs',
    'Mk8sV1alpha1NodeGroupTemplateBootDiskArgsDict',
    'Mk8sV1alpha1NodeGroupTemplateFilesystemArgs',
    'Mk8sV1alpha1NodeGroupTemplateFilesystemArgsDict',
    'Mk8sV1alpha1NodeGroupTemplateFilesystemExistingFilesystemArgs',
    'Mk8sV1alpha1NodeGroupTemplateFilesystemExistingFilesystemArgsDict',
    'Mk8sV1alpha1NodeGroupTemplateGpuClusterArgs',
    'Mk8sV1alpha1NodeGroupTemplateGpuClusterArgsDict',
    'Mk8sV1alpha1NodeGroupTemplateMetadataArgs',
    'Mk8sV1alpha1NodeGroupTemplateMetadataArgsDict',
    'Mk8sV1alpha1NodeGroupTemplateNetworkInterfaceArgs',
    'Mk8sV1alpha1NodeGroupTemplateNetworkInterfaceArgsDict',
    'Mk8sV1alpha1NodeGroupTemplateNetworkInterfacePublicIpAddressArgs',
    'Mk8sV1alpha1NodeGroupTemplateNetworkInterfacePublicIpAddressArgsDict',
    'Mk8sV1alpha1NodeGroupTemplateResourcesArgs',
    'Mk8sV1alpha1NodeGroupTemplateResourcesArgsDict',
    'Mk8sV1alpha1NodeGroupTemplateTaintArgs',
    'Mk8sV1alpha1NodeGroupTemplateTaintArgsDict',
    'MspMlflowV1alpha1ClusterMetadataArgs',
    'MspMlflowV1alpha1ClusterMetadataArgsDict',
    'MspMlflowV1alpha1ClusterStatusArgs',
    'MspMlflowV1alpha1ClusterStatusArgsDict',
    'MspMlflowV1alpha1ClusterStatusTrackingEndpointsArgs',
    'MspMlflowV1alpha1ClusterStatusTrackingEndpointsArgsDict',
    'MspPostgresqlV1alpha1ClusterBackupArgs',
    'MspPostgresqlV1alpha1ClusterBackupArgsDict',
    'MspPostgresqlV1alpha1ClusterBootstrapArgs',
    'MspPostgresqlV1alpha1ClusterBootstrapArgsDict',
    'MspPostgresqlV1alpha1ClusterConfigArgs',
    'MspPostgresqlV1alpha1ClusterConfigArgsDict',
    'MspPostgresqlV1alpha1ClusterConfigPoolerConfigArgs',
    'MspPostgresqlV1alpha1ClusterConfigPoolerConfigArgsDict',
    'MspPostgresqlV1alpha1ClusterConfigPostgresqlConfig16Args',
    'MspPostgresqlV1alpha1ClusterConfigPostgresqlConfig16ArgsDict',
    'MspPostgresqlV1alpha1ClusterConfigResourcesArgs',
    'MspPostgresqlV1alpha1ClusterConfigResourcesArgsDict',
    'MspPostgresqlV1alpha1ClusterConfigResourcesDiskArgs',
    'MspPostgresqlV1alpha1ClusterConfigResourcesDiskArgsDict',
    'MspPostgresqlV1alpha1ClusterConfigResourcesHostsArgs',
    'MspPostgresqlV1alpha1ClusterConfigResourcesHostsArgsDict',
    'MspPostgresqlV1alpha1ClusterConfigResourcesResourcesArgs',
    'MspPostgresqlV1alpha1ClusterConfigResourcesResourcesArgsDict',
    'MspPostgresqlV1alpha1ClusterConfigTemplateArgs',
    'MspPostgresqlV1alpha1ClusterConfigTemplateArgsDict',
    'MspPostgresqlV1alpha1ClusterConfigTemplateDiskArgs',
    'MspPostgresqlV1alpha1ClusterConfigTemplateDiskArgsDict',
    'MspPostgresqlV1alpha1ClusterConfigTemplateHostsArgs',
    'MspPostgresqlV1alpha1ClusterConfigTemplateHostsArgsDict',
    'MspPostgresqlV1alpha1ClusterConfigTemplateResourcesArgs',
    'MspPostgresqlV1alpha1ClusterConfigTemplateResourcesArgsDict',
    'MspPostgresqlV1alpha1ClusterMetadataArgs',
    'MspPostgresqlV1alpha1ClusterMetadataArgsDict',
    'MspPostgresqlV1alpha1ClusterStatusArgs',
    'MspPostgresqlV1alpha1ClusterStatusArgsDict',
    'MspPostgresqlV1alpha1ClusterStatusConnectionEndpointsArgs',
    'MspPostgresqlV1alpha1ClusterStatusConnectionEndpointsArgsDict',
    'MspPostgresqlV1alpha1ClusterStatusPresetDetailsArgs',
    'MspPostgresqlV1alpha1ClusterStatusPresetDetailsArgsDict',
    'MspSparkV1alpha1ClusterAuthorizationArgs',
    'MspSparkV1alpha1ClusterAuthorizationArgsDict',
    'MspSparkV1alpha1ClusterLimitsArgs',
    'MspSparkV1alpha1ClusterLimitsArgsDict',
    'MspSparkV1alpha1ClusterMetadataArgs',
    'MspSparkV1alpha1ClusterMetadataArgsDict',
    'MspSparkV1alpha1ClusterStatusArgs',
    'MspSparkV1alpha1ClusterStatusArgsDict',
    'MspSparkV1alpha1SessionDriverArgs',
    'MspSparkV1alpha1SessionDriverArgsDict',
    'MspSparkV1alpha1SessionDriverDiskArgs',
    'MspSparkV1alpha1SessionDriverDiskArgsDict',
    'MspSparkV1alpha1SessionDriverResourcesArgs',
    'MspSparkV1alpha1SessionDriverResourcesArgsDict',
    'MspSparkV1alpha1SessionExecutorArgs',
    'MspSparkV1alpha1SessionExecutorArgsDict',
    'MspSparkV1alpha1SessionExecutorDiskArgs',
    'MspSparkV1alpha1SessionExecutorDiskArgsDict',
    'MspSparkV1alpha1SessionExecutorHostsArgs',
    'MspSparkV1alpha1SessionExecutorHostsArgsDict',
    'MspSparkV1alpha1SessionExecutorHostsDynamicAllocationArgs',
    'MspSparkV1alpha1SessionExecutorHostsDynamicAllocationArgsDict',
    'MspSparkV1alpha1SessionExecutorResourcesArgs',
    'MspSparkV1alpha1SessionExecutorResourcesArgsDict',
    'MspSparkV1alpha1SessionMetadataArgs',
    'MspSparkV1alpha1SessionMetadataArgsDict',
    'MspSparkV1alpha1SessionPythonArgs',
    'MspSparkV1alpha1SessionPythonArgsDict',
    'MspSparkV1alpha1SessionStatusArgs',
    'MspSparkV1alpha1SessionStatusArgsDict',
    'MspSparkV1alpha1SessionStatusDriverPresetDetailsArgs',
    'MspSparkV1alpha1SessionStatusDriverPresetDetailsArgsDict',
    'MspSparkV1alpha1SessionStatusExecutorPresetDetailsArgs',
    'MspSparkV1alpha1SessionStatusExecutorPresetDetailsArgsDict',
    'ProviderAddressOptionsArgs',
    'ProviderAddressOptionsArgsDict',
    'ProviderAddressTemplateArgs',
    'ProviderAddressTemplateArgsDict',
    'ProviderServiceAccountArgs',
    'ProviderServiceAccountArgsDict',
    'RegistryV1RegistryMetadataArgs',
    'RegistryV1RegistryMetadataArgsDict',
    'RegistryV1RegistryStatusArgs',
    'RegistryV1RegistryStatusArgsDict',
    'StorageV1BucketLifecycleConfigurationArgs',
    'StorageV1BucketLifecycleConfigurationArgsDict',
    'StorageV1BucketLifecycleConfigurationRuleArgs',
    'StorageV1BucketLifecycleConfigurationRuleArgsDict',
    'StorageV1BucketLifecycleConfigurationRuleAbortIncompleteMultipartUploadArgs',
    'StorageV1BucketLifecycleConfigurationRuleAbortIncompleteMultipartUploadArgsDict',
    'StorageV1BucketLifecycleConfigurationRuleExpirationArgs',
    'StorageV1BucketLifecycleConfigurationRuleExpirationArgsDict',
    'StorageV1BucketLifecycleConfigurationRuleFilterArgs',
    'StorageV1BucketLifecycleConfigurationRuleFilterArgsDict',
    'StorageV1BucketLifecycleConfigurationRuleNoncurrentVersionExpirationArgs',
    'StorageV1BucketLifecycleConfigurationRuleNoncurrentVersionExpirationArgsDict',
    'StorageV1BucketMetadataArgs',
    'StorageV1BucketMetadataArgsDict',
    'StorageV1BucketStatusArgs',
    'StorageV1BucketStatusArgsDict',
    'StorageV1BucketStatusCounterArgs',
    'StorageV1BucketStatusCounterArgsDict',
    'StorageV1BucketStatusCounterCountersArgs',
    'StorageV1BucketStatusCounterCountersArgsDict',
    'StorageV1BucketStatusCounterNonCurrentCountersArgs',
    'StorageV1BucketStatusCounterNonCurrentCountersArgsDict',
    'VpcV1AllocationIpv4PrivateArgs',
    'VpcV1AllocationIpv4PrivateArgsDict',
    'VpcV1AllocationIpv4PublicArgs',
    'VpcV1AllocationIpv4PublicArgsDict',
    'VpcV1AllocationMetadataArgs',
    'VpcV1AllocationMetadataArgsDict',
    'VpcV1AllocationStatusArgs',
    'VpcV1AllocationStatusArgsDict',
    'VpcV1AllocationStatusAssignmentArgs',
    'VpcV1AllocationStatusAssignmentArgsDict',
    'VpcV1AllocationStatusAssignmentLoadBalancerArgs',
    'VpcV1AllocationStatusAssignmentLoadBalancerArgsDict',
    'VpcV1AllocationStatusAssignmentNetworkInterfaceArgs',
    'VpcV1AllocationStatusAssignmentNetworkInterfaceArgsDict',
    'VpcV1AllocationStatusDetailsArgs',
    'VpcV1AllocationStatusDetailsArgsDict',
    'VpcV1alpha1AllocationIpv4PrivateArgs',
    'VpcV1alpha1AllocationIpv4PrivateArgsDict',
    'VpcV1alpha1AllocationIpv4PublicArgs',
    'VpcV1alpha1AllocationIpv4PublicArgsDict',
    'VpcV1alpha1AllocationMetadataArgs',
    'VpcV1alpha1AllocationMetadataArgsDict',
    'VpcV1alpha1AllocationStatusArgs',
    'VpcV1alpha1AllocationStatusArgsDict',
    'VpcV1alpha1AllocationStatusAssignmentArgs',
    'VpcV1alpha1AllocationStatusAssignmentArgsDict',
    'VpcV1alpha1AllocationStatusAssignmentLoadBalancerArgs',
    'VpcV1alpha1AllocationStatusAssignmentLoadBalancerArgsDict',
    'VpcV1alpha1AllocationStatusAssignmentNetworkInterfaceArgs',
    'VpcV1alpha1AllocationStatusAssignmentNetworkInterfaceArgsDict',
    'VpcV1alpha1AllocationStatusDetailsArgs',
    'VpcV1alpha1AllocationStatusDetailsArgsDict',
    'GetApplicationsV1alpha1K8sReleaseMetadataArgs',
    'GetApplicationsV1alpha1K8sReleaseMetadataArgsDict',
    'GetIamV1AuthPublicKeyMetadataArgs',
    'GetIamV1AuthPublicKeyMetadataArgsDict',
    'GetIamV1FederationCertificateMetadataArgs',
    'GetIamV1FederationCertificateMetadataArgsDict',
    'GetIamV1FederationMetadataArgs',
    'GetIamV1FederationMetadataArgsDict',
    'GetIamV1GroupMembershipMetadataArgs',
    'GetIamV1GroupMembershipMetadataArgsDict',
    'GetIamV1InvitationMetadataArgs',
    'GetIamV1InvitationMetadataArgsDict',
    'GetIamV1TenantMetadataArgs',
    'GetIamV1TenantMetadataArgsDict',
    'GetIamV1TenantUserAccountMetadataArgs',
    'GetIamV1TenantUserAccountMetadataArgsDict',
    'GetRegistryV1RegistryMetadataArgs',
    'GetRegistryV1RegistryMetadataArgsDict',
]

MYPY = False

if not MYPY:
    class ApplicationsV1alpha1K8sReleaseMetadataArgsDict(TypedDict):
        pass
elif False:
    ApplicationsV1alpha1K8sReleaseMetadataArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ApplicationsV1alpha1K8sReleaseMetadataArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class ApplicationsV1alpha1K8sReleaseStatusArgsDict(TypedDict):
        error_message: NotRequired[pulumi.Input[str]]
        state: NotRequired[pulumi.Input[str]]
        """
        ### Supported values

        Possible values:

         - `UNSPECIFIED`
         - `CREATED`
         - `RUNNING`
         - `DEPLOYED`
         - `FAILED`
         - `INSTALLING`
        """
elif False:
    ApplicationsV1alpha1K8sReleaseStatusArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ApplicationsV1alpha1K8sReleaseStatusArgs:
    def __init__(__self__, *,
                 error_message: Optional[pulumi.Input[str]] = None,
                 state: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] state: ### Supported values
               
               Possible values:
               
                - `UNSPECIFIED`
                - `CREATED`
                - `RUNNING`
                - `DEPLOYED`
                - `FAILED`
                - `INSTALLING`
        """
        if error_message is not None:
            pulumi.set(__self__, "error_message", error_message)
        if state is not None:
            pulumi.set(__self__, "state", state)

    @property
    @pulumi.getter(name="errorMessage")
    def error_message(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "error_message")

    @error_message.setter
    def error_message(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "error_message", value)

    @property
    @pulumi.getter
    def state(self) -> Optional[pulumi.Input[str]]:
        """
        ### Supported values

        Possible values:

         - `UNSPECIFIED`
         - `CREATED`
         - `RUNNING`
         - `DEPLOYED`
         - `FAILED`
         - `INSTALLING`
        """
        return pulumi.get(self, "state")

    @state.setter
    def state(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "state", value)


if not MYPY:
    class ComputeV1DiskMetadataArgsDict(TypedDict):
        pass
elif False:
    ComputeV1DiskMetadataArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ComputeV1DiskMetadataArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class ComputeV1DiskPlacementPolicyArgsDict(TypedDict):
        placement_group_id: NotRequired[pulumi.Input[str]]
        placement_group_partition: NotRequired[pulumi.Input[float]]
elif False:
    ComputeV1DiskPlacementPolicyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ComputeV1DiskPlacementPolicyArgs:
    def __init__(__self__, *,
                 placement_group_id: Optional[pulumi.Input[str]] = None,
                 placement_group_partition: Optional[pulumi.Input[float]] = None):
        if placement_group_id is not None:
            pulumi.set(__self__, "placement_group_id", placement_group_id)
        if placement_group_partition is not None:
            pulumi.set(__self__, "placement_group_partition", placement_group_partition)

    @property
    @pulumi.getter(name="placementGroupId")
    def placement_group_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "placement_group_id")

    @placement_group_id.setter
    def placement_group_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "placement_group_id", value)

    @property
    @pulumi.getter(name="placementGroupPartition")
    def placement_group_partition(self) -> Optional[pulumi.Input[float]]:
        return pulumi.get(self, "placement_group_partition")

    @placement_group_partition.setter
    def placement_group_partition(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "placement_group_partition", value)


if not MYPY:
    class ComputeV1DiskSourceImageFamilyArgsDict(TypedDict):
        image_family: pulumi.Input[str]
        parent_id: NotRequired[pulumi.Input[str]]
elif False:
    ComputeV1DiskSourceImageFamilyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ComputeV1DiskSourceImageFamilyArgs:
    def __init__(__self__, *,
                 image_family: pulumi.Input[str],
                 parent_id: Optional[pulumi.Input[str]] = None):
        pulumi.set(__self__, "image_family", image_family)
        if parent_id is not None:
            pulumi.set(__self__, "parent_id", parent_id)

    @property
    @pulumi.getter(name="imageFamily")
    def image_family(self) -> pulumi.Input[str]:
        return pulumi.get(self, "image_family")

    @image_family.setter
    def image_family(self, value: pulumi.Input[str]):
        pulumi.set(self, "image_family", value)

    @property
    @pulumi.getter(name="parentId")
    def parent_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "parent_id")

    @parent_id.setter
    def parent_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "parent_id", value)


if not MYPY:
    class ComputeV1DiskStatusArgsDict(TypedDict):
        read_only_attachments: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        read_write_attachment: NotRequired[pulumi.Input[str]]
        reconciling: NotRequired[pulumi.Input[bool]]
        """
        Indicates whether there is an ongoing operation
        """
        size_bytes: NotRequired[pulumi.Input[float]]
        source_image_id: NotRequired[pulumi.Input[str]]
        state: NotRequired[pulumi.Input[str]]
        """
        ### Supported values

        Possible values:

         - `UNSPECIFIED`
         - `CREATING`
         - `READY`
         - `UPDATING`
         - `DELETING`
         - `ERROR`
        """
        state_description: NotRequired[pulumi.Input[str]]
elif False:
    ComputeV1DiskStatusArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ComputeV1DiskStatusArgs:
    def __init__(__self__, *,
                 read_only_attachments: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 read_write_attachment: Optional[pulumi.Input[str]] = None,
                 reconciling: Optional[pulumi.Input[bool]] = None,
                 size_bytes: Optional[pulumi.Input[float]] = None,
                 source_image_id: Optional[pulumi.Input[str]] = None,
                 state: Optional[pulumi.Input[str]] = None,
                 state_description: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[bool] reconciling: Indicates whether there is an ongoing operation
        :param pulumi.Input[str] state: ### Supported values
               
               Possible values:
               
                - `UNSPECIFIED`
                - `CREATING`
                - `READY`
                - `UPDATING`
                - `DELETING`
                - `ERROR`
        """
        if read_only_attachments is not None:
            pulumi.set(__self__, "read_only_attachments", read_only_attachments)
        if read_write_attachment is not None:
            pulumi.set(__self__, "read_write_attachment", read_write_attachment)
        if reconciling is not None:
            pulumi.set(__self__, "reconciling", reconciling)
        if size_bytes is not None:
            pulumi.set(__self__, "size_bytes", size_bytes)
        if source_image_id is not None:
            pulumi.set(__self__, "source_image_id", source_image_id)
        if state is not None:
            pulumi.set(__self__, "state", state)
        if state_description is not None:
            pulumi.set(__self__, "state_description", state_description)

    @property
    @pulumi.getter(name="readOnlyAttachments")
    def read_only_attachments(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "read_only_attachments")

    @read_only_attachments.setter
    def read_only_attachments(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "read_only_attachments", value)

    @property
    @pulumi.getter(name="readWriteAttachment")
    def read_write_attachment(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "read_write_attachment")

    @read_write_attachment.setter
    def read_write_attachment(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "read_write_attachment", value)

    @property
    @pulumi.getter
    def reconciling(self) -> Optional[pulumi.Input[bool]]:
        """
        Indicates whether there is an ongoing operation
        """
        return pulumi.get(self, "reconciling")

    @reconciling.setter
    def reconciling(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "reconciling", value)

    @property
    @pulumi.getter(name="sizeBytes")
    def size_bytes(self) -> Optional[pulumi.Input[float]]:
        return pulumi.get(self, "size_bytes")

    @size_bytes.setter
    def size_bytes(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "size_bytes", value)

    @property
    @pulumi.getter(name="sourceImageId")
    def source_image_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "source_image_id")

    @source_image_id.setter
    def source_image_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "source_image_id", value)

    @property
    @pulumi.getter
    def state(self) -> Optional[pulumi.Input[str]]:
        """
        ### Supported values

        Possible values:

         - `UNSPECIFIED`
         - `CREATING`
         - `READY`
         - `UPDATING`
         - `DELETING`
         - `ERROR`
        """
        return pulumi.get(self, "state")

    @state.setter
    def state(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "state", value)

    @property
    @pulumi.getter(name="stateDescription")
    def state_description(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "state_description")

    @state_description.setter
    def state_description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "state_description", value)


if not MYPY:
    class ComputeV1FilesystemMetadataArgsDict(TypedDict):
        pass
elif False:
    ComputeV1FilesystemMetadataArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ComputeV1FilesystemMetadataArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class ComputeV1FilesystemStatusArgsDict(TypedDict):
        read_only_attachments: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        read_write_attachments: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        reconciling: NotRequired[pulumi.Input[bool]]
        """
        Indicates whether there is an ongoing operation
        """
        size_bytes: NotRequired[pulumi.Input[float]]
        state: NotRequired[pulumi.Input[str]]
        """
        ### Supported values

        Possible values:

         - `UNSPECIFIED`
         - `CREATING`
         - `READY`
         - `UPDATING`
         - `DELETING`
         - `ERROR`
        """
        state_description: NotRequired[pulumi.Input[str]]
elif False:
    ComputeV1FilesystemStatusArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ComputeV1FilesystemStatusArgs:
    def __init__(__self__, *,
                 read_only_attachments: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 read_write_attachments: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 reconciling: Optional[pulumi.Input[bool]] = None,
                 size_bytes: Optional[pulumi.Input[float]] = None,
                 state: Optional[pulumi.Input[str]] = None,
                 state_description: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[bool] reconciling: Indicates whether there is an ongoing operation
        :param pulumi.Input[str] state: ### Supported values
               
               Possible values:
               
                - `UNSPECIFIED`
                - `CREATING`
                - `READY`
                - `UPDATING`
                - `DELETING`
                - `ERROR`
        """
        if read_only_attachments is not None:
            pulumi.set(__self__, "read_only_attachments", read_only_attachments)
        if read_write_attachments is not None:
            pulumi.set(__self__, "read_write_attachments", read_write_attachments)
        if reconciling is not None:
            pulumi.set(__self__, "reconciling", reconciling)
        if size_bytes is not None:
            pulumi.set(__self__, "size_bytes", size_bytes)
        if state is not None:
            pulumi.set(__self__, "state", state)
        if state_description is not None:
            pulumi.set(__self__, "state_description", state_description)

    @property
    @pulumi.getter(name="readOnlyAttachments")
    def read_only_attachments(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "read_only_attachments")

    @read_only_attachments.setter
    def read_only_attachments(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "read_only_attachments", value)

    @property
    @pulumi.getter(name="readWriteAttachments")
    def read_write_attachments(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "read_write_attachments")

    @read_write_attachments.setter
    def read_write_attachments(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "read_write_attachments", value)

    @property
    @pulumi.getter
    def reconciling(self) -> Optional[pulumi.Input[bool]]:
        """
        Indicates whether there is an ongoing operation
        """
        return pulumi.get(self, "reconciling")

    @reconciling.setter
    def reconciling(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "reconciling", value)

    @property
    @pulumi.getter(name="sizeBytes")
    def size_bytes(self) -> Optional[pulumi.Input[float]]:
        return pulumi.get(self, "size_bytes")

    @size_bytes.setter
    def size_bytes(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "size_bytes", value)

    @property
    @pulumi.getter
    def state(self) -> Optional[pulumi.Input[str]]:
        """
        ### Supported values

        Possible values:

         - `UNSPECIFIED`
         - `CREATING`
         - `READY`
         - `UPDATING`
         - `DELETING`
         - `ERROR`
        """
        return pulumi.get(self, "state")

    @state.setter
    def state(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "state", value)

    @property
    @pulumi.getter(name="stateDescription")
    def state_description(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "state_description")

    @state_description.setter
    def state_description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "state_description", value)


if not MYPY:
    class ComputeV1GpuClusterMetadataArgsDict(TypedDict):
        pass
elif False:
    ComputeV1GpuClusterMetadataArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ComputeV1GpuClusterMetadataArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class ComputeV1GpuClusterStatusArgsDict(TypedDict):
        instances: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        reconciling: NotRequired[pulumi.Input[bool]]
        """
        Indicates whether there is an ongoing operation
        """
elif False:
    ComputeV1GpuClusterStatusArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ComputeV1GpuClusterStatusArgs:
    def __init__(__self__, *,
                 instances: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 reconciling: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[bool] reconciling: Indicates whether there is an ongoing operation
        """
        if instances is not None:
            pulumi.set(__self__, "instances", instances)
        if reconciling is not None:
            pulumi.set(__self__, "reconciling", reconciling)

    @property
    @pulumi.getter
    def instances(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "instances")

    @instances.setter
    def instances(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "instances", value)

    @property
    @pulumi.getter
    def reconciling(self) -> Optional[pulumi.Input[bool]]:
        """
        Indicates whether there is an ongoing operation
        """
        return pulumi.get(self, "reconciling")

    @reconciling.setter
    def reconciling(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "reconciling", value)


if not MYPY:
    class ComputeV1InstanceBootDiskArgsDict(TypedDict):
        attach_mode: pulumi.Input[str]
        """
        ### Supported values

        Possible values:

         - `UNSPECIFIED`
         - `READ_ONLY`
         - `READ_WRITE`
        """
        device_id: NotRequired[pulumi.Input[str]]
        """
        Specifies the user-defined identifier, allowing to use '/dev/disk/by-id/virtio-{device_id}' as a device path in mount command.
        """
        existing_disk: NotRequired[pulumi.Input['ComputeV1InstanceBootDiskExistingDiskArgsDict']]
elif False:
    ComputeV1InstanceBootDiskArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ComputeV1InstanceBootDiskArgs:
    def __init__(__self__, *,
                 attach_mode: pulumi.Input[str],
                 device_id: Optional[pulumi.Input[str]] = None,
                 existing_disk: Optional[pulumi.Input['ComputeV1InstanceBootDiskExistingDiskArgs']] = None):
        """
        :param pulumi.Input[str] attach_mode: ### Supported values
               
               Possible values:
               
                - `UNSPECIFIED`
                - `READ_ONLY`
                - `READ_WRITE`
        :param pulumi.Input[str] device_id: Specifies the user-defined identifier, allowing to use '/dev/disk/by-id/virtio-{device_id}' as a device path in mount command.
        """
        pulumi.set(__self__, "attach_mode", attach_mode)
        if device_id is not None:
            pulumi.set(__self__, "device_id", device_id)
        if existing_disk is not None:
            pulumi.set(__self__, "existing_disk", existing_disk)

    @property
    @pulumi.getter(name="attachMode")
    def attach_mode(self) -> pulumi.Input[str]:
        """
        ### Supported values

        Possible values:

         - `UNSPECIFIED`
         - `READ_ONLY`
         - `READ_WRITE`
        """
        return pulumi.get(self, "attach_mode")

    @attach_mode.setter
    def attach_mode(self, value: pulumi.Input[str]):
        pulumi.set(self, "attach_mode", value)

    @property
    @pulumi.getter(name="deviceId")
    def device_id(self) -> Optional[pulumi.Input[str]]:
        """
        Specifies the user-defined identifier, allowing to use '/dev/disk/by-id/virtio-{device_id}' as a device path in mount command.
        """
        return pulumi.get(self, "device_id")

    @device_id.setter
    def device_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "device_id", value)

    @property
    @pulumi.getter(name="existingDisk")
    def existing_disk(self) -> Optional[pulumi.Input['ComputeV1InstanceBootDiskExistingDiskArgs']]:
        return pulumi.get(self, "existing_disk")

    @existing_disk.setter
    def existing_disk(self, value: Optional[pulumi.Input['ComputeV1InstanceBootDiskExistingDiskArgs']]):
        pulumi.set(self, "existing_disk", value)


if not MYPY:
    class ComputeV1InstanceBootDiskExistingDiskArgsDict(TypedDict):
        id: pulumi.Input[str]
elif False:
    ComputeV1InstanceBootDiskExistingDiskArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ComputeV1InstanceBootDiskExistingDiskArgs:
    def __init__(__self__, *,
                 id: pulumi.Input[str]):
        pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> pulumi.Input[str]:
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[str]):
        pulumi.set(self, "id", value)


if not MYPY:
    class ComputeV1InstanceFilesystemArgsDict(TypedDict):
        attach_mode: pulumi.Input[str]
        """
        ### Supported values

        Possible values:

         - `UNSPECIFIED`
         - `READ_ONLY`
         - `READ_WRITE`
        """
        mount_tag: pulumi.Input[str]
        """
        Specifies the user-defined identifier, allowing to use it as a device in mount command.
        """
        existing_filesystem: NotRequired[pulumi.Input['ComputeV1InstanceFilesystemExistingFilesystemArgsDict']]
elif False:
    ComputeV1InstanceFilesystemArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ComputeV1InstanceFilesystemArgs:
    def __init__(__self__, *,
                 attach_mode: pulumi.Input[str],
                 mount_tag: pulumi.Input[str],
                 existing_filesystem: Optional[pulumi.Input['ComputeV1InstanceFilesystemExistingFilesystemArgs']] = None):
        """
        :param pulumi.Input[str] attach_mode: ### Supported values
               
               Possible values:
               
                - `UNSPECIFIED`
                - `READ_ONLY`
                - `READ_WRITE`
        :param pulumi.Input[str] mount_tag: Specifies the user-defined identifier, allowing to use it as a device in mount command.
        """
        pulumi.set(__self__, "attach_mode", attach_mode)
        pulumi.set(__self__, "mount_tag", mount_tag)
        if existing_filesystem is not None:
            pulumi.set(__self__, "existing_filesystem", existing_filesystem)

    @property
    @pulumi.getter(name="attachMode")
    def attach_mode(self) -> pulumi.Input[str]:
        """
        ### Supported values

        Possible values:

         - `UNSPECIFIED`
         - `READ_ONLY`
         - `READ_WRITE`
        """
        return pulumi.get(self, "attach_mode")

    @attach_mode.setter
    def attach_mode(self, value: pulumi.Input[str]):
        pulumi.set(self, "attach_mode", value)

    @property
    @pulumi.getter(name="mountTag")
    def mount_tag(self) -> pulumi.Input[str]:
        """
        Specifies the user-defined identifier, allowing to use it as a device in mount command.
        """
        return pulumi.get(self, "mount_tag")

    @mount_tag.setter
    def mount_tag(self, value: pulumi.Input[str]):
        pulumi.set(self, "mount_tag", value)

    @property
    @pulumi.getter(name="existingFilesystem")
    def existing_filesystem(self) -> Optional[pulumi.Input['ComputeV1InstanceFilesystemExistingFilesystemArgs']]:
        return pulumi.get(self, "existing_filesystem")

    @existing_filesystem.setter
    def existing_filesystem(self, value: Optional[pulumi.Input['ComputeV1InstanceFilesystemExistingFilesystemArgs']]):
        pulumi.set(self, "existing_filesystem", value)


if not MYPY:
    class ComputeV1InstanceFilesystemExistingFilesystemArgsDict(TypedDict):
        id: pulumi.Input[str]
elif False:
    ComputeV1InstanceFilesystemExistingFilesystemArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ComputeV1InstanceFilesystemExistingFilesystemArgs:
    def __init__(__self__, *,
                 id: pulumi.Input[str]):
        pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> pulumi.Input[str]:
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[str]):
        pulumi.set(self, "id", value)


if not MYPY:
    class ComputeV1InstanceGpuClusterArgsDict(TypedDict):
        id: NotRequired[pulumi.Input[str]]
elif False:
    ComputeV1InstanceGpuClusterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ComputeV1InstanceGpuClusterArgs:
    def __init__(__self__, *,
                 id: Optional[pulumi.Input[str]] = None):
        if id is not None:
            pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "id", value)


if not MYPY:
    class ComputeV1InstanceMetadataArgsDict(TypedDict):
        pass
elif False:
    ComputeV1InstanceMetadataArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ComputeV1InstanceMetadataArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class ComputeV1InstanceNetworkInterfaceArgsDict(TypedDict):
        ip_address: pulumi.Input['ComputeV1InstanceNetworkInterfaceIpAddressArgsDict']
        """
        Private IPv4 address associated with the interface.

        ### Inner value description

        Describes an IPv4 address.
        """
        name: pulumi.Input[str]
        """
        Name for interface.
        Must be unique within instance's network interfaces
        """
        subnet_id: pulumi.Input[str]
        """
        Subnet ID
        """
        public_ip_address: NotRequired[pulumi.Input['ComputeV1InstanceNetworkInterfacePublicIpAddressArgsDict']]
        """
        Public IPv4 address associated with the interface.

        ### Inner value description

        Describes a public IP address.
        """
elif False:
    ComputeV1InstanceNetworkInterfaceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ComputeV1InstanceNetworkInterfaceArgs:
    def __init__(__self__, *,
                 ip_address: pulumi.Input['ComputeV1InstanceNetworkInterfaceIpAddressArgs'],
                 name: pulumi.Input[str],
                 subnet_id: pulumi.Input[str],
                 public_ip_address: Optional[pulumi.Input['ComputeV1InstanceNetworkInterfacePublicIpAddressArgs']] = None):
        """
        :param pulumi.Input['ComputeV1InstanceNetworkInterfaceIpAddressArgs'] ip_address: Private IPv4 address associated with the interface.
               
               ### Inner value description
               
               Describes an IPv4 address.
        :param pulumi.Input[str] name: Name for interface.
               Must be unique within instance's network interfaces
        :param pulumi.Input[str] subnet_id: Subnet ID
        :param pulumi.Input['ComputeV1InstanceNetworkInterfacePublicIpAddressArgs'] public_ip_address: Public IPv4 address associated with the interface.
               
               ### Inner value description
               
               Describes a public IP address.
        """
        pulumi.set(__self__, "ip_address", ip_address)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "subnet_id", subnet_id)
        if public_ip_address is not None:
            pulumi.set(__self__, "public_ip_address", public_ip_address)

    @property
    @pulumi.getter(name="ipAddress")
    def ip_address(self) -> pulumi.Input['ComputeV1InstanceNetworkInterfaceIpAddressArgs']:
        """
        Private IPv4 address associated with the interface.

        ### Inner value description

        Describes an IPv4 address.
        """
        return pulumi.get(self, "ip_address")

    @ip_address.setter
    def ip_address(self, value: pulumi.Input['ComputeV1InstanceNetworkInterfaceIpAddressArgs']):
        pulumi.set(self, "ip_address", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        Name for interface.
        Must be unique within instance's network interfaces
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="subnetId")
    def subnet_id(self) -> pulumi.Input[str]:
        """
        Subnet ID
        """
        return pulumi.get(self, "subnet_id")

    @subnet_id.setter
    def subnet_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "subnet_id", value)

    @property
    @pulumi.getter(name="publicIpAddress")
    def public_ip_address(self) -> Optional[pulumi.Input['ComputeV1InstanceNetworkInterfacePublicIpAddressArgs']]:
        """
        Public IPv4 address associated with the interface.

        ### Inner value description

        Describes a public IP address.
        """
        return pulumi.get(self, "public_ip_address")

    @public_ip_address.setter
    def public_ip_address(self, value: Optional[pulumi.Input['ComputeV1InstanceNetworkInterfacePublicIpAddressArgs']]):
        pulumi.set(self, "public_ip_address", value)


if not MYPY:
    class ComputeV1InstanceNetworkInterfaceIpAddressArgsDict(TypedDict):
        allocation_id: NotRequired[pulumi.Input[str]]
        """
        Allocation identifier if it was created before.
        """
elif False:
    ComputeV1InstanceNetworkInterfaceIpAddressArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ComputeV1InstanceNetworkInterfaceIpAddressArgs:
    def __init__(__self__, *,
                 allocation_id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] allocation_id: Allocation identifier if it was created before.
        """
        if allocation_id is not None:
            pulumi.set(__self__, "allocation_id", allocation_id)

    @property
    @pulumi.getter(name="allocationId")
    def allocation_id(self) -> Optional[pulumi.Input[str]]:
        """
        Allocation identifier if it was created before.
        """
        return pulumi.get(self, "allocation_id")

    @allocation_id.setter
    def allocation_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "allocation_id", value)


if not MYPY:
    class ComputeV1InstanceNetworkInterfacePublicIpAddressArgsDict(TypedDict):
        allocation_id: NotRequired[pulumi.Input[str]]
        """
        Allocation identifier if it was created before.
        """
        static: NotRequired[pulumi.Input[bool]]
        """
        If false - Allocation will be created/deleted during NetworkInterface.Allocate/NetworkInterface.Deallocate
        If true  - Allocation will be created/deleted during NetworkInterface.Create/NetworkInterface.Delete
        False by default
        """
elif False:
    ComputeV1InstanceNetworkInterfacePublicIpAddressArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ComputeV1InstanceNetworkInterfacePublicIpAddressArgs:
    def __init__(__self__, *,
                 allocation_id: Optional[pulumi.Input[str]] = None,
                 static: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[str] allocation_id: Allocation identifier if it was created before.
        :param pulumi.Input[bool] static: If false - Allocation will be created/deleted during NetworkInterface.Allocate/NetworkInterface.Deallocate
               If true  - Allocation will be created/deleted during NetworkInterface.Create/NetworkInterface.Delete
               False by default
        """
        if allocation_id is not None:
            pulumi.set(__self__, "allocation_id", allocation_id)
        if static is not None:
            pulumi.set(__self__, "static", static)

    @property
    @pulumi.getter(name="allocationId")
    def allocation_id(self) -> Optional[pulumi.Input[str]]:
        """
        Allocation identifier if it was created before.
        """
        return pulumi.get(self, "allocation_id")

    @allocation_id.setter
    def allocation_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "allocation_id", value)

    @property
    @pulumi.getter
    def static(self) -> Optional[pulumi.Input[bool]]:
        """
        If false - Allocation will be created/deleted during NetworkInterface.Allocate/NetworkInterface.Deallocate
        If true  - Allocation will be created/deleted during NetworkInterface.Create/NetworkInterface.Delete
        False by default
        """
        return pulumi.get(self, "static")

    @static.setter
    def static(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "static", value)


if not MYPY:
    class ComputeV1InstanceResourcesArgsDict(TypedDict):
        platform: pulumi.Input[str]
        preset: NotRequired[pulumi.Input[str]]
elif False:
    ComputeV1InstanceResourcesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ComputeV1InstanceResourcesArgs:
    def __init__(__self__, *,
                 platform: pulumi.Input[str],
                 preset: Optional[pulumi.Input[str]] = None):
        pulumi.set(__self__, "platform", platform)
        if preset is not None:
            pulumi.set(__self__, "preset", preset)

    @property
    @pulumi.getter
    def platform(self) -> pulumi.Input[str]:
        return pulumi.get(self, "platform")

    @platform.setter
    def platform(self, value: pulumi.Input[str]):
        pulumi.set(self, "platform", value)

    @property
    @pulumi.getter
    def preset(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "preset")

    @preset.setter
    def preset(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "preset", value)


if not MYPY:
    class ComputeV1InstanceSecondaryDiskArgsDict(TypedDict):
        attach_mode: pulumi.Input[str]
        """
        ### Supported values

        Possible values:

         - `UNSPECIFIED`
         - `READ_ONLY`
         - `READ_WRITE`
        """
        device_id: NotRequired[pulumi.Input[str]]
        """
        Specifies the user-defined identifier, allowing to use '/dev/disk/by-id/virtio-{device_id}' as a device path in mount command.
        """
        existing_disk: NotRequired[pulumi.Input['ComputeV1InstanceSecondaryDiskExistingDiskArgsDict']]
elif False:
    ComputeV1InstanceSecondaryDiskArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ComputeV1InstanceSecondaryDiskArgs:
    def __init__(__self__, *,
                 attach_mode: pulumi.Input[str],
                 device_id: Optional[pulumi.Input[str]] = None,
                 existing_disk: Optional[pulumi.Input['ComputeV1InstanceSecondaryDiskExistingDiskArgs']] = None):
        """
        :param pulumi.Input[str] attach_mode: ### Supported values
               
               Possible values:
               
                - `UNSPECIFIED`
                - `READ_ONLY`
                - `READ_WRITE`
        :param pulumi.Input[str] device_id: Specifies the user-defined identifier, allowing to use '/dev/disk/by-id/virtio-{device_id}' as a device path in mount command.
        """
        pulumi.set(__self__, "attach_mode", attach_mode)
        if device_id is not None:
            pulumi.set(__self__, "device_id", device_id)
        if existing_disk is not None:
            pulumi.set(__self__, "existing_disk", existing_disk)

    @property
    @pulumi.getter(name="attachMode")
    def attach_mode(self) -> pulumi.Input[str]:
        """
        ### Supported values

        Possible values:

         - `UNSPECIFIED`
         - `READ_ONLY`
         - `READ_WRITE`
        """
        return pulumi.get(self, "attach_mode")

    @attach_mode.setter
    def attach_mode(self, value: pulumi.Input[str]):
        pulumi.set(self, "attach_mode", value)

    @property
    @pulumi.getter(name="deviceId")
    def device_id(self) -> Optional[pulumi.Input[str]]:
        """
        Specifies the user-defined identifier, allowing to use '/dev/disk/by-id/virtio-{device_id}' as a device path in mount command.
        """
        return pulumi.get(self, "device_id")

    @device_id.setter
    def device_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "device_id", value)

    @property
    @pulumi.getter(name="existingDisk")
    def existing_disk(self) -> Optional[pulumi.Input['ComputeV1InstanceSecondaryDiskExistingDiskArgs']]:
        return pulumi.get(self, "existing_disk")

    @existing_disk.setter
    def existing_disk(self, value: Optional[pulumi.Input['ComputeV1InstanceSecondaryDiskExistingDiskArgs']]):
        pulumi.set(self, "existing_disk", value)


if not MYPY:
    class ComputeV1InstanceSecondaryDiskExistingDiskArgsDict(TypedDict):
        id: pulumi.Input[str]
elif False:
    ComputeV1InstanceSecondaryDiskExistingDiskArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ComputeV1InstanceSecondaryDiskExistingDiskArgs:
    def __init__(__self__, *,
                 id: pulumi.Input[str]):
        pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> pulumi.Input[str]:
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[str]):
        pulumi.set(self, "id", value)


if not MYPY:
    class ComputeV1InstanceStatusArgsDict(TypedDict):
        maintenance_event: NotRequired[pulumi.Input['ComputeV1InstanceStatusMaintenanceEventArgsDict']]
        network_interfaces: NotRequired[pulumi.Input[Sequence[pulumi.Input['ComputeV1InstanceStatusNetworkInterfaceArgsDict']]]]
        """
        ### Inner value description

        Describes the status of a network interface.
        """
        reconciling: NotRequired[pulumi.Input[bool]]
        """
        Indicates whether there is an ongoing operation
        """
        state: NotRequired[pulumi.Input[str]]
        """
        ### Supported values

        Possible values:

         - `UNSPECIFIED`
         - `CREATING`
         - `UPDATING`
         - `STARTING`
         - `RUNNING`
         - `STOPPING`
         - `STOPPED`
         - `DELETING`
         - `ERROR`
        """
elif False:
    ComputeV1InstanceStatusArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ComputeV1InstanceStatusArgs:
    def __init__(__self__, *,
                 maintenance_event: Optional[pulumi.Input['ComputeV1InstanceStatusMaintenanceEventArgs']] = None,
                 network_interfaces: Optional[pulumi.Input[Sequence[pulumi.Input['ComputeV1InstanceStatusNetworkInterfaceArgs']]]] = None,
                 reconciling: Optional[pulumi.Input[bool]] = None,
                 state: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['ComputeV1InstanceStatusNetworkInterfaceArgs']]] network_interfaces: ### Inner value description
               
               Describes the status of a network interface.
        :param pulumi.Input[bool] reconciling: Indicates whether there is an ongoing operation
        :param pulumi.Input[str] state: ### Supported values
               
               Possible values:
               
                - `UNSPECIFIED`
                - `CREATING`
                - `UPDATING`
                - `STARTING`
                - `RUNNING`
                - `STOPPING`
                - `STOPPED`
                - `DELETING`
                - `ERROR`
        """
        if maintenance_event is not None:
            pulumi.set(__self__, "maintenance_event", maintenance_event)
        if network_interfaces is not None:
            pulumi.set(__self__, "network_interfaces", network_interfaces)
        if reconciling is not None:
            pulumi.set(__self__, "reconciling", reconciling)
        if state is not None:
            pulumi.set(__self__, "state", state)

    @property
    @pulumi.getter(name="maintenanceEvent")
    def maintenance_event(self) -> Optional[pulumi.Input['ComputeV1InstanceStatusMaintenanceEventArgs']]:
        return pulumi.get(self, "maintenance_event")

    @maintenance_event.setter
    def maintenance_event(self, value: Optional[pulumi.Input['ComputeV1InstanceStatusMaintenanceEventArgs']]):
        pulumi.set(self, "maintenance_event", value)

    @property
    @pulumi.getter(name="networkInterfaces")
    def network_interfaces(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ComputeV1InstanceStatusNetworkInterfaceArgs']]]]:
        """
        ### Inner value description

        Describes the status of a network interface.
        """
        return pulumi.get(self, "network_interfaces")

    @network_interfaces.setter
    def network_interfaces(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ComputeV1InstanceStatusNetworkInterfaceArgs']]]]):
        pulumi.set(self, "network_interfaces", value)

    @property
    @pulumi.getter
    def reconciling(self) -> Optional[pulumi.Input[bool]]:
        """
        Indicates whether there is an ongoing operation
        """
        return pulumi.get(self, "reconciling")

    @reconciling.setter
    def reconciling(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "reconciling", value)

    @property
    @pulumi.getter
    def state(self) -> Optional[pulumi.Input[str]]:
        """
        ### Supported values

        Possible values:

         - `UNSPECIFIED`
         - `CREATING`
         - `UPDATING`
         - `STARTING`
         - `RUNNING`
         - `STOPPING`
         - `STOPPED`
         - `DELETING`
         - `ERROR`
        """
        return pulumi.get(self, "state")

    @state.setter
    def state(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "state", value)


if not MYPY:
    class ComputeV1InstanceStatusMaintenanceEventArgsDict(TypedDict):
        finished_at: NotRequired[pulumi.Input[str]]
        """
        A string representing a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ` or `YYYY-MM-DDTHH:MM:SS.SSS±HH:MM`

        Time when the maintenance event is finished
        """
        maintenance_id: NotRequired[pulumi.Input[str]]
        operation_id: NotRequired[pulumi.Input[str]]
        """
        Operation ID of stopping or recovering operation
        """
        sla_deadline_ts: NotRequired[pulumi.Input[str]]
        """
        A string representing a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ` or `YYYY-MM-DDTHH:MM:SS.SSS±HH:MM`

        Time when the instance will be force stopped
        """
        state: NotRequired[pulumi.Input[str]]
        """
        ### Supported values

        Possible values:

         - `PENDING`
         - `IN_PROGRESS`
         - `COMPLETED`
         - `CANCELLED`
        """
        ticket_id: NotRequired[pulumi.Input[str]]
        """
        Ticket key, can be transformed into url where support is talking with the client
        """
elif False:
    ComputeV1InstanceStatusMaintenanceEventArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ComputeV1InstanceStatusMaintenanceEventArgs:
    def __init__(__self__, *,
                 finished_at: Optional[pulumi.Input[str]] = None,
                 maintenance_id: Optional[pulumi.Input[str]] = None,
                 operation_id: Optional[pulumi.Input[str]] = None,
                 sla_deadline_ts: Optional[pulumi.Input[str]] = None,
                 state: Optional[pulumi.Input[str]] = None,
                 ticket_id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] finished_at: A string representing a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ` or `YYYY-MM-DDTHH:MM:SS.SSS±HH:MM`
               
               Time when the maintenance event is finished
        :param pulumi.Input[str] operation_id: Operation ID of stopping or recovering operation
        :param pulumi.Input[str] sla_deadline_ts: A string representing a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ` or `YYYY-MM-DDTHH:MM:SS.SSS±HH:MM`
               
               Time when the instance will be force stopped
        :param pulumi.Input[str] state: ### Supported values
               
               Possible values:
               
                - `PENDING`
                - `IN_PROGRESS`
                - `COMPLETED`
                - `CANCELLED`
        :param pulumi.Input[str] ticket_id: Ticket key, can be transformed into url where support is talking with the client
        """
        if finished_at is not None:
            pulumi.set(__self__, "finished_at", finished_at)
        if maintenance_id is not None:
            pulumi.set(__self__, "maintenance_id", maintenance_id)
        if operation_id is not None:
            pulumi.set(__self__, "operation_id", operation_id)
        if sla_deadline_ts is not None:
            pulumi.set(__self__, "sla_deadline_ts", sla_deadline_ts)
        if state is not None:
            pulumi.set(__self__, "state", state)
        if ticket_id is not None:
            pulumi.set(__self__, "ticket_id", ticket_id)

    @property
    @pulumi.getter(name="finishedAt")
    def finished_at(self) -> Optional[pulumi.Input[str]]:
        """
        A string representing a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ` or `YYYY-MM-DDTHH:MM:SS.SSS±HH:MM`

        Time when the maintenance event is finished
        """
        return pulumi.get(self, "finished_at")

    @finished_at.setter
    def finished_at(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "finished_at", value)

    @property
    @pulumi.getter(name="maintenanceId")
    def maintenance_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "maintenance_id")

    @maintenance_id.setter
    def maintenance_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "maintenance_id", value)

    @property
    @pulumi.getter(name="operationId")
    def operation_id(self) -> Optional[pulumi.Input[str]]:
        """
        Operation ID of stopping or recovering operation
        """
        return pulumi.get(self, "operation_id")

    @operation_id.setter
    def operation_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "operation_id", value)

    @property
    @pulumi.getter(name="slaDeadlineTs")
    def sla_deadline_ts(self) -> Optional[pulumi.Input[str]]:
        """
        A string representing a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ` or `YYYY-MM-DDTHH:MM:SS.SSS±HH:MM`

        Time when the instance will be force stopped
        """
        return pulumi.get(self, "sla_deadline_ts")

    @sla_deadline_ts.setter
    def sla_deadline_ts(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "sla_deadline_ts", value)

    @property
    @pulumi.getter
    def state(self) -> Optional[pulumi.Input[str]]:
        """
        ### Supported values

        Possible values:

         - `PENDING`
         - `IN_PROGRESS`
         - `COMPLETED`
         - `CANCELLED`
        """
        return pulumi.get(self, "state")

    @state.setter
    def state(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "state", value)

    @property
    @pulumi.getter(name="ticketId")
    def ticket_id(self) -> Optional[pulumi.Input[str]]:
        """
        Ticket key, can be transformed into url where support is talking with the client
        """
        return pulumi.get(self, "ticket_id")

    @ticket_id.setter
    def ticket_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ticket_id", value)


if not MYPY:
    class ComputeV1InstanceStatusNetworkInterfaceArgsDict(TypedDict):
        index: NotRequired[pulumi.Input[float]]
        """
        The index of the network interface
        """
        ip_address: NotRequired[pulumi.Input['ComputeV1InstanceStatusNetworkInterfaceIpAddressArgsDict']]
        """
        Effective Private IPv4 address
        """
        mac_address: NotRequired[pulumi.Input[str]]
        """
        MAC address
        """
        name: NotRequired[pulumi.Input[str]]
        """
        Name for interface.
        Unique within instance's network interfaces
        """
        public_ip_address: NotRequired[pulumi.Input['ComputeV1InstanceStatusNetworkInterfacePublicIpAddressArgsDict']]
        """
        Effective Public IPv4 address
        """
elif False:
    ComputeV1InstanceStatusNetworkInterfaceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ComputeV1InstanceStatusNetworkInterfaceArgs:
    def __init__(__self__, *,
                 index: Optional[pulumi.Input[float]] = None,
                 ip_address: Optional[pulumi.Input['ComputeV1InstanceStatusNetworkInterfaceIpAddressArgs']] = None,
                 mac_address: Optional[pulumi.Input[str]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 public_ip_address: Optional[pulumi.Input['ComputeV1InstanceStatusNetworkInterfacePublicIpAddressArgs']] = None):
        """
        :param pulumi.Input[float] index: The index of the network interface
        :param pulumi.Input['ComputeV1InstanceStatusNetworkInterfaceIpAddressArgs'] ip_address: Effective Private IPv4 address
        :param pulumi.Input[str] mac_address: MAC address
        :param pulumi.Input[str] name: Name for interface.
               Unique within instance's network interfaces
        :param pulumi.Input['ComputeV1InstanceStatusNetworkInterfacePublicIpAddressArgs'] public_ip_address: Effective Public IPv4 address
        """
        if index is not None:
            pulumi.set(__self__, "index", index)
        if ip_address is not None:
            pulumi.set(__self__, "ip_address", ip_address)
        if mac_address is not None:
            pulumi.set(__self__, "mac_address", mac_address)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if public_ip_address is not None:
            pulumi.set(__self__, "public_ip_address", public_ip_address)

    @property
    @pulumi.getter
    def index(self) -> Optional[pulumi.Input[float]]:
        """
        The index of the network interface
        """
        return pulumi.get(self, "index")

    @index.setter
    def index(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "index", value)

    @property
    @pulumi.getter(name="ipAddress")
    def ip_address(self) -> Optional[pulumi.Input['ComputeV1InstanceStatusNetworkInterfaceIpAddressArgs']]:
        """
        Effective Private IPv4 address
        """
        return pulumi.get(self, "ip_address")

    @ip_address.setter
    def ip_address(self, value: Optional[pulumi.Input['ComputeV1InstanceStatusNetworkInterfaceIpAddressArgs']]):
        pulumi.set(self, "ip_address", value)

    @property
    @pulumi.getter(name="macAddress")
    def mac_address(self) -> Optional[pulumi.Input[str]]:
        """
        MAC address
        """
        return pulumi.get(self, "mac_address")

    @mac_address.setter
    def mac_address(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "mac_address", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        Name for interface.
        Unique within instance's network interfaces
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="publicIpAddress")
    def public_ip_address(self) -> Optional[pulumi.Input['ComputeV1InstanceStatusNetworkInterfacePublicIpAddressArgs']]:
        """
        Effective Public IPv4 address
        """
        return pulumi.get(self, "public_ip_address")

    @public_ip_address.setter
    def public_ip_address(self, value: Optional[pulumi.Input['ComputeV1InstanceStatusNetworkInterfacePublicIpAddressArgs']]):
        pulumi.set(self, "public_ip_address", value)


if not MYPY:
    class ComputeV1InstanceStatusNetworkInterfaceIpAddressArgsDict(TypedDict):
        address: NotRequired[pulumi.Input[str]]
        """
        Effective private IPv4 address assigned to the interface.
        """
        allocation_id: NotRequired[pulumi.Input[str]]
        """
        Allocation identifier.
        """
elif False:
    ComputeV1InstanceStatusNetworkInterfaceIpAddressArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ComputeV1InstanceStatusNetworkInterfaceIpAddressArgs:
    def __init__(__self__, *,
                 address: Optional[pulumi.Input[str]] = None,
                 allocation_id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] address: Effective private IPv4 address assigned to the interface.
        :param pulumi.Input[str] allocation_id: Allocation identifier.
        """
        if address is not None:
            pulumi.set(__self__, "address", address)
        if allocation_id is not None:
            pulumi.set(__self__, "allocation_id", allocation_id)

    @property
    @pulumi.getter
    def address(self) -> Optional[pulumi.Input[str]]:
        """
        Effective private IPv4 address assigned to the interface.
        """
        return pulumi.get(self, "address")

    @address.setter
    def address(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "address", value)

    @property
    @pulumi.getter(name="allocationId")
    def allocation_id(self) -> Optional[pulumi.Input[str]]:
        """
        Allocation identifier.
        """
        return pulumi.get(self, "allocation_id")

    @allocation_id.setter
    def allocation_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "allocation_id", value)


if not MYPY:
    class ComputeV1InstanceStatusNetworkInterfacePublicIpAddressArgsDict(TypedDict):
        address: NotRequired[pulumi.Input[str]]
        """
        Effective public IPv4 address assigned to the interface.
        """
        allocation_id: NotRequired[pulumi.Input[str]]
        """
        Allocation identifier.
        """
elif False:
    ComputeV1InstanceStatusNetworkInterfacePublicIpAddressArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ComputeV1InstanceStatusNetworkInterfacePublicIpAddressArgs:
    def __init__(__self__, *,
                 address: Optional[pulumi.Input[str]] = None,
                 allocation_id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] address: Effective public IPv4 address assigned to the interface.
        :param pulumi.Input[str] allocation_id: Allocation identifier.
        """
        if address is not None:
            pulumi.set(__self__, "address", address)
        if allocation_id is not None:
            pulumi.set(__self__, "allocation_id", allocation_id)

    @property
    @pulumi.getter
    def address(self) -> Optional[pulumi.Input[str]]:
        """
        Effective public IPv4 address assigned to the interface.
        """
        return pulumi.get(self, "address")

    @address.setter
    def address(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "address", value)

    @property
    @pulumi.getter(name="allocationId")
    def allocation_id(self) -> Optional[pulumi.Input[str]]:
        """
        Allocation identifier.
        """
        return pulumi.get(self, "allocation_id")

    @allocation_id.setter
    def allocation_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "allocation_id", value)


if not MYPY:
    class ComputeV1alpha1DiskMetadataArgsDict(TypedDict):
        pass
elif False:
    ComputeV1alpha1DiskMetadataArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ComputeV1alpha1DiskMetadataArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class ComputeV1alpha1DiskPlacementPolicyArgsDict(TypedDict):
        placement_group_id: NotRequired[pulumi.Input[str]]
        placement_group_partition: NotRequired[pulumi.Input[float]]
elif False:
    ComputeV1alpha1DiskPlacementPolicyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ComputeV1alpha1DiskPlacementPolicyArgs:
    def __init__(__self__, *,
                 placement_group_id: Optional[pulumi.Input[str]] = None,
                 placement_group_partition: Optional[pulumi.Input[float]] = None):
        if placement_group_id is not None:
            pulumi.set(__self__, "placement_group_id", placement_group_id)
        if placement_group_partition is not None:
            pulumi.set(__self__, "placement_group_partition", placement_group_partition)

    @property
    @pulumi.getter(name="placementGroupId")
    def placement_group_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "placement_group_id")

    @placement_group_id.setter
    def placement_group_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "placement_group_id", value)

    @property
    @pulumi.getter(name="placementGroupPartition")
    def placement_group_partition(self) -> Optional[pulumi.Input[float]]:
        return pulumi.get(self, "placement_group_partition")

    @placement_group_partition.setter
    def placement_group_partition(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "placement_group_partition", value)


if not MYPY:
    class ComputeV1alpha1DiskStatusArgsDict(TypedDict):
        read_only_attachments: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        read_write_attachment: NotRequired[pulumi.Input[str]]
        reconciling: NotRequired[pulumi.Input[bool]]
        """
        Indicates whether there is an ongoing operation
        """
        size_bytes: NotRequired[pulumi.Input[float]]
        source_image_id: NotRequired[pulumi.Input[str]]
        state: NotRequired[pulumi.Input[str]]
        """
        ### Supported values

        Possible values:

         - `UNSPECIFIED`
         - `CREATING`
         - `READY`
         - `UPDATING`
         - `DELETING`
         - `ERROR`
        """
        state_description: NotRequired[pulumi.Input[str]]
elif False:
    ComputeV1alpha1DiskStatusArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ComputeV1alpha1DiskStatusArgs:
    def __init__(__self__, *,
                 read_only_attachments: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 read_write_attachment: Optional[pulumi.Input[str]] = None,
                 reconciling: Optional[pulumi.Input[bool]] = None,
                 size_bytes: Optional[pulumi.Input[float]] = None,
                 source_image_id: Optional[pulumi.Input[str]] = None,
                 state: Optional[pulumi.Input[str]] = None,
                 state_description: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[bool] reconciling: Indicates whether there is an ongoing operation
        :param pulumi.Input[str] state: ### Supported values
               
               Possible values:
               
                - `UNSPECIFIED`
                - `CREATING`
                - `READY`
                - `UPDATING`
                - `DELETING`
                - `ERROR`
        """
        if read_only_attachments is not None:
            pulumi.set(__self__, "read_only_attachments", read_only_attachments)
        if read_write_attachment is not None:
            pulumi.set(__self__, "read_write_attachment", read_write_attachment)
        if reconciling is not None:
            pulumi.set(__self__, "reconciling", reconciling)
        if size_bytes is not None:
            pulumi.set(__self__, "size_bytes", size_bytes)
        if source_image_id is not None:
            pulumi.set(__self__, "source_image_id", source_image_id)
        if state is not None:
            pulumi.set(__self__, "state", state)
        if state_description is not None:
            pulumi.set(__self__, "state_description", state_description)

    @property
    @pulumi.getter(name="readOnlyAttachments")
    def read_only_attachments(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "read_only_attachments")

    @read_only_attachments.setter
    def read_only_attachments(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "read_only_attachments", value)

    @property
    @pulumi.getter(name="readWriteAttachment")
    def read_write_attachment(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "read_write_attachment")

    @read_write_attachment.setter
    def read_write_attachment(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "read_write_attachment", value)

    @property
    @pulumi.getter
    def reconciling(self) -> Optional[pulumi.Input[bool]]:
        """
        Indicates whether there is an ongoing operation
        """
        return pulumi.get(self, "reconciling")

    @reconciling.setter
    def reconciling(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "reconciling", value)

    @property
    @pulumi.getter(name="sizeBytes")
    def size_bytes(self) -> Optional[pulumi.Input[float]]:
        return pulumi.get(self, "size_bytes")

    @size_bytes.setter
    def size_bytes(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "size_bytes", value)

    @property
    @pulumi.getter(name="sourceImageId")
    def source_image_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "source_image_id")

    @source_image_id.setter
    def source_image_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "source_image_id", value)

    @property
    @pulumi.getter
    def state(self) -> Optional[pulumi.Input[str]]:
        """
        ### Supported values

        Possible values:

         - `UNSPECIFIED`
         - `CREATING`
         - `READY`
         - `UPDATING`
         - `DELETING`
         - `ERROR`
        """
        return pulumi.get(self, "state")

    @state.setter
    def state(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "state", value)

    @property
    @pulumi.getter(name="stateDescription")
    def state_description(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "state_description")

    @state_description.setter
    def state_description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "state_description", value)


if not MYPY:
    class ComputeV1alpha1FilesystemMetadataArgsDict(TypedDict):
        pass
elif False:
    ComputeV1alpha1FilesystemMetadataArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ComputeV1alpha1FilesystemMetadataArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class ComputeV1alpha1FilesystemStatusArgsDict(TypedDict):
        read_only_attachments: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        read_write_attachments: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        reconciling: NotRequired[pulumi.Input[bool]]
        """
        Indicates whether there is an ongoing operation
        """
        size_bytes: NotRequired[pulumi.Input[float]]
        state: NotRequired[pulumi.Input[str]]
        """
        ### Supported values

        Possible values:

         - `UNSPECIFIED`
         - `CREATING`
         - `READY`
         - `UPDATING`
         - `DELETING`
         - `ERROR`
        """
        state_description: NotRequired[pulumi.Input[str]]
elif False:
    ComputeV1alpha1FilesystemStatusArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ComputeV1alpha1FilesystemStatusArgs:
    def __init__(__self__, *,
                 read_only_attachments: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 read_write_attachments: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 reconciling: Optional[pulumi.Input[bool]] = None,
                 size_bytes: Optional[pulumi.Input[float]] = None,
                 state: Optional[pulumi.Input[str]] = None,
                 state_description: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[bool] reconciling: Indicates whether there is an ongoing operation
        :param pulumi.Input[str] state: ### Supported values
               
               Possible values:
               
                - `UNSPECIFIED`
                - `CREATING`
                - `READY`
                - `UPDATING`
                - `DELETING`
                - `ERROR`
        """
        if read_only_attachments is not None:
            pulumi.set(__self__, "read_only_attachments", read_only_attachments)
        if read_write_attachments is not None:
            pulumi.set(__self__, "read_write_attachments", read_write_attachments)
        if reconciling is not None:
            pulumi.set(__self__, "reconciling", reconciling)
        if size_bytes is not None:
            pulumi.set(__self__, "size_bytes", size_bytes)
        if state is not None:
            pulumi.set(__self__, "state", state)
        if state_description is not None:
            pulumi.set(__self__, "state_description", state_description)

    @property
    @pulumi.getter(name="readOnlyAttachments")
    def read_only_attachments(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "read_only_attachments")

    @read_only_attachments.setter
    def read_only_attachments(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "read_only_attachments", value)

    @property
    @pulumi.getter(name="readWriteAttachments")
    def read_write_attachments(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "read_write_attachments")

    @read_write_attachments.setter
    def read_write_attachments(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "read_write_attachments", value)

    @property
    @pulumi.getter
    def reconciling(self) -> Optional[pulumi.Input[bool]]:
        """
        Indicates whether there is an ongoing operation
        """
        return pulumi.get(self, "reconciling")

    @reconciling.setter
    def reconciling(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "reconciling", value)

    @property
    @pulumi.getter(name="sizeBytes")
    def size_bytes(self) -> Optional[pulumi.Input[float]]:
        return pulumi.get(self, "size_bytes")

    @size_bytes.setter
    def size_bytes(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "size_bytes", value)

    @property
    @pulumi.getter
    def state(self) -> Optional[pulumi.Input[str]]:
        """
        ### Supported values

        Possible values:

         - `UNSPECIFIED`
         - `CREATING`
         - `READY`
         - `UPDATING`
         - `DELETING`
         - `ERROR`
        """
        return pulumi.get(self, "state")

    @state.setter
    def state(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "state", value)

    @property
    @pulumi.getter(name="stateDescription")
    def state_description(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "state_description")

    @state_description.setter
    def state_description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "state_description", value)


if not MYPY:
    class ComputeV1alpha1GpuClusterMetadataArgsDict(TypedDict):
        pass
elif False:
    ComputeV1alpha1GpuClusterMetadataArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ComputeV1alpha1GpuClusterMetadataArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class ComputeV1alpha1GpuClusterStatusArgsDict(TypedDict):
        instances: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        reconciling: NotRequired[pulumi.Input[bool]]
        """
        Indicates whether there is an ongoing operation
        """
elif False:
    ComputeV1alpha1GpuClusterStatusArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ComputeV1alpha1GpuClusterStatusArgs:
    def __init__(__self__, *,
                 instances: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 reconciling: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[bool] reconciling: Indicates whether there is an ongoing operation
        """
        if instances is not None:
            pulumi.set(__self__, "instances", instances)
        if reconciling is not None:
            pulumi.set(__self__, "reconciling", reconciling)

    @property
    @pulumi.getter
    def instances(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "instances")

    @instances.setter
    def instances(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "instances", value)

    @property
    @pulumi.getter
    def reconciling(self) -> Optional[pulumi.Input[bool]]:
        """
        Indicates whether there is an ongoing operation
        """
        return pulumi.get(self, "reconciling")

    @reconciling.setter
    def reconciling(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "reconciling", value)


if not MYPY:
    class ComputeV1alpha1InstanceBootDiskArgsDict(TypedDict):
        attach_mode: pulumi.Input[str]
        """
        ### Supported values

        Possible values:

         - `UNSPECIFIED`
         - `READ_ONLY`
         - `READ_WRITE`
        """
        device_name: NotRequired[pulumi.Input[str]]
        """
        Specifies the user-defined identifier, allowing to use '/dev/disk/by-id/virtio-{device_name}' as a device path in mount command.
        """
        existing_disk: NotRequired[pulumi.Input['ComputeV1alpha1InstanceBootDiskExistingDiskArgsDict']]
elif False:
    ComputeV1alpha1InstanceBootDiskArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ComputeV1alpha1InstanceBootDiskArgs:
    def __init__(__self__, *,
                 attach_mode: pulumi.Input[str],
                 device_name: Optional[pulumi.Input[str]] = None,
                 existing_disk: Optional[pulumi.Input['ComputeV1alpha1InstanceBootDiskExistingDiskArgs']] = None):
        """
        :param pulumi.Input[str] attach_mode: ### Supported values
               
               Possible values:
               
                - `UNSPECIFIED`
                - `READ_ONLY`
                - `READ_WRITE`
        :param pulumi.Input[str] device_name: Specifies the user-defined identifier, allowing to use '/dev/disk/by-id/virtio-{device_name}' as a device path in mount command.
        """
        pulumi.set(__self__, "attach_mode", attach_mode)
        if device_name is not None:
            pulumi.set(__self__, "device_name", device_name)
        if existing_disk is not None:
            pulumi.set(__self__, "existing_disk", existing_disk)

    @property
    @pulumi.getter(name="attachMode")
    def attach_mode(self) -> pulumi.Input[str]:
        """
        ### Supported values

        Possible values:

         - `UNSPECIFIED`
         - `READ_ONLY`
         - `READ_WRITE`
        """
        return pulumi.get(self, "attach_mode")

    @attach_mode.setter
    def attach_mode(self, value: pulumi.Input[str]):
        pulumi.set(self, "attach_mode", value)

    @property
    @pulumi.getter(name="deviceName")
    def device_name(self) -> Optional[pulumi.Input[str]]:
        """
        Specifies the user-defined identifier, allowing to use '/dev/disk/by-id/virtio-{device_name}' as a device path in mount command.
        """
        return pulumi.get(self, "device_name")

    @device_name.setter
    def device_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "device_name", value)

    @property
    @pulumi.getter(name="existingDisk")
    def existing_disk(self) -> Optional[pulumi.Input['ComputeV1alpha1InstanceBootDiskExistingDiskArgs']]:
        return pulumi.get(self, "existing_disk")

    @existing_disk.setter
    def existing_disk(self, value: Optional[pulumi.Input['ComputeV1alpha1InstanceBootDiskExistingDiskArgs']]):
        pulumi.set(self, "existing_disk", value)


if not MYPY:
    class ComputeV1alpha1InstanceBootDiskExistingDiskArgsDict(TypedDict):
        id: pulumi.Input[str]
elif False:
    ComputeV1alpha1InstanceBootDiskExistingDiskArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ComputeV1alpha1InstanceBootDiskExistingDiskArgs:
    def __init__(__self__, *,
                 id: pulumi.Input[str]):
        pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> pulumi.Input[str]:
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[str]):
        pulumi.set(self, "id", value)


if not MYPY:
    class ComputeV1alpha1InstanceFilesystemArgsDict(TypedDict):
        attach_mode: pulumi.Input[str]
        """
        ### Supported values

        Possible values:

         - `UNSPECIFIED`
         - `READ_ONLY`
         - `READ_WRITE`
        """
        device_name: pulumi.Input[str]
        """
        Specifies the user-defined identifier, allowing to use it as a device in mount command.
        """
        existing_filesystem: NotRequired[pulumi.Input['ComputeV1alpha1InstanceFilesystemExistingFilesystemArgsDict']]
elif False:
    ComputeV1alpha1InstanceFilesystemArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ComputeV1alpha1InstanceFilesystemArgs:
    def __init__(__self__, *,
                 attach_mode: pulumi.Input[str],
                 device_name: pulumi.Input[str],
                 existing_filesystem: Optional[pulumi.Input['ComputeV1alpha1InstanceFilesystemExistingFilesystemArgs']] = None):
        """
        :param pulumi.Input[str] attach_mode: ### Supported values
               
               Possible values:
               
                - `UNSPECIFIED`
                - `READ_ONLY`
                - `READ_WRITE`
        :param pulumi.Input[str] device_name: Specifies the user-defined identifier, allowing to use it as a device in mount command.
        """
        pulumi.set(__self__, "attach_mode", attach_mode)
        pulumi.set(__self__, "device_name", device_name)
        if existing_filesystem is not None:
            pulumi.set(__self__, "existing_filesystem", existing_filesystem)

    @property
    @pulumi.getter(name="attachMode")
    def attach_mode(self) -> pulumi.Input[str]:
        """
        ### Supported values

        Possible values:

         - `UNSPECIFIED`
         - `READ_ONLY`
         - `READ_WRITE`
        """
        return pulumi.get(self, "attach_mode")

    @attach_mode.setter
    def attach_mode(self, value: pulumi.Input[str]):
        pulumi.set(self, "attach_mode", value)

    @property
    @pulumi.getter(name="deviceName")
    def device_name(self) -> pulumi.Input[str]:
        """
        Specifies the user-defined identifier, allowing to use it as a device in mount command.
        """
        return pulumi.get(self, "device_name")

    @device_name.setter
    def device_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "device_name", value)

    @property
    @pulumi.getter(name="existingFilesystem")
    def existing_filesystem(self) -> Optional[pulumi.Input['ComputeV1alpha1InstanceFilesystemExistingFilesystemArgs']]:
        return pulumi.get(self, "existing_filesystem")

    @existing_filesystem.setter
    def existing_filesystem(self, value: Optional[pulumi.Input['ComputeV1alpha1InstanceFilesystemExistingFilesystemArgs']]):
        pulumi.set(self, "existing_filesystem", value)


if not MYPY:
    class ComputeV1alpha1InstanceFilesystemExistingFilesystemArgsDict(TypedDict):
        id: pulumi.Input[str]
elif False:
    ComputeV1alpha1InstanceFilesystemExistingFilesystemArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ComputeV1alpha1InstanceFilesystemExistingFilesystemArgs:
    def __init__(__self__, *,
                 id: pulumi.Input[str]):
        pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> pulumi.Input[str]:
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[str]):
        pulumi.set(self, "id", value)


if not MYPY:
    class ComputeV1alpha1InstanceGpuClusterArgsDict(TypedDict):
        id: NotRequired[pulumi.Input[str]]
elif False:
    ComputeV1alpha1InstanceGpuClusterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ComputeV1alpha1InstanceGpuClusterArgs:
    def __init__(__self__, *,
                 id: Optional[pulumi.Input[str]] = None):
        if id is not None:
            pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "id", value)


if not MYPY:
    class ComputeV1alpha1InstanceMetadataArgsDict(TypedDict):
        pass
elif False:
    ComputeV1alpha1InstanceMetadataArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ComputeV1alpha1InstanceMetadataArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class ComputeV1alpha1InstanceNetworkInterfaceArgsDict(TypedDict):
        name: pulumi.Input[str]
        """
        Name for interface.
        Must be unique within instance's network interfaces
        """
        subnet_id: pulumi.Input[str]
        """
        Subnet ID
        """
        ip_address: NotRequired[pulumi.Input['ComputeV1alpha1InstanceNetworkInterfaceIpAddressArgsDict']]
        """
        Private IPv4 address associated with the interface.

        ### Inner value description

        Describes an IPv4 address.
        """
        public_ip_address: NotRequired[pulumi.Input['ComputeV1alpha1InstanceNetworkInterfacePublicIpAddressArgsDict']]
        """
        Public IPv4 address associated with the interface.

        ### Inner value description

        Describes a public IP address.
        """
elif False:
    ComputeV1alpha1InstanceNetworkInterfaceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ComputeV1alpha1InstanceNetworkInterfaceArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 subnet_id: pulumi.Input[str],
                 ip_address: Optional[pulumi.Input['ComputeV1alpha1InstanceNetworkInterfaceIpAddressArgs']] = None,
                 public_ip_address: Optional[pulumi.Input['ComputeV1alpha1InstanceNetworkInterfacePublicIpAddressArgs']] = None):
        """
        :param pulumi.Input[str] name: Name for interface.
               Must be unique within instance's network interfaces
        :param pulumi.Input[str] subnet_id: Subnet ID
        :param pulumi.Input['ComputeV1alpha1InstanceNetworkInterfaceIpAddressArgs'] ip_address: Private IPv4 address associated with the interface.
               
               ### Inner value description
               
               Describes an IPv4 address.
        :param pulumi.Input['ComputeV1alpha1InstanceNetworkInterfacePublicIpAddressArgs'] public_ip_address: Public IPv4 address associated with the interface.
               
               ### Inner value description
               
               Describes a public IP address.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "subnet_id", subnet_id)
        if ip_address is not None:
            pulumi.set(__self__, "ip_address", ip_address)
        if public_ip_address is not None:
            pulumi.set(__self__, "public_ip_address", public_ip_address)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        Name for interface.
        Must be unique within instance's network interfaces
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="subnetId")
    def subnet_id(self) -> pulumi.Input[str]:
        """
        Subnet ID
        """
        return pulumi.get(self, "subnet_id")

    @subnet_id.setter
    def subnet_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "subnet_id", value)

    @property
    @pulumi.getter(name="ipAddress")
    def ip_address(self) -> Optional[pulumi.Input['ComputeV1alpha1InstanceNetworkInterfaceIpAddressArgs']]:
        """
        Private IPv4 address associated with the interface.

        ### Inner value description

        Describes an IPv4 address.
        """
        return pulumi.get(self, "ip_address")

    @ip_address.setter
    def ip_address(self, value: Optional[pulumi.Input['ComputeV1alpha1InstanceNetworkInterfaceIpAddressArgs']]):
        pulumi.set(self, "ip_address", value)

    @property
    @pulumi.getter(name="publicIpAddress")
    def public_ip_address(self) -> Optional[pulumi.Input['ComputeV1alpha1InstanceNetworkInterfacePublicIpAddressArgs']]:
        """
        Public IPv4 address associated with the interface.

        ### Inner value description

        Describes a public IP address.
        """
        return pulumi.get(self, "public_ip_address")

    @public_ip_address.setter
    def public_ip_address(self, value: Optional[pulumi.Input['ComputeV1alpha1InstanceNetworkInterfacePublicIpAddressArgs']]):
        pulumi.set(self, "public_ip_address", value)


if not MYPY:
    class ComputeV1alpha1InstanceNetworkInterfaceIpAddressArgsDict(TypedDict):
        allocation_id: NotRequired[pulumi.Input[str]]
        """
        Allocation identifier if it was created before.
        """
elif False:
    ComputeV1alpha1InstanceNetworkInterfaceIpAddressArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ComputeV1alpha1InstanceNetworkInterfaceIpAddressArgs:
    def __init__(__self__, *,
                 allocation_id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] allocation_id: Allocation identifier if it was created before.
        """
        if allocation_id is not None:
            pulumi.set(__self__, "allocation_id", allocation_id)

    @property
    @pulumi.getter(name="allocationId")
    def allocation_id(self) -> Optional[pulumi.Input[str]]:
        """
        Allocation identifier if it was created before.
        """
        return pulumi.get(self, "allocation_id")

    @allocation_id.setter
    def allocation_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "allocation_id", value)


if not MYPY:
    class ComputeV1alpha1InstanceNetworkInterfacePublicIpAddressArgsDict(TypedDict):
        allocation_id: NotRequired[pulumi.Input[str]]
        """
        Allocation identifier if it was created before.
        """
        static: NotRequired[pulumi.Input[bool]]
        """
        If false - Lifecycle of allocation depends on NetworkInterface.Allocate/NetworkInterface.Deallocate
        If true  - Lifecycle of allocation depends on NetworkInterface.Create/NetworkInterface.Delete
        False by default
        """
elif False:
    ComputeV1alpha1InstanceNetworkInterfacePublicIpAddressArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ComputeV1alpha1InstanceNetworkInterfacePublicIpAddressArgs:
    def __init__(__self__, *,
                 allocation_id: Optional[pulumi.Input[str]] = None,
                 static: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[str] allocation_id: Allocation identifier if it was created before.
        :param pulumi.Input[bool] static: If false - Lifecycle of allocation depends on NetworkInterface.Allocate/NetworkInterface.Deallocate
               If true  - Lifecycle of allocation depends on NetworkInterface.Create/NetworkInterface.Delete
               False by default
        """
        if allocation_id is not None:
            pulumi.set(__self__, "allocation_id", allocation_id)
        if static is not None:
            pulumi.set(__self__, "static", static)

    @property
    @pulumi.getter(name="allocationId")
    def allocation_id(self) -> Optional[pulumi.Input[str]]:
        """
        Allocation identifier if it was created before.
        """
        return pulumi.get(self, "allocation_id")

    @allocation_id.setter
    def allocation_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "allocation_id", value)

    @property
    @pulumi.getter
    def static(self) -> Optional[pulumi.Input[bool]]:
        """
        If false - Lifecycle of allocation depends on NetworkInterface.Allocate/NetworkInterface.Deallocate
        If true  - Lifecycle of allocation depends on NetworkInterface.Create/NetworkInterface.Delete
        False by default
        """
        return pulumi.get(self, "static")

    @static.setter
    def static(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "static", value)


if not MYPY:
    class ComputeV1alpha1InstanceResourcesArgsDict(TypedDict):
        platform: pulumi.Input[str]
        preset: NotRequired[pulumi.Input[str]]
elif False:
    ComputeV1alpha1InstanceResourcesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ComputeV1alpha1InstanceResourcesArgs:
    def __init__(__self__, *,
                 platform: pulumi.Input[str],
                 preset: Optional[pulumi.Input[str]] = None):
        pulumi.set(__self__, "platform", platform)
        if preset is not None:
            pulumi.set(__self__, "preset", preset)

    @property
    @pulumi.getter
    def platform(self) -> pulumi.Input[str]:
        return pulumi.get(self, "platform")

    @platform.setter
    def platform(self, value: pulumi.Input[str]):
        pulumi.set(self, "platform", value)

    @property
    @pulumi.getter
    def preset(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "preset")

    @preset.setter
    def preset(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "preset", value)


if not MYPY:
    class ComputeV1alpha1InstanceSecondaryDiskArgsDict(TypedDict):
        attach_mode: pulumi.Input[str]
        """
        ### Supported values

        Possible values:

         - `UNSPECIFIED`
         - `READ_ONLY`
         - `READ_WRITE`
        """
        device_name: NotRequired[pulumi.Input[str]]
        """
        Specifies the user-defined identifier, allowing to use '/dev/disk/by-id/virtio-{device_name}' as a device path in mount command.
        """
        existing_disk: NotRequired[pulumi.Input['ComputeV1alpha1InstanceSecondaryDiskExistingDiskArgsDict']]
elif False:
    ComputeV1alpha1InstanceSecondaryDiskArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ComputeV1alpha1InstanceSecondaryDiskArgs:
    def __init__(__self__, *,
                 attach_mode: pulumi.Input[str],
                 device_name: Optional[pulumi.Input[str]] = None,
                 existing_disk: Optional[pulumi.Input['ComputeV1alpha1InstanceSecondaryDiskExistingDiskArgs']] = None):
        """
        :param pulumi.Input[str] attach_mode: ### Supported values
               
               Possible values:
               
                - `UNSPECIFIED`
                - `READ_ONLY`
                - `READ_WRITE`
        :param pulumi.Input[str] device_name: Specifies the user-defined identifier, allowing to use '/dev/disk/by-id/virtio-{device_name}' as a device path in mount command.
        """
        pulumi.set(__self__, "attach_mode", attach_mode)
        if device_name is not None:
            pulumi.set(__self__, "device_name", device_name)
        if existing_disk is not None:
            pulumi.set(__self__, "existing_disk", existing_disk)

    @property
    @pulumi.getter(name="attachMode")
    def attach_mode(self) -> pulumi.Input[str]:
        """
        ### Supported values

        Possible values:

         - `UNSPECIFIED`
         - `READ_ONLY`
         - `READ_WRITE`
        """
        return pulumi.get(self, "attach_mode")

    @attach_mode.setter
    def attach_mode(self, value: pulumi.Input[str]):
        pulumi.set(self, "attach_mode", value)

    @property
    @pulumi.getter(name="deviceName")
    def device_name(self) -> Optional[pulumi.Input[str]]:
        """
        Specifies the user-defined identifier, allowing to use '/dev/disk/by-id/virtio-{device_name}' as a device path in mount command.
        """
        return pulumi.get(self, "device_name")

    @device_name.setter
    def device_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "device_name", value)

    @property
    @pulumi.getter(name="existingDisk")
    def existing_disk(self) -> Optional[pulumi.Input['ComputeV1alpha1InstanceSecondaryDiskExistingDiskArgs']]:
        return pulumi.get(self, "existing_disk")

    @existing_disk.setter
    def existing_disk(self, value: Optional[pulumi.Input['ComputeV1alpha1InstanceSecondaryDiskExistingDiskArgs']]):
        pulumi.set(self, "existing_disk", value)


if not MYPY:
    class ComputeV1alpha1InstanceSecondaryDiskExistingDiskArgsDict(TypedDict):
        id: pulumi.Input[str]
elif False:
    ComputeV1alpha1InstanceSecondaryDiskExistingDiskArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ComputeV1alpha1InstanceSecondaryDiskExistingDiskArgs:
    def __init__(__self__, *,
                 id: pulumi.Input[str]):
        pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> pulumi.Input[str]:
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[str]):
        pulumi.set(self, "id", value)


if not MYPY:
    class ComputeV1alpha1InstanceStatusArgsDict(TypedDict):
        network_interfaces: NotRequired[pulumi.Input[Sequence[pulumi.Input['ComputeV1alpha1InstanceStatusNetworkInterfaceArgsDict']]]]
        """
        ### Inner value description

        Describes the status of a network interface.
        """
        reconciling: NotRequired[pulumi.Input[bool]]
        """
        Indicates whether there is an ongoing operation
        """
        state: NotRequired[pulumi.Input[str]]
        """
        ### Supported values

        Possible values:

         - `UNSPECIFIED`
         - `CREATING`
         - `UPDATING`
         - `STARTING`
         - `RUNNING`
         - `STOPPING`
         - `STOPPED`
         - `DELETING`
         - `ERROR`
        """
elif False:
    ComputeV1alpha1InstanceStatusArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ComputeV1alpha1InstanceStatusArgs:
    def __init__(__self__, *,
                 network_interfaces: Optional[pulumi.Input[Sequence[pulumi.Input['ComputeV1alpha1InstanceStatusNetworkInterfaceArgs']]]] = None,
                 reconciling: Optional[pulumi.Input[bool]] = None,
                 state: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['ComputeV1alpha1InstanceStatusNetworkInterfaceArgs']]] network_interfaces: ### Inner value description
               
               Describes the status of a network interface.
        :param pulumi.Input[bool] reconciling: Indicates whether there is an ongoing operation
        :param pulumi.Input[str] state: ### Supported values
               
               Possible values:
               
                - `UNSPECIFIED`
                - `CREATING`
                - `UPDATING`
                - `STARTING`
                - `RUNNING`
                - `STOPPING`
                - `STOPPED`
                - `DELETING`
                - `ERROR`
        """
        if network_interfaces is not None:
            pulumi.set(__self__, "network_interfaces", network_interfaces)
        if reconciling is not None:
            pulumi.set(__self__, "reconciling", reconciling)
        if state is not None:
            pulumi.set(__self__, "state", state)

    @property
    @pulumi.getter(name="networkInterfaces")
    def network_interfaces(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ComputeV1alpha1InstanceStatusNetworkInterfaceArgs']]]]:
        """
        ### Inner value description

        Describes the status of a network interface.
        """
        return pulumi.get(self, "network_interfaces")

    @network_interfaces.setter
    def network_interfaces(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ComputeV1alpha1InstanceStatusNetworkInterfaceArgs']]]]):
        pulumi.set(self, "network_interfaces", value)

    @property
    @pulumi.getter
    def reconciling(self) -> Optional[pulumi.Input[bool]]:
        """
        Indicates whether there is an ongoing operation
        """
        return pulumi.get(self, "reconciling")

    @reconciling.setter
    def reconciling(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "reconciling", value)

    @property
    @pulumi.getter
    def state(self) -> Optional[pulumi.Input[str]]:
        """
        ### Supported values

        Possible values:

         - `UNSPECIFIED`
         - `CREATING`
         - `UPDATING`
         - `STARTING`
         - `RUNNING`
         - `STOPPING`
         - `STOPPED`
         - `DELETING`
         - `ERROR`
        """
        return pulumi.get(self, "state")

    @state.setter
    def state(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "state", value)


if not MYPY:
    class ComputeV1alpha1InstanceStatusNetworkInterfaceArgsDict(TypedDict):
        index: NotRequired[pulumi.Input[float]]
        """
        The index of the network interface
        """
        ip_address: NotRequired[pulumi.Input['ComputeV1alpha1InstanceStatusNetworkInterfaceIpAddressArgsDict']]
        """
        Effective Private IPv4 address
        """
        mac_address: NotRequired[pulumi.Input[str]]
        """
        MAC address
        """
        name: NotRequired[pulumi.Input[str]]
        """
        Name for interface.
        Unique within instance's network interfaces
        """
        public_ip_address: NotRequired[pulumi.Input['ComputeV1alpha1InstanceStatusNetworkInterfacePublicIpAddressArgsDict']]
        """
        Effective Public IPv4 address
        """
elif False:
    ComputeV1alpha1InstanceStatusNetworkInterfaceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ComputeV1alpha1InstanceStatusNetworkInterfaceArgs:
    def __init__(__self__, *,
                 index: Optional[pulumi.Input[float]] = None,
                 ip_address: Optional[pulumi.Input['ComputeV1alpha1InstanceStatusNetworkInterfaceIpAddressArgs']] = None,
                 mac_address: Optional[pulumi.Input[str]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 public_ip_address: Optional[pulumi.Input['ComputeV1alpha1InstanceStatusNetworkInterfacePublicIpAddressArgs']] = None):
        """
        :param pulumi.Input[float] index: The index of the network interface
        :param pulumi.Input['ComputeV1alpha1InstanceStatusNetworkInterfaceIpAddressArgs'] ip_address: Effective Private IPv4 address
        :param pulumi.Input[str] mac_address: MAC address
        :param pulumi.Input[str] name: Name for interface.
               Unique within instance's network interfaces
        :param pulumi.Input['ComputeV1alpha1InstanceStatusNetworkInterfacePublicIpAddressArgs'] public_ip_address: Effective Public IPv4 address
        """
        if index is not None:
            pulumi.set(__self__, "index", index)
        if ip_address is not None:
            pulumi.set(__self__, "ip_address", ip_address)
        if mac_address is not None:
            pulumi.set(__self__, "mac_address", mac_address)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if public_ip_address is not None:
            pulumi.set(__self__, "public_ip_address", public_ip_address)

    @property
    @pulumi.getter
    def index(self) -> Optional[pulumi.Input[float]]:
        """
        The index of the network interface
        """
        return pulumi.get(self, "index")

    @index.setter
    def index(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "index", value)

    @property
    @pulumi.getter(name="ipAddress")
    def ip_address(self) -> Optional[pulumi.Input['ComputeV1alpha1InstanceStatusNetworkInterfaceIpAddressArgs']]:
        """
        Effective Private IPv4 address
        """
        return pulumi.get(self, "ip_address")

    @ip_address.setter
    def ip_address(self, value: Optional[pulumi.Input['ComputeV1alpha1InstanceStatusNetworkInterfaceIpAddressArgs']]):
        pulumi.set(self, "ip_address", value)

    @property
    @pulumi.getter(name="macAddress")
    def mac_address(self) -> Optional[pulumi.Input[str]]:
        """
        MAC address
        """
        return pulumi.get(self, "mac_address")

    @mac_address.setter
    def mac_address(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "mac_address", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        Name for interface.
        Unique within instance's network interfaces
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="publicIpAddress")
    def public_ip_address(self) -> Optional[pulumi.Input['ComputeV1alpha1InstanceStatusNetworkInterfacePublicIpAddressArgs']]:
        """
        Effective Public IPv4 address
        """
        return pulumi.get(self, "public_ip_address")

    @public_ip_address.setter
    def public_ip_address(self, value: Optional[pulumi.Input['ComputeV1alpha1InstanceStatusNetworkInterfacePublicIpAddressArgs']]):
        pulumi.set(self, "public_ip_address", value)


if not MYPY:
    class ComputeV1alpha1InstanceStatusNetworkInterfaceIpAddressArgsDict(TypedDict):
        address: NotRequired[pulumi.Input[str]]
        """
        Effective private IPv4 address assigned to the interface.
        """
        allocation_id: NotRequired[pulumi.Input[str]]
        """
        Allocation identifier.
        """
elif False:
    ComputeV1alpha1InstanceStatusNetworkInterfaceIpAddressArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ComputeV1alpha1InstanceStatusNetworkInterfaceIpAddressArgs:
    def __init__(__self__, *,
                 address: Optional[pulumi.Input[str]] = None,
                 allocation_id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] address: Effective private IPv4 address assigned to the interface.
        :param pulumi.Input[str] allocation_id: Allocation identifier.
        """
        if address is not None:
            pulumi.set(__self__, "address", address)
        if allocation_id is not None:
            pulumi.set(__self__, "allocation_id", allocation_id)

    @property
    @pulumi.getter
    def address(self) -> Optional[pulumi.Input[str]]:
        """
        Effective private IPv4 address assigned to the interface.
        """
        return pulumi.get(self, "address")

    @address.setter
    def address(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "address", value)

    @property
    @pulumi.getter(name="allocationId")
    def allocation_id(self) -> Optional[pulumi.Input[str]]:
        """
        Allocation identifier.
        """
        return pulumi.get(self, "allocation_id")

    @allocation_id.setter
    def allocation_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "allocation_id", value)


if not MYPY:
    class ComputeV1alpha1InstanceStatusNetworkInterfacePublicIpAddressArgsDict(TypedDict):
        address: NotRequired[pulumi.Input[str]]
        """
        Effective public IPv4 address assigned to the interface.
        """
        allocation_id: NotRequired[pulumi.Input[str]]
        """
        Allocation identifier.
        """
elif False:
    ComputeV1alpha1InstanceStatusNetworkInterfacePublicIpAddressArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ComputeV1alpha1InstanceStatusNetworkInterfacePublicIpAddressArgs:
    def __init__(__self__, *,
                 address: Optional[pulumi.Input[str]] = None,
                 allocation_id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] address: Effective public IPv4 address assigned to the interface.
        :param pulumi.Input[str] allocation_id: Allocation identifier.
        """
        if address is not None:
            pulumi.set(__self__, "address", address)
        if allocation_id is not None:
            pulumi.set(__self__, "allocation_id", allocation_id)

    @property
    @pulumi.getter
    def address(self) -> Optional[pulumi.Input[str]]:
        """
        Effective public IPv4 address assigned to the interface.
        """
        return pulumi.get(self, "address")

    @address.setter
    def address(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "address", value)

    @property
    @pulumi.getter(name="allocationId")
    def allocation_id(self) -> Optional[pulumi.Input[str]]:
        """
        Allocation identifier.
        """
        return pulumi.get(self, "allocation_id")

    @allocation_id.setter
    def allocation_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "allocation_id", value)


if not MYPY:
    class IamV1AuthPublicKeyAccountArgsDict(TypedDict):
        anonymous_account: NotRequired[pulumi.Input['IamV1AuthPublicKeyAccountAnonymousAccountArgsDict']]
        """
        *Cannot be set alongside  or service_account.*
        """
        service_account: NotRequired[pulumi.Input['IamV1AuthPublicKeyAccountServiceAccountArgsDict']]
        """
        *Cannot be set alongside  or anonymous_account.*
        """
        user_account: NotRequired[pulumi.Input['IamV1AuthPublicKeyAccountUserAccountArgsDict']]
        """
        *Cannot be set alongside  or anonymous_account.*
        """
elif False:
    IamV1AuthPublicKeyAccountArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class IamV1AuthPublicKeyAccountArgs:
    def __init__(__self__, *,
                 anonymous_account: Optional[pulumi.Input['IamV1AuthPublicKeyAccountAnonymousAccountArgs']] = None,
                 service_account: Optional[pulumi.Input['IamV1AuthPublicKeyAccountServiceAccountArgs']] = None,
                 user_account: Optional[pulumi.Input['IamV1AuthPublicKeyAccountUserAccountArgs']] = None):
        """
        :param pulumi.Input['IamV1AuthPublicKeyAccountAnonymousAccountArgs'] anonymous_account: *Cannot be set alongside  or service_account.*
        :param pulumi.Input['IamV1AuthPublicKeyAccountServiceAccountArgs'] service_account: *Cannot be set alongside  or anonymous_account.*
        :param pulumi.Input['IamV1AuthPublicKeyAccountUserAccountArgs'] user_account: *Cannot be set alongside  or anonymous_account.*
        """
        if anonymous_account is not None:
            pulumi.set(__self__, "anonymous_account", anonymous_account)
        if service_account is not None:
            pulumi.set(__self__, "service_account", service_account)
        if user_account is not None:
            pulumi.set(__self__, "user_account", user_account)

    @property
    @pulumi.getter(name="anonymousAccount")
    def anonymous_account(self) -> Optional[pulumi.Input['IamV1AuthPublicKeyAccountAnonymousAccountArgs']]:
        """
        *Cannot be set alongside  or service_account.*
        """
        return pulumi.get(self, "anonymous_account")

    @anonymous_account.setter
    def anonymous_account(self, value: Optional[pulumi.Input['IamV1AuthPublicKeyAccountAnonymousAccountArgs']]):
        pulumi.set(self, "anonymous_account", value)

    @property
    @pulumi.getter(name="serviceAccount")
    def service_account(self) -> Optional[pulumi.Input['IamV1AuthPublicKeyAccountServiceAccountArgs']]:
        """
        *Cannot be set alongside  or anonymous_account.*
        """
        return pulumi.get(self, "service_account")

    @service_account.setter
    def service_account(self, value: Optional[pulumi.Input['IamV1AuthPublicKeyAccountServiceAccountArgs']]):
        pulumi.set(self, "service_account", value)

    @property
    @pulumi.getter(name="userAccount")
    def user_account(self) -> Optional[pulumi.Input['IamV1AuthPublicKeyAccountUserAccountArgs']]:
        """
        *Cannot be set alongside  or anonymous_account.*
        """
        return pulumi.get(self, "user_account")

    @user_account.setter
    def user_account(self, value: Optional[pulumi.Input['IamV1AuthPublicKeyAccountUserAccountArgs']]):
        pulumi.set(self, "user_account", value)


if not MYPY:
    class IamV1AuthPublicKeyAccountAnonymousAccountArgsDict(TypedDict):
        pass
elif False:
    IamV1AuthPublicKeyAccountAnonymousAccountArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class IamV1AuthPublicKeyAccountAnonymousAccountArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class IamV1AuthPublicKeyAccountServiceAccountArgsDict(TypedDict):
        id: NotRequired[pulumi.Input[str]]
elif False:
    IamV1AuthPublicKeyAccountServiceAccountArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class IamV1AuthPublicKeyAccountServiceAccountArgs:
    def __init__(__self__, *,
                 id: Optional[pulumi.Input[str]] = None):
        if id is not None:
            pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "id", value)


if not MYPY:
    class IamV1AuthPublicKeyAccountUserAccountArgsDict(TypedDict):
        id: NotRequired[pulumi.Input[str]]
elif False:
    IamV1AuthPublicKeyAccountUserAccountArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class IamV1AuthPublicKeyAccountUserAccountArgs:
    def __init__(__self__, *,
                 id: Optional[pulumi.Input[str]] = None):
        if id is not None:
            pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "id", value)


if not MYPY:
    class IamV1AuthPublicKeyMetadataArgsDict(TypedDict):
        pass
elif False:
    IamV1AuthPublicKeyMetadataArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class IamV1AuthPublicKeyMetadataArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class IamV1AuthPublicKeyStatusArgsDict(TypedDict):
        algorithm: NotRequired[pulumi.Input[str]]
        fingerprint: NotRequired[pulumi.Input[str]]
        key_size: NotRequired[pulumi.Input[float]]
        state: NotRequired[pulumi.Input[str]]
        """
        ### Supported values

        Possible values:

         - `STATE_UNSPECIFIED`
         - `ACTIVE`
         - `INACTIVE`
         - `EXPIRED`
         - `DELETING`
         - `DELETED`
        """
elif False:
    IamV1AuthPublicKeyStatusArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class IamV1AuthPublicKeyStatusArgs:
    def __init__(__self__, *,
                 algorithm: Optional[pulumi.Input[str]] = None,
                 fingerprint: Optional[pulumi.Input[str]] = None,
                 key_size: Optional[pulumi.Input[float]] = None,
                 state: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] state: ### Supported values
               
               Possible values:
               
                - `STATE_UNSPECIFIED`
                - `ACTIVE`
                - `INACTIVE`
                - `EXPIRED`
                - `DELETING`
                - `DELETED`
        """
        if algorithm is not None:
            pulumi.set(__self__, "algorithm", algorithm)
        if fingerprint is not None:
            pulumi.set(__self__, "fingerprint", fingerprint)
        if key_size is not None:
            pulumi.set(__self__, "key_size", key_size)
        if state is not None:
            pulumi.set(__self__, "state", state)

    @property
    @pulumi.getter
    def algorithm(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "algorithm")

    @algorithm.setter
    def algorithm(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "algorithm", value)

    @property
    @pulumi.getter
    def fingerprint(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "fingerprint")

    @fingerprint.setter
    def fingerprint(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "fingerprint", value)

    @property
    @pulumi.getter(name="keySize")
    def key_size(self) -> Optional[pulumi.Input[float]]:
        return pulumi.get(self, "key_size")

    @key_size.setter
    def key_size(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "key_size", value)

    @property
    @pulumi.getter
    def state(self) -> Optional[pulumi.Input[str]]:
        """
        ### Supported values

        Possible values:

         - `STATE_UNSPECIFIED`
         - `ACTIVE`
         - `INACTIVE`
         - `EXPIRED`
         - `DELETING`
         - `DELETED`
        """
        return pulumi.get(self, "state")

    @state.setter
    def state(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "state", value)


if not MYPY:
    class IamV1FederationCertificateMetadataArgsDict(TypedDict):
        pass
elif False:
    IamV1FederationCertificateMetadataArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class IamV1FederationCertificateMetadataArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class IamV1FederationCertificateStatusArgsDict(TypedDict):
        algorithm: NotRequired[pulumi.Input[str]]
        key_size: NotRequired[pulumi.Input[float]]
        not_after: NotRequired[pulumi.Input[str]]
        """
        A string representing a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ` or `YYYY-MM-DDTHH:MM:SS.SSS±HH:MM`
        """
        not_before: NotRequired[pulumi.Input[str]]
        """
        A string representing a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ` or `YYYY-MM-DDTHH:MM:SS.SSS±HH:MM`
        """
        state: NotRequired[pulumi.Input[str]]
        """
        ### Supported values

        Possible values:

         - `STATE_UNSPECIFIED`
         - `ACTIVE`
         - `EXPIRED`
        """
elif False:
    IamV1FederationCertificateStatusArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class IamV1FederationCertificateStatusArgs:
    def __init__(__self__, *,
                 algorithm: Optional[pulumi.Input[str]] = None,
                 key_size: Optional[pulumi.Input[float]] = None,
                 not_after: Optional[pulumi.Input[str]] = None,
                 not_before: Optional[pulumi.Input[str]] = None,
                 state: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] not_after: A string representing a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ` or `YYYY-MM-DDTHH:MM:SS.SSS±HH:MM`
        :param pulumi.Input[str] not_before: A string representing a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ` or `YYYY-MM-DDTHH:MM:SS.SSS±HH:MM`
        :param pulumi.Input[str] state: ### Supported values
               
               Possible values:
               
                - `STATE_UNSPECIFIED`
                - `ACTIVE`
                - `EXPIRED`
        """
        if algorithm is not None:
            pulumi.set(__self__, "algorithm", algorithm)
        if key_size is not None:
            pulumi.set(__self__, "key_size", key_size)
        if not_after is not None:
            pulumi.set(__self__, "not_after", not_after)
        if not_before is not None:
            pulumi.set(__self__, "not_before", not_before)
        if state is not None:
            pulumi.set(__self__, "state", state)

    @property
    @pulumi.getter
    def algorithm(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "algorithm")

    @algorithm.setter
    def algorithm(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "algorithm", value)

    @property
    @pulumi.getter(name="keySize")
    def key_size(self) -> Optional[pulumi.Input[float]]:
        return pulumi.get(self, "key_size")

    @key_size.setter
    def key_size(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "key_size", value)

    @property
    @pulumi.getter(name="notAfter")
    def not_after(self) -> Optional[pulumi.Input[str]]:
        """
        A string representing a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ` or `YYYY-MM-DDTHH:MM:SS.SSS±HH:MM`
        """
        return pulumi.get(self, "not_after")

    @not_after.setter
    def not_after(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "not_after", value)

    @property
    @pulumi.getter(name="notBefore")
    def not_before(self) -> Optional[pulumi.Input[str]]:
        """
        A string representing a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ` or `YYYY-MM-DDTHH:MM:SS.SSS±HH:MM`
        """
        return pulumi.get(self, "not_before")

    @not_before.setter
    def not_before(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "not_before", value)

    @property
    @pulumi.getter
    def state(self) -> Optional[pulumi.Input[str]]:
        """
        ### Supported values

        Possible values:

         - `STATE_UNSPECIFIED`
         - `ACTIVE`
         - `EXPIRED`
        """
        return pulumi.get(self, "state")

    @state.setter
    def state(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "state", value)


if not MYPY:
    class IamV1FederationMetadataArgsDict(TypedDict):
        pass
elif False:
    IamV1FederationMetadataArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class IamV1FederationMetadataArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class IamV1FederationSamlSettingsArgsDict(TypedDict):
        idp_issuer: NotRequired[pulumi.Input[str]]
        sso_url: NotRequired[pulumi.Input[str]]
elif False:
    IamV1FederationSamlSettingsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class IamV1FederationSamlSettingsArgs:
    def __init__(__self__, *,
                 idp_issuer: Optional[pulumi.Input[str]] = None,
                 sso_url: Optional[pulumi.Input[str]] = None):
        if idp_issuer is not None:
            pulumi.set(__self__, "idp_issuer", idp_issuer)
        if sso_url is not None:
            pulumi.set(__self__, "sso_url", sso_url)

    @property
    @pulumi.getter(name="idpIssuer")
    def idp_issuer(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "idp_issuer")

    @idp_issuer.setter
    def idp_issuer(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "idp_issuer", value)

    @property
    @pulumi.getter(name="ssoUrl")
    def sso_url(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "sso_url")

    @sso_url.setter
    def sso_url(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "sso_url", value)


if not MYPY:
    class IamV1FederationStatusArgsDict(TypedDict):
        pass
elif False:
    IamV1FederationStatusArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class IamV1FederationStatusArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class IamV1GroupMembershipMetadataArgsDict(TypedDict):
        pass
elif False:
    IamV1GroupMembershipMetadataArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class IamV1GroupMembershipMetadataArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class IamV1GroupMembershipStatusArgsDict(TypedDict):
        pass
elif False:
    IamV1GroupMembershipStatusArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class IamV1GroupMembershipStatusArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class IamV1InvitationMetadataArgsDict(TypedDict):
        pass
elif False:
    IamV1InvitationMetadataArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class IamV1InvitationMetadataArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class IamV1InvitationStatusArgsDict(TypedDict):
        expires_at: NotRequired[pulumi.Input[str]]
        """
        A string representing a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ` or `YYYY-MM-DDTHH:MM:SS.SSS±HH:MM`
        """
        state: NotRequired[pulumi.Input[str]]
        """
        ### Supported values

        Possible values:

         - `UNSPECIFIED`
         - `CREATING` - contacts data is not stored in pds yet. probably will GC it later
         - `CREATED` - notification is not sent yet
         - `PENDING` - notification is sent, we are waiting for the user to approve the notification
         - `EXPIRED` - notification is expired, accept is no longer possible
         - `ACCEPTED` - notification is accepted
        """
        tenant_user_account_id: NotRequired[pulumi.Input[str]]
elif False:
    IamV1InvitationStatusArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class IamV1InvitationStatusArgs:
    def __init__(__self__, *,
                 expires_at: Optional[pulumi.Input[str]] = None,
                 state: Optional[pulumi.Input[str]] = None,
                 tenant_user_account_id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] expires_at: A string representing a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ` or `YYYY-MM-DDTHH:MM:SS.SSS±HH:MM`
        :param pulumi.Input[str] state: ### Supported values
               
               Possible values:
               
                - `UNSPECIFIED`
                - `CREATING` - contacts data is not stored in pds yet. probably will GC it later
                - `CREATED` - notification is not sent yet
                - `PENDING` - notification is sent, we are waiting for the user to approve the notification
                - `EXPIRED` - notification is expired, accept is no longer possible
                - `ACCEPTED` - notification is accepted
        """
        if expires_at is not None:
            pulumi.set(__self__, "expires_at", expires_at)
        if state is not None:
            pulumi.set(__self__, "state", state)
        if tenant_user_account_id is not None:
            pulumi.set(__self__, "tenant_user_account_id", tenant_user_account_id)

    @property
    @pulumi.getter(name="expiresAt")
    def expires_at(self) -> Optional[pulumi.Input[str]]:
        """
        A string representing a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ` or `YYYY-MM-DDTHH:MM:SS.SSS±HH:MM`
        """
        return pulumi.get(self, "expires_at")

    @expires_at.setter
    def expires_at(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "expires_at", value)

    @property
    @pulumi.getter
    def state(self) -> Optional[pulumi.Input[str]]:
        """
        ### Supported values

        Possible values:

         - `UNSPECIFIED`
         - `CREATING` - contacts data is not stored in pds yet. probably will GC it later
         - `CREATED` - notification is not sent yet
         - `PENDING` - notification is sent, we are waiting for the user to approve the notification
         - `EXPIRED` - notification is expired, accept is no longer possible
         - `ACCEPTED` - notification is accepted
        """
        return pulumi.get(self, "state")

    @state.setter
    def state(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "state", value)

    @property
    @pulumi.getter(name="tenantUserAccountId")
    def tenant_user_account_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "tenant_user_account_id")

    @tenant_user_account_id.setter
    def tenant_user_account_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "tenant_user_account_id", value)


if not MYPY:
    class IamV1ServiceAccountMetadataArgsDict(TypedDict):
        pass
elif False:
    IamV1ServiceAccountMetadataArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class IamV1ServiceAccountMetadataArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class IamV1ServiceAccountStatusArgsDict(TypedDict):
        active: NotRequired[pulumi.Input[bool]]
elif False:
    IamV1ServiceAccountStatusArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class IamV1ServiceAccountStatusArgs:
    def __init__(__self__, *,
                 active: Optional[pulumi.Input[bool]] = None):
        if active is not None:
            pulumi.set(__self__, "active", active)

    @property
    @pulumi.getter
    def active(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "active")

    @active.setter
    def active(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "active", value)


if not MYPY:
    class Mk8sV1ClusterControlPlaneArgsDict(TypedDict):
        subnet_id: pulumi.Input[str]
        """
        Nebius VPC Subnet ID where control plane instances will be located.
        Also will be default NodeGroup subnet.
        """
        endpoints: NotRequired[pulumi.Input['Mk8sV1ClusterControlPlaneEndpointsArgsDict']]
        etcd_cluster_size: NotRequired[pulumi.Input[float]]
        """
        Number of instances in etcd cluster.
        3 by default.
        Control plane with `etcd_cluster_size: 3` called "Highly Available" ("HA"), because it's Kubernetes API
        will be available despite a failure of one control plane instance.
        """
        version: NotRequired[pulumi.Input[str]]
        """
        Desired Kubernetes version of the cluster. For now only acceptable format is
        `<major>.<minor>` like "1.30". Option for patch version update will be added later.
        """
elif False:
    Mk8sV1ClusterControlPlaneArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class Mk8sV1ClusterControlPlaneArgs:
    def __init__(__self__, *,
                 subnet_id: pulumi.Input[str],
                 endpoints: Optional[pulumi.Input['Mk8sV1ClusterControlPlaneEndpointsArgs']] = None,
                 etcd_cluster_size: Optional[pulumi.Input[float]] = None,
                 version: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] subnet_id: Nebius VPC Subnet ID where control plane instances will be located.
               Also will be default NodeGroup subnet.
        :param pulumi.Input[float] etcd_cluster_size: Number of instances in etcd cluster.
               3 by default.
               Control plane with `etcd_cluster_size: 3` called "Highly Available" ("HA"), because it's Kubernetes API
               will be available despite a failure of one control plane instance.
        :param pulumi.Input[str] version: Desired Kubernetes version of the cluster. For now only acceptable format is
               `<major>.<minor>` like "1.30". Option for patch version update will be added later.
        """
        pulumi.set(__self__, "subnet_id", subnet_id)
        if endpoints is not None:
            pulumi.set(__self__, "endpoints", endpoints)
        if etcd_cluster_size is not None:
            pulumi.set(__self__, "etcd_cluster_size", etcd_cluster_size)
        if version is not None:
            pulumi.set(__self__, "version", version)

    @property
    @pulumi.getter(name="subnetId")
    def subnet_id(self) -> pulumi.Input[str]:
        """
        Nebius VPC Subnet ID where control plane instances will be located.
        Also will be default NodeGroup subnet.
        """
        return pulumi.get(self, "subnet_id")

    @subnet_id.setter
    def subnet_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "subnet_id", value)

    @property
    @pulumi.getter
    def endpoints(self) -> Optional[pulumi.Input['Mk8sV1ClusterControlPlaneEndpointsArgs']]:
        return pulumi.get(self, "endpoints")

    @endpoints.setter
    def endpoints(self, value: Optional[pulumi.Input['Mk8sV1ClusterControlPlaneEndpointsArgs']]):
        pulumi.set(self, "endpoints", value)

    @property
    @pulumi.getter(name="etcdClusterSize")
    def etcd_cluster_size(self) -> Optional[pulumi.Input[float]]:
        """
        Number of instances in etcd cluster.
        3 by default.
        Control plane with `etcd_cluster_size: 3` called "Highly Available" ("HA"), because it's Kubernetes API
        will be available despite a failure of one control plane instance.
        """
        return pulumi.get(self, "etcd_cluster_size")

    @etcd_cluster_size.setter
    def etcd_cluster_size(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "etcd_cluster_size", value)

    @property
    @pulumi.getter
    def version(self) -> Optional[pulumi.Input[str]]:
        """
        Desired Kubernetes version of the cluster. For now only acceptable format is
        `<major>.<minor>` like "1.30". Option for patch version update will be added later.
        """
        return pulumi.get(self, "version")

    @version.setter
    def version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "version", value)


if not MYPY:
    class Mk8sV1ClusterControlPlaneEndpointsArgsDict(TypedDict):
        public_endpoint: NotRequired[pulumi.Input['Mk8sV1ClusterControlPlaneEndpointsPublicEndpointArgsDict']]
        """
        Specification of public endpoint for control plane.
        Set value to empty, to enable it.
        """
elif False:
    Mk8sV1ClusterControlPlaneEndpointsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class Mk8sV1ClusterControlPlaneEndpointsArgs:
    def __init__(__self__, *,
                 public_endpoint: Optional[pulumi.Input['Mk8sV1ClusterControlPlaneEndpointsPublicEndpointArgs']] = None):
        """
        :param pulumi.Input['Mk8sV1ClusterControlPlaneEndpointsPublicEndpointArgs'] public_endpoint: Specification of public endpoint for control plane.
               Set value to empty, to enable it.
        """
        if public_endpoint is not None:
            pulumi.set(__self__, "public_endpoint", public_endpoint)

    @property
    @pulumi.getter(name="publicEndpoint")
    def public_endpoint(self) -> Optional[pulumi.Input['Mk8sV1ClusterControlPlaneEndpointsPublicEndpointArgs']]:
        """
        Specification of public endpoint for control plane.
        Set value to empty, to enable it.
        """
        return pulumi.get(self, "public_endpoint")

    @public_endpoint.setter
    def public_endpoint(self, value: Optional[pulumi.Input['Mk8sV1ClusterControlPlaneEndpointsPublicEndpointArgs']]):
        pulumi.set(self, "public_endpoint", value)


if not MYPY:
    class Mk8sV1ClusterControlPlaneEndpointsPublicEndpointArgsDict(TypedDict):
        pass
elif False:
    Mk8sV1ClusterControlPlaneEndpointsPublicEndpointArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class Mk8sV1ClusterControlPlaneEndpointsPublicEndpointArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class Mk8sV1ClusterKubeNetworkArgsDict(TypedDict):
        service_cidrs: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        CIDR blocks for Service ClusterIP allocation. For now, only one value is supported.
        For now, value should be in prefix length form (such as "/16").
        Later a CIDR-formatted string (such as "10.1.2.0/16") will be supported.
        In case of prefix length, certain CIDR is auto allocated.
        Specified CIDR blocks will be reserved in Cluster.spec.control_plane.subnet_id to prevent address duplication.
        Allowed prefix length is from "/12" to "/28".
        Empty value treated as ["/16"].
        """
elif False:
    Mk8sV1ClusterKubeNetworkArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class Mk8sV1ClusterKubeNetworkArgs:
    def __init__(__self__, *,
                 service_cidrs: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] service_cidrs: CIDR blocks for Service ClusterIP allocation. For now, only one value is supported.
               For now, value should be in prefix length form (such as "/16").
               Later a CIDR-formatted string (such as "10.1.2.0/16") will be supported.
               In case of prefix length, certain CIDR is auto allocated.
               Specified CIDR blocks will be reserved in Cluster.spec.control_plane.subnet_id to prevent address duplication.
               Allowed prefix length is from "/12" to "/28".
               Empty value treated as ["/16"].
        """
        if service_cidrs is not None:
            pulumi.set(__self__, "service_cidrs", service_cidrs)

    @property
    @pulumi.getter(name="serviceCidrs")
    def service_cidrs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        CIDR blocks for Service ClusterIP allocation. For now, only one value is supported.
        For now, value should be in prefix length form (such as "/16").
        Later a CIDR-formatted string (such as "10.1.2.0/16") will be supported.
        In case of prefix length, certain CIDR is auto allocated.
        Specified CIDR blocks will be reserved in Cluster.spec.control_plane.subnet_id to prevent address duplication.
        Allowed prefix length is from "/12" to "/28".
        Empty value treated as ["/16"].
        """
        return pulumi.get(self, "service_cidrs")

    @service_cidrs.setter
    def service_cidrs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "service_cidrs", value)


if not MYPY:
    class Mk8sV1ClusterMetadataArgsDict(TypedDict):
        pass
elif False:
    Mk8sV1ClusterMetadataArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class Mk8sV1ClusterMetadataArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class Mk8sV1ClusterStatusArgsDict(TypedDict):
        control_plane: NotRequired[pulumi.Input['Mk8sV1ClusterStatusControlPlaneArgsDict']]
        reconciling: NotRequired[pulumi.Input[bool]]
        """
        Show that changes are in flight
        """
        state: NotRequired[pulumi.Input[str]]
        """
        ### Supported values

        Possible values:

         - `STATE_UNSPECIFIED`
         - `PROVISIONING`
         - `RUNNING`
         - `DELETING`
        """
elif False:
    Mk8sV1ClusterStatusArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class Mk8sV1ClusterStatusArgs:
    def __init__(__self__, *,
                 control_plane: Optional[pulumi.Input['Mk8sV1ClusterStatusControlPlaneArgs']] = None,
                 reconciling: Optional[pulumi.Input[bool]] = None,
                 state: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[bool] reconciling: Show that changes are in flight
        :param pulumi.Input[str] state: ### Supported values
               
               Possible values:
               
                - `STATE_UNSPECIFIED`
                - `PROVISIONING`
                - `RUNNING`
                - `DELETING`
        """
        if control_plane is not None:
            pulumi.set(__self__, "control_plane", control_plane)
        if reconciling is not None:
            pulumi.set(__self__, "reconciling", reconciling)
        if state is not None:
            pulumi.set(__self__, "state", state)

    @property
    @pulumi.getter(name="controlPlane")
    def control_plane(self) -> Optional[pulumi.Input['Mk8sV1ClusterStatusControlPlaneArgs']]:
        return pulumi.get(self, "control_plane")

    @control_plane.setter
    def control_plane(self, value: Optional[pulumi.Input['Mk8sV1ClusterStatusControlPlaneArgs']]):
        pulumi.set(self, "control_plane", value)

    @property
    @pulumi.getter
    def reconciling(self) -> Optional[pulumi.Input[bool]]:
        """
        Show that changes are in flight
        """
        return pulumi.get(self, "reconciling")

    @reconciling.setter
    def reconciling(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "reconciling", value)

    @property
    @pulumi.getter
    def state(self) -> Optional[pulumi.Input[str]]:
        """
        ### Supported values

        Possible values:

         - `STATE_UNSPECIFIED`
         - `PROVISIONING`
         - `RUNNING`
         - `DELETING`
        """
        return pulumi.get(self, "state")

    @state.setter
    def state(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "state", value)


if not MYPY:
    class Mk8sV1ClusterStatusControlPlaneArgsDict(TypedDict):
        auth: NotRequired[pulumi.Input['Mk8sV1ClusterStatusControlPlaneAuthArgsDict']]
        endpoints: NotRequired[pulumi.Input['Mk8sV1ClusterStatusControlPlaneEndpointsArgsDict']]
        """
        ### Inner value description

        Endpoints of Kubernetes control plane. Kubernetes API can be accessed at `https://endpoint/`.
        """
        etcd_cluster_size: NotRequired[pulumi.Input[float]]
        """
        Number of instances in etcd cluster.
        """
        version: NotRequired[pulumi.Input[str]]
        """
        Actual Kubernetes and configuration version.
        Version have format `<major>.<minor>.<patch>-nebius-cp.<infra_version>` like "1.30.0-nebius-cp.3".
        Where <major>.<minor>.<patch> is Kubernetes version and <infra_version> is version of control plane infrastructure and configuration,
        which update may include bug fixes, security updates and new features of components running on control plane, like CCM or Cluster Autoscaler.
        """
elif False:
    Mk8sV1ClusterStatusControlPlaneArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class Mk8sV1ClusterStatusControlPlaneArgs:
    def __init__(__self__, *,
                 auth: Optional[pulumi.Input['Mk8sV1ClusterStatusControlPlaneAuthArgs']] = None,
                 endpoints: Optional[pulumi.Input['Mk8sV1ClusterStatusControlPlaneEndpointsArgs']] = None,
                 etcd_cluster_size: Optional[pulumi.Input[float]] = None,
                 version: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input['Mk8sV1ClusterStatusControlPlaneEndpointsArgs'] endpoints: ### Inner value description
               
               Endpoints of Kubernetes control plane. Kubernetes API can be accessed at `https://endpoint/`.
        :param pulumi.Input[float] etcd_cluster_size: Number of instances in etcd cluster.
        :param pulumi.Input[str] version: Actual Kubernetes and configuration version.
               Version have format `<major>.<minor>.<patch>-nebius-cp.<infra_version>` like "1.30.0-nebius-cp.3".
               Where <major>.<minor>.<patch> is Kubernetes version and <infra_version> is version of control plane infrastructure and configuration,
               which update may include bug fixes, security updates and new features of components running on control plane, like CCM or Cluster Autoscaler.
        """
        if auth is not None:
            pulumi.set(__self__, "auth", auth)
        if endpoints is not None:
            pulumi.set(__self__, "endpoints", endpoints)
        if etcd_cluster_size is not None:
            pulumi.set(__self__, "etcd_cluster_size", etcd_cluster_size)
        if version is not None:
            pulumi.set(__self__, "version", version)

    @property
    @pulumi.getter
    def auth(self) -> Optional[pulumi.Input['Mk8sV1ClusterStatusControlPlaneAuthArgs']]:
        return pulumi.get(self, "auth")

    @auth.setter
    def auth(self, value: Optional[pulumi.Input['Mk8sV1ClusterStatusControlPlaneAuthArgs']]):
        pulumi.set(self, "auth", value)

    @property
    @pulumi.getter
    def endpoints(self) -> Optional[pulumi.Input['Mk8sV1ClusterStatusControlPlaneEndpointsArgs']]:
        """
        ### Inner value description

        Endpoints of Kubernetes control plane. Kubernetes API can be accessed at `https://endpoint/`.
        """
        return pulumi.get(self, "endpoints")

    @endpoints.setter
    def endpoints(self, value: Optional[pulumi.Input['Mk8sV1ClusterStatusControlPlaneEndpointsArgs']]):
        pulumi.set(self, "endpoints", value)

    @property
    @pulumi.getter(name="etcdClusterSize")
    def etcd_cluster_size(self) -> Optional[pulumi.Input[float]]:
        """
        Number of instances in etcd cluster.
        """
        return pulumi.get(self, "etcd_cluster_size")

    @etcd_cluster_size.setter
    def etcd_cluster_size(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "etcd_cluster_size", value)

    @property
    @pulumi.getter
    def version(self) -> Optional[pulumi.Input[str]]:
        """
        Actual Kubernetes and configuration version.
        Version have format `<major>.<minor>.<patch>-nebius-cp.<infra_version>` like "1.30.0-nebius-cp.3".
        Where <major>.<minor>.<patch> is Kubernetes version and <infra_version> is version of control plane infrastructure and configuration,
        which update may include bug fixes, security updates and new features of components running on control plane, like CCM or Cluster Autoscaler.
        """
        return pulumi.get(self, "version")

    @version.setter
    def version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "version", value)


if not MYPY:
    class Mk8sV1ClusterStatusControlPlaneAuthArgsDict(TypedDict):
        cluster_ca_certificate: NotRequired[pulumi.Input[str]]
        """
        PEM with the Cluster Certificate Authority, that must be used for TLS connection to Kubernetes API.
        """
elif False:
    Mk8sV1ClusterStatusControlPlaneAuthArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class Mk8sV1ClusterStatusControlPlaneAuthArgs:
    def __init__(__self__, *,
                 cluster_ca_certificate: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] cluster_ca_certificate: PEM with the Cluster Certificate Authority, that must be used for TLS connection to Kubernetes API.
        """
        if cluster_ca_certificate is not None:
            pulumi.set(__self__, "cluster_ca_certificate", cluster_ca_certificate)

    @property
    @pulumi.getter(name="clusterCaCertificate")
    def cluster_ca_certificate(self) -> Optional[pulumi.Input[str]]:
        """
        PEM with the Cluster Certificate Authority, that must be used for TLS connection to Kubernetes API.
        """
        return pulumi.get(self, "cluster_ca_certificate")

    @cluster_ca_certificate.setter
    def cluster_ca_certificate(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "cluster_ca_certificate", value)


if not MYPY:
    class Mk8sV1ClusterStatusControlPlaneEndpointsArgsDict(TypedDict):
        private_endpoint: NotRequired[pulumi.Input[str]]
        """
        DNS name or IP address accessible from the user VPC.
        """
        public_endpoint: NotRequired[pulumi.Input[str]]
        """
        DNS name or IP address accessible from the Internet.
        """
elif False:
    Mk8sV1ClusterStatusControlPlaneEndpointsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class Mk8sV1ClusterStatusControlPlaneEndpointsArgs:
    def __init__(__self__, *,
                 private_endpoint: Optional[pulumi.Input[str]] = None,
                 public_endpoint: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] private_endpoint: DNS name or IP address accessible from the user VPC.
        :param pulumi.Input[str] public_endpoint: DNS name or IP address accessible from the Internet.
        """
        if private_endpoint is not None:
            pulumi.set(__self__, "private_endpoint", private_endpoint)
        if public_endpoint is not None:
            pulumi.set(__self__, "public_endpoint", public_endpoint)

    @property
    @pulumi.getter(name="privateEndpoint")
    def private_endpoint(self) -> Optional[pulumi.Input[str]]:
        """
        DNS name or IP address accessible from the user VPC.
        """
        return pulumi.get(self, "private_endpoint")

    @private_endpoint.setter
    def private_endpoint(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "private_endpoint", value)

    @property
    @pulumi.getter(name="publicEndpoint")
    def public_endpoint(self) -> Optional[pulumi.Input[str]]:
        """
        DNS name or IP address accessible from the Internet.
        """
        return pulumi.get(self, "public_endpoint")

    @public_endpoint.setter
    def public_endpoint(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "public_endpoint", value)


if not MYPY:
    class Mk8sV1NodeGroupAutoscalingArgsDict(TypedDict):
        max_node_count: NotRequired[pulumi.Input[float]]
        min_node_count: NotRequired[pulumi.Input[float]]
elif False:
    Mk8sV1NodeGroupAutoscalingArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class Mk8sV1NodeGroupAutoscalingArgs:
    def __init__(__self__, *,
                 max_node_count: Optional[pulumi.Input[float]] = None,
                 min_node_count: Optional[pulumi.Input[float]] = None):
        if max_node_count is not None:
            pulumi.set(__self__, "max_node_count", max_node_count)
        if min_node_count is not None:
            pulumi.set(__self__, "min_node_count", min_node_count)

    @property
    @pulumi.getter(name="maxNodeCount")
    def max_node_count(self) -> Optional[pulumi.Input[float]]:
        return pulumi.get(self, "max_node_count")

    @max_node_count.setter
    def max_node_count(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "max_node_count", value)

    @property
    @pulumi.getter(name="minNodeCount")
    def min_node_count(self) -> Optional[pulumi.Input[float]]:
        return pulumi.get(self, "min_node_count")

    @min_node_count.setter
    def min_node_count(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "min_node_count", value)


if not MYPY:
    class Mk8sV1NodeGroupMetadataArgsDict(TypedDict):
        pass
elif False:
    Mk8sV1NodeGroupMetadataArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class Mk8sV1NodeGroupMetadataArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class Mk8sV1NodeGroupStatusArgsDict(TypedDict):
        node_count: NotRequired[pulumi.Input[float]]
        """
        Total number of nodes that are currently in the node group.
        Both ready and not ready nodes are counted.
        """
        outdated_node_count: NotRequired[pulumi.Input[float]]
        """
        Total number of nodes that has outdated node configuration.
        These nodes will be replaced by new nodes with up-to-date configuration.
        """
        ready_node_count: NotRequired[pulumi.Input[float]]
        """
        Total number of nodes that successfully joined the cluster and are ready to serve workloads.
        Both outdated and up-to-date nodes are counted.
        """
        reconciling: NotRequired[pulumi.Input[bool]]
        """
        Show that there are changes are in flight.
        """
        state: NotRequired[pulumi.Input[str]]
        """
        ### Supported values

        Possible values:

         - `STATE_UNSPECIFIED`
         - `PROVISIONING`
         - `RUNNING`
         - `DELETING`
        """
        target_node_count: NotRequired[pulumi.Input[float]]
        """
        Desired total number of nodes that should be in the node group.
        It is either `NodeGroupSpec.fixed_node_count` or arbitrary number between
        `NodeGroupAutoscalingSpec.min_node_count` and `NodeGroupAutoscalingSpec.max_node_count` decided by autoscaler.
        """
        version: NotRequired[pulumi.Input[str]]
        """
        Actual version of NodeGroup. Have format `<major>.<minor>.<patch>-nebius-node.<infra_version>` like "1.30.0-nebius-node.10".
        Where <major>.<minor>.<patch> is Kubernetes version and <infra_version> is version of Node infrastructure and configuration,
        which update may include bug fixes, security updates and new features depending on worker node configuration.
        """
elif False:
    Mk8sV1NodeGroupStatusArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class Mk8sV1NodeGroupStatusArgs:
    def __init__(__self__, *,
                 node_count: Optional[pulumi.Input[float]] = None,
                 outdated_node_count: Optional[pulumi.Input[float]] = None,
                 ready_node_count: Optional[pulumi.Input[float]] = None,
                 reconciling: Optional[pulumi.Input[bool]] = None,
                 state: Optional[pulumi.Input[str]] = None,
                 target_node_count: Optional[pulumi.Input[float]] = None,
                 version: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[float] node_count: Total number of nodes that are currently in the node group.
               Both ready and not ready nodes are counted.
        :param pulumi.Input[float] outdated_node_count: Total number of nodes that has outdated node configuration.
               These nodes will be replaced by new nodes with up-to-date configuration.
        :param pulumi.Input[float] ready_node_count: Total number of nodes that successfully joined the cluster and are ready to serve workloads.
               Both outdated and up-to-date nodes are counted.
        :param pulumi.Input[bool] reconciling: Show that there are changes are in flight.
        :param pulumi.Input[str] state: ### Supported values
               
               Possible values:
               
                - `STATE_UNSPECIFIED`
                - `PROVISIONING`
                - `RUNNING`
                - `DELETING`
        :param pulumi.Input[float] target_node_count: Desired total number of nodes that should be in the node group.
               It is either `NodeGroupSpec.fixed_node_count` or arbitrary number between
               `NodeGroupAutoscalingSpec.min_node_count` and `NodeGroupAutoscalingSpec.max_node_count` decided by autoscaler.
        :param pulumi.Input[str] version: Actual version of NodeGroup. Have format `<major>.<minor>.<patch>-nebius-node.<infra_version>` like "1.30.0-nebius-node.10".
               Where <major>.<minor>.<patch> is Kubernetes version and <infra_version> is version of Node infrastructure and configuration,
               which update may include bug fixes, security updates and new features depending on worker node configuration.
        """
        if node_count is not None:
            pulumi.set(__self__, "node_count", node_count)
        if outdated_node_count is not None:
            pulumi.set(__self__, "outdated_node_count", outdated_node_count)
        if ready_node_count is not None:
            pulumi.set(__self__, "ready_node_count", ready_node_count)
        if reconciling is not None:
            pulumi.set(__self__, "reconciling", reconciling)
        if state is not None:
            pulumi.set(__self__, "state", state)
        if target_node_count is not None:
            pulumi.set(__self__, "target_node_count", target_node_count)
        if version is not None:
            pulumi.set(__self__, "version", version)

    @property
    @pulumi.getter(name="nodeCount")
    def node_count(self) -> Optional[pulumi.Input[float]]:
        """
        Total number of nodes that are currently in the node group.
        Both ready and not ready nodes are counted.
        """
        return pulumi.get(self, "node_count")

    @node_count.setter
    def node_count(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "node_count", value)

    @property
    @pulumi.getter(name="outdatedNodeCount")
    def outdated_node_count(self) -> Optional[pulumi.Input[float]]:
        """
        Total number of nodes that has outdated node configuration.
        These nodes will be replaced by new nodes with up-to-date configuration.
        """
        return pulumi.get(self, "outdated_node_count")

    @outdated_node_count.setter
    def outdated_node_count(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "outdated_node_count", value)

    @property
    @pulumi.getter(name="readyNodeCount")
    def ready_node_count(self) -> Optional[pulumi.Input[float]]:
        """
        Total number of nodes that successfully joined the cluster and are ready to serve workloads.
        Both outdated and up-to-date nodes are counted.
        """
        return pulumi.get(self, "ready_node_count")

    @ready_node_count.setter
    def ready_node_count(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "ready_node_count", value)

    @property
    @pulumi.getter
    def reconciling(self) -> Optional[pulumi.Input[bool]]:
        """
        Show that there are changes are in flight.
        """
        return pulumi.get(self, "reconciling")

    @reconciling.setter
    def reconciling(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "reconciling", value)

    @property
    @pulumi.getter
    def state(self) -> Optional[pulumi.Input[str]]:
        """
        ### Supported values

        Possible values:

         - `STATE_UNSPECIFIED`
         - `PROVISIONING`
         - `RUNNING`
         - `DELETING`
        """
        return pulumi.get(self, "state")

    @state.setter
    def state(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "state", value)

    @property
    @pulumi.getter(name="targetNodeCount")
    def target_node_count(self) -> Optional[pulumi.Input[float]]:
        """
        Desired total number of nodes that should be in the node group.
        It is either `NodeGroupSpec.fixed_node_count` or arbitrary number between
        `NodeGroupAutoscalingSpec.min_node_count` and `NodeGroupAutoscalingSpec.max_node_count` decided by autoscaler.
        """
        return pulumi.get(self, "target_node_count")

    @target_node_count.setter
    def target_node_count(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "target_node_count", value)

    @property
    @pulumi.getter
    def version(self) -> Optional[pulumi.Input[str]]:
        """
        Actual version of NodeGroup. Have format `<major>.<minor>.<patch>-nebius-node.<infra_version>` like "1.30.0-nebius-node.10".
        Where <major>.<minor>.<patch> is Kubernetes version and <infra_version> is version of Node infrastructure and configuration,
        which update may include bug fixes, security updates and new features depending on worker node configuration.
        """
        return pulumi.get(self, "version")

    @version.setter
    def version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "version", value)


if not MYPY:
    class Mk8sV1NodeGroupStrategyArgsDict(TypedDict):
        drain_timeout: NotRequired[pulumi.Input[str]]
        """
        Maximum amount of time that the service will spend on attempting gracefully draining a node (evicting it's pods), before
        falling back to pod deletion.
        By default, node can be drained unlimited time.
        Important consequence of that is if PodDisruptionBudget doesn't allow to evict a pod,
        then NodeGroup update with node re-creation will hung on that pod eviction.
        Note, that it is different from `kubectl drain --timeout`

        Duration as a string: possibly signed sequence of decimal numbers, each with optional fraction and a unit suffix, such as `300ms`, `-1.5h` or `2h45m`. Valid time units are `ns`, `us` (or `µs`), `ms`, `s`, `m`, `h`, `d`.
        """
        max_surge: NotRequired[pulumi.Input['Mk8sV1NodeGroupStrategyMaxSurgeArgsDict']]
        """
        The maximum number of additional nodes that can be provisioned above the desired number of nodes during the update process.
        This value can be specified either as an absolute number (for example 3) or as a percentage of the desired number of nodes (for example 5%).
        When specified as a percentage, the actual number is calculated by rounding up to the nearest whole number.
        This value cannot be 0 if `max_unavailable` is also set to 0.
        Defaults to 1.
        Example: If set to 25%, the node group can scale up by an additional 25% during the update,
        allowing new nodes to be added before old nodes are removed, which helps minimize workload disruption.
        NOTE: it is user responsibility to ensure that there are enough quota for provision nodes above the desired number.
          Available quota effectively limits `max_surge`.
          In case of not enough quota even for one extra node, update operation will hung because of quota exhausted error.
          Such error will be visible in Operation.progress_data.
        """
        max_unavailable: NotRequired[pulumi.Input['Mk8sV1NodeGroupStrategyMaxUnavailableArgsDict']]
        """
        The maximum number of nodes that can be simultaneously unavailable during the update process.
        This value can be specified either as an absolute number (for example 3) or as a percentage of the desired number of nodes (for example 5%).
        When specified as a percentage, the actual number is calculated by rounding down to the nearest whole number.
        This value cannot be 0 if `max_surge` is also set to 0.
        Defaults to 0.
        Example: If set to 20%, up to 20% of the nodes can be taken offline at once during the update,
        ensuring that at least 80% of the desired nodes remain operational.
        """
elif False:
    Mk8sV1NodeGroupStrategyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class Mk8sV1NodeGroupStrategyArgs:
    def __init__(__self__, *,
                 drain_timeout: Optional[pulumi.Input[str]] = None,
                 max_surge: Optional[pulumi.Input['Mk8sV1NodeGroupStrategyMaxSurgeArgs']] = None,
                 max_unavailable: Optional[pulumi.Input['Mk8sV1NodeGroupStrategyMaxUnavailableArgs']] = None):
        """
        :param pulumi.Input[str] drain_timeout: Maximum amount of time that the service will spend on attempting gracefully draining a node (evicting it's pods), before
               falling back to pod deletion.
               By default, node can be drained unlimited time.
               Important consequence of that is if PodDisruptionBudget doesn't allow to evict a pod,
               then NodeGroup update with node re-creation will hung on that pod eviction.
               Note, that it is different from `kubectl drain --timeout`
               
               Duration as a string: possibly signed sequence of decimal numbers, each with optional fraction and a unit suffix, such as `300ms`, `-1.5h` or `2h45m`. Valid time units are `ns`, `us` (or `µs`), `ms`, `s`, `m`, `h`, `d`.
        :param pulumi.Input['Mk8sV1NodeGroupStrategyMaxSurgeArgs'] max_surge: The maximum number of additional nodes that can be provisioned above the desired number of nodes during the update process.
               This value can be specified either as an absolute number (for example 3) or as a percentage of the desired number of nodes (for example 5%).
               When specified as a percentage, the actual number is calculated by rounding up to the nearest whole number.
               This value cannot be 0 if `max_unavailable` is also set to 0.
               Defaults to 1.
               Example: If set to 25%, the node group can scale up by an additional 25% during the update,
               allowing new nodes to be added before old nodes are removed, which helps minimize workload disruption.
               NOTE: it is user responsibility to ensure that there are enough quota for provision nodes above the desired number.
                 Available quota effectively limits `max_surge`.
                 In case of not enough quota even for one extra node, update operation will hung because of quota exhausted error.
                 Such error will be visible in Operation.progress_data.
        :param pulumi.Input['Mk8sV1NodeGroupStrategyMaxUnavailableArgs'] max_unavailable: The maximum number of nodes that can be simultaneously unavailable during the update process.
               This value can be specified either as an absolute number (for example 3) or as a percentage of the desired number of nodes (for example 5%).
               When specified as a percentage, the actual number is calculated by rounding down to the nearest whole number.
               This value cannot be 0 if `max_surge` is also set to 0.
               Defaults to 0.
               Example: If set to 20%, up to 20% of the nodes can be taken offline at once during the update,
               ensuring that at least 80% of the desired nodes remain operational.
        """
        if drain_timeout is not None:
            pulumi.set(__self__, "drain_timeout", drain_timeout)
        if max_surge is not None:
            pulumi.set(__self__, "max_surge", max_surge)
        if max_unavailable is not None:
            pulumi.set(__self__, "max_unavailable", max_unavailable)

    @property
    @pulumi.getter(name="drainTimeout")
    def drain_timeout(self) -> Optional[pulumi.Input[str]]:
        """
        Maximum amount of time that the service will spend on attempting gracefully draining a node (evicting it's pods), before
        falling back to pod deletion.
        By default, node can be drained unlimited time.
        Important consequence of that is if PodDisruptionBudget doesn't allow to evict a pod,
        then NodeGroup update with node re-creation will hung on that pod eviction.
        Note, that it is different from `kubectl drain --timeout`

        Duration as a string: possibly signed sequence of decimal numbers, each with optional fraction and a unit suffix, such as `300ms`, `-1.5h` or `2h45m`. Valid time units are `ns`, `us` (or `µs`), `ms`, `s`, `m`, `h`, `d`.
        """
        return pulumi.get(self, "drain_timeout")

    @drain_timeout.setter
    def drain_timeout(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "drain_timeout", value)

    @property
    @pulumi.getter(name="maxSurge")
    def max_surge(self) -> Optional[pulumi.Input['Mk8sV1NodeGroupStrategyMaxSurgeArgs']]:
        """
        The maximum number of additional nodes that can be provisioned above the desired number of nodes during the update process.
        This value can be specified either as an absolute number (for example 3) or as a percentage of the desired number of nodes (for example 5%).
        When specified as a percentage, the actual number is calculated by rounding up to the nearest whole number.
        This value cannot be 0 if `max_unavailable` is also set to 0.
        Defaults to 1.
        Example: If set to 25%, the node group can scale up by an additional 25% during the update,
        allowing new nodes to be added before old nodes are removed, which helps minimize workload disruption.
        NOTE: it is user responsibility to ensure that there are enough quota for provision nodes above the desired number.
          Available quota effectively limits `max_surge`.
          In case of not enough quota even for one extra node, update operation will hung because of quota exhausted error.
          Such error will be visible in Operation.progress_data.
        """
        return pulumi.get(self, "max_surge")

    @max_surge.setter
    def max_surge(self, value: Optional[pulumi.Input['Mk8sV1NodeGroupStrategyMaxSurgeArgs']]):
        pulumi.set(self, "max_surge", value)

    @property
    @pulumi.getter(name="maxUnavailable")
    def max_unavailable(self) -> Optional[pulumi.Input['Mk8sV1NodeGroupStrategyMaxUnavailableArgs']]:
        """
        The maximum number of nodes that can be simultaneously unavailable during the update process.
        This value can be specified either as an absolute number (for example 3) or as a percentage of the desired number of nodes (for example 5%).
        When specified as a percentage, the actual number is calculated by rounding down to the nearest whole number.
        This value cannot be 0 if `max_surge` is also set to 0.
        Defaults to 0.
        Example: If set to 20%, up to 20% of the nodes can be taken offline at once during the update,
        ensuring that at least 80% of the desired nodes remain operational.
        """
        return pulumi.get(self, "max_unavailable")

    @max_unavailable.setter
    def max_unavailable(self, value: Optional[pulumi.Input['Mk8sV1NodeGroupStrategyMaxUnavailableArgs']]):
        pulumi.set(self, "max_unavailable", value)


if not MYPY:
    class Mk8sV1NodeGroupStrategyMaxSurgeArgsDict(TypedDict):
        count: NotRequired[pulumi.Input[float]]
        """
        *Cannot be set alongside percent.*
        """
        percent: NotRequired[pulumi.Input[float]]
        """
        *Cannot be set alongside count.*
        """
elif False:
    Mk8sV1NodeGroupStrategyMaxSurgeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class Mk8sV1NodeGroupStrategyMaxSurgeArgs:
    def __init__(__self__, *,
                 count: Optional[pulumi.Input[float]] = None,
                 percent: Optional[pulumi.Input[float]] = None):
        """
        :param pulumi.Input[float] count: *Cannot be set alongside percent.*
        :param pulumi.Input[float] percent: *Cannot be set alongside count.*
        """
        if count is not None:
            pulumi.set(__self__, "count", count)
        if percent is not None:
            pulumi.set(__self__, "percent", percent)

    @property
    @pulumi.getter
    def count(self) -> Optional[pulumi.Input[float]]:
        """
        *Cannot be set alongside percent.*
        """
        return pulumi.get(self, "count")

    @count.setter
    def count(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "count", value)

    @property
    @pulumi.getter
    def percent(self) -> Optional[pulumi.Input[float]]:
        """
        *Cannot be set alongside count.*
        """
        return pulumi.get(self, "percent")

    @percent.setter
    def percent(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "percent", value)


if not MYPY:
    class Mk8sV1NodeGroupStrategyMaxUnavailableArgsDict(TypedDict):
        count: NotRequired[pulumi.Input[float]]
        """
        *Cannot be set alongside percent.*
        """
        percent: NotRequired[pulumi.Input[float]]
        """
        *Cannot be set alongside count.*
        """
elif False:
    Mk8sV1NodeGroupStrategyMaxUnavailableArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class Mk8sV1NodeGroupStrategyMaxUnavailableArgs:
    def __init__(__self__, *,
                 count: Optional[pulumi.Input[float]] = None,
                 percent: Optional[pulumi.Input[float]] = None):
        """
        :param pulumi.Input[float] count: *Cannot be set alongside percent.*
        :param pulumi.Input[float] percent: *Cannot be set alongside count.*
        """
        if count is not None:
            pulumi.set(__self__, "count", count)
        if percent is not None:
            pulumi.set(__self__, "percent", percent)

    @property
    @pulumi.getter
    def count(self) -> Optional[pulumi.Input[float]]:
        """
        *Cannot be set alongside percent.*
        """
        return pulumi.get(self, "count")

    @count.setter
    def count(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "count", value)

    @property
    @pulumi.getter
    def percent(self) -> Optional[pulumi.Input[float]]:
        """
        *Cannot be set alongside count.*
        """
        return pulumi.get(self, "percent")

    @percent.setter
    def percent(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "percent", value)


if not MYPY:
    class Mk8sV1NodeGroupTemplateArgsDict(TypedDict):
        resources: pulumi.Input['Mk8sV1NodeGroupTemplateResourcesArgsDict']
        """
        Resources that will have Nebius Compute Instance where Node kubelet will run.
        """
        boot_disk: NotRequired[pulumi.Input['Mk8sV1NodeGroupTemplateBootDiskArgsDict']]
        """
        Parameters of a Node Nebius Compute Instance boot disk.
        """
        cloud_init_user_data: NotRequired[pulumi.Input[str]]
        """
        cloud-init user-data
        Should contain at least one SSH key.
        """
        filesystems: NotRequired[pulumi.Input[Sequence[pulumi.Input['Mk8sV1NodeGroupTemplateFilesystemArgsDict']]]]
        """
        Static attachments of Compute Filesystem.
        Can be used as a workaround, until CSI for Compute Disk and Filesystem will be available.
        """
        gpu_cluster: NotRequired[pulumi.Input['Mk8sV1NodeGroupTemplateGpuClusterArgsDict']]
        """
        Nebius Compute GPUCluster ID that will be attached to node.
        """
        metadata: NotRequired[pulumi.Input['Mk8sV1NodeGroupTemplateMetadataArgsDict']]
        network_interfaces: NotRequired[pulumi.Input[Sequence[pulumi.Input['Mk8sV1NodeGroupTemplateNetworkInterfaceArgsDict']]]]
        service_account_id: NotRequired[pulumi.Input[str]]
        """
        the Nebius service account whose credentials will be available on the nodes of the group.
        With these credentials, it is possible to make `npc` or public API requests from the nodes without the need for extra authentication.
        This service account is also used to make requests to container registry.

        `resource.serviceaccount.issueAccessToken` permission is required to use this field.
        """
        taints: NotRequired[pulumi.Input[Sequence[pulumi.Input['Mk8sV1NodeGroupTemplateTaintArgsDict']]]]
        """
        Kubernetes Node taints.
        For now change will not be propagated to existing nodes, so will be applied only to Kubernetes Nodes created after the field change.
        That behaviour may change later.
        So, for now you will need to manually set them to existing nodes, if that is needed.
        Field change will NOT trigger NodeGroup roll out.

        ### Inner value description

        See https://kubernetes.io/docs/concepts/scheduling-eviction/taint-and-toleration/
        """
elif False:
    Mk8sV1NodeGroupTemplateArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class Mk8sV1NodeGroupTemplateArgs:
    def __init__(__self__, *,
                 resources: pulumi.Input['Mk8sV1NodeGroupTemplateResourcesArgs'],
                 boot_disk: Optional[pulumi.Input['Mk8sV1NodeGroupTemplateBootDiskArgs']] = None,
                 cloud_init_user_data: Optional[pulumi.Input[str]] = None,
                 filesystems: Optional[pulumi.Input[Sequence[pulumi.Input['Mk8sV1NodeGroupTemplateFilesystemArgs']]]] = None,
                 gpu_cluster: Optional[pulumi.Input['Mk8sV1NodeGroupTemplateGpuClusterArgs']] = None,
                 metadata: Optional[pulumi.Input['Mk8sV1NodeGroupTemplateMetadataArgs']] = None,
                 network_interfaces: Optional[pulumi.Input[Sequence[pulumi.Input['Mk8sV1NodeGroupTemplateNetworkInterfaceArgs']]]] = None,
                 service_account_id: Optional[pulumi.Input[str]] = None,
                 taints: Optional[pulumi.Input[Sequence[pulumi.Input['Mk8sV1NodeGroupTemplateTaintArgs']]]] = None):
        """
        :param pulumi.Input['Mk8sV1NodeGroupTemplateResourcesArgs'] resources: Resources that will have Nebius Compute Instance where Node kubelet will run.
        :param pulumi.Input['Mk8sV1NodeGroupTemplateBootDiskArgs'] boot_disk: Parameters of a Node Nebius Compute Instance boot disk.
        :param pulumi.Input[str] cloud_init_user_data: cloud-init user-data
               Should contain at least one SSH key.
        :param pulumi.Input[Sequence[pulumi.Input['Mk8sV1NodeGroupTemplateFilesystemArgs']]] filesystems: Static attachments of Compute Filesystem.
               Can be used as a workaround, until CSI for Compute Disk and Filesystem will be available.
        :param pulumi.Input['Mk8sV1NodeGroupTemplateGpuClusterArgs'] gpu_cluster: Nebius Compute GPUCluster ID that will be attached to node.
        :param pulumi.Input[str] service_account_id: the Nebius service account whose credentials will be available on the nodes of the group.
               With these credentials, it is possible to make `npc` or public API requests from the nodes without the need for extra authentication.
               This service account is also used to make requests to container registry.
               
               `resource.serviceaccount.issueAccessToken` permission is required to use this field.
        :param pulumi.Input[Sequence[pulumi.Input['Mk8sV1NodeGroupTemplateTaintArgs']]] taints: Kubernetes Node taints.
               For now change will not be propagated to existing nodes, so will be applied only to Kubernetes Nodes created after the field change.
               That behaviour may change later.
               So, for now you will need to manually set them to existing nodes, if that is needed.
               Field change will NOT trigger NodeGroup roll out.
               
               ### Inner value description
               
               See https://kubernetes.io/docs/concepts/scheduling-eviction/taint-and-toleration/
        """
        pulumi.set(__self__, "resources", resources)
        if boot_disk is not None:
            pulumi.set(__self__, "boot_disk", boot_disk)
        if cloud_init_user_data is not None:
            pulumi.set(__self__, "cloud_init_user_data", cloud_init_user_data)
        if filesystems is not None:
            pulumi.set(__self__, "filesystems", filesystems)
        if gpu_cluster is not None:
            pulumi.set(__self__, "gpu_cluster", gpu_cluster)
        if metadata is not None:
            pulumi.set(__self__, "metadata", metadata)
        if network_interfaces is not None:
            pulumi.set(__self__, "network_interfaces", network_interfaces)
        if service_account_id is not None:
            pulumi.set(__self__, "service_account_id", service_account_id)
        if taints is not None:
            pulumi.set(__self__, "taints", taints)

    @property
    @pulumi.getter
    def resources(self) -> pulumi.Input['Mk8sV1NodeGroupTemplateResourcesArgs']:
        """
        Resources that will have Nebius Compute Instance where Node kubelet will run.
        """
        return pulumi.get(self, "resources")

    @resources.setter
    def resources(self, value: pulumi.Input['Mk8sV1NodeGroupTemplateResourcesArgs']):
        pulumi.set(self, "resources", value)

    @property
    @pulumi.getter(name="bootDisk")
    def boot_disk(self) -> Optional[pulumi.Input['Mk8sV1NodeGroupTemplateBootDiskArgs']]:
        """
        Parameters of a Node Nebius Compute Instance boot disk.
        """
        return pulumi.get(self, "boot_disk")

    @boot_disk.setter
    def boot_disk(self, value: Optional[pulumi.Input['Mk8sV1NodeGroupTemplateBootDiskArgs']]):
        pulumi.set(self, "boot_disk", value)

    @property
    @pulumi.getter(name="cloudInitUserData")
    def cloud_init_user_data(self) -> Optional[pulumi.Input[str]]:
        """
        cloud-init user-data
        Should contain at least one SSH key.
        """
        return pulumi.get(self, "cloud_init_user_data")

    @cloud_init_user_data.setter
    def cloud_init_user_data(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "cloud_init_user_data", value)

    @property
    @pulumi.getter
    def filesystems(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['Mk8sV1NodeGroupTemplateFilesystemArgs']]]]:
        """
        Static attachments of Compute Filesystem.
        Can be used as a workaround, until CSI for Compute Disk and Filesystem will be available.
        """
        return pulumi.get(self, "filesystems")

    @filesystems.setter
    def filesystems(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['Mk8sV1NodeGroupTemplateFilesystemArgs']]]]):
        pulumi.set(self, "filesystems", value)

    @property
    @pulumi.getter(name="gpuCluster")
    def gpu_cluster(self) -> Optional[pulumi.Input['Mk8sV1NodeGroupTemplateGpuClusterArgs']]:
        """
        Nebius Compute GPUCluster ID that will be attached to node.
        """
        return pulumi.get(self, "gpu_cluster")

    @gpu_cluster.setter
    def gpu_cluster(self, value: Optional[pulumi.Input['Mk8sV1NodeGroupTemplateGpuClusterArgs']]):
        pulumi.set(self, "gpu_cluster", value)

    @property
    @pulumi.getter
    def metadata(self) -> Optional[pulumi.Input['Mk8sV1NodeGroupTemplateMetadataArgs']]:
        return pulumi.get(self, "metadata")

    @metadata.setter
    def metadata(self, value: Optional[pulumi.Input['Mk8sV1NodeGroupTemplateMetadataArgs']]):
        pulumi.set(self, "metadata", value)

    @property
    @pulumi.getter(name="networkInterfaces")
    def network_interfaces(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['Mk8sV1NodeGroupTemplateNetworkInterfaceArgs']]]]:
        return pulumi.get(self, "network_interfaces")

    @network_interfaces.setter
    def network_interfaces(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['Mk8sV1NodeGroupTemplateNetworkInterfaceArgs']]]]):
        pulumi.set(self, "network_interfaces", value)

    @property
    @pulumi.getter(name="serviceAccountId")
    def service_account_id(self) -> Optional[pulumi.Input[str]]:
        """
        the Nebius service account whose credentials will be available on the nodes of the group.
        With these credentials, it is possible to make `npc` or public API requests from the nodes without the need for extra authentication.
        This service account is also used to make requests to container registry.

        `resource.serviceaccount.issueAccessToken` permission is required to use this field.
        """
        return pulumi.get(self, "service_account_id")

    @service_account_id.setter
    def service_account_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "service_account_id", value)

    @property
    @pulumi.getter
    def taints(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['Mk8sV1NodeGroupTemplateTaintArgs']]]]:
        """
        Kubernetes Node taints.
        For now change will not be propagated to existing nodes, so will be applied only to Kubernetes Nodes created after the field change.
        That behaviour may change later.
        So, for now you will need to manually set them to existing nodes, if that is needed.
        Field change will NOT trigger NodeGroup roll out.

        ### Inner value description

        See https://kubernetes.io/docs/concepts/scheduling-eviction/taint-and-toleration/
        """
        return pulumi.get(self, "taints")

    @taints.setter
    def taints(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['Mk8sV1NodeGroupTemplateTaintArgs']]]]):
        pulumi.set(self, "taints", value)


if not MYPY:
    class Mk8sV1NodeGroupTemplateBootDiskArgsDict(TypedDict):
        block_size_bytes: NotRequired[pulumi.Input[float]]
        size_bytes: NotRequired[pulumi.Input[float]]
        """
        *Cannot be set alongside size_kibibytes or size_gibibytes.*
        """
        size_gibibytes: NotRequired[pulumi.Input[float]]
        """
        *Cannot be set alongside size_bytes or size_mebibytes.*
        """
        size_kibibytes: NotRequired[pulumi.Input[float]]
        """
        *Cannot be set alongside size_bytes or size_gibibytes.*
        """
        size_mebibytes: NotRequired[pulumi.Input[float]]
        """
        *Cannot be set alongside size_bytes or size_gibibytes.*
        """
        type: NotRequired[pulumi.Input[str]]
        """
        ### Supported values

        Possible values:

         - `UNSPECIFIED`
         - `NETWORK_SSD`
         - `NETWORK_HDD`
         - `NETWORK_SSD_IO_M3`
         - `NETWORK_SSD_NON_REPLICATED`
        """
elif False:
    Mk8sV1NodeGroupTemplateBootDiskArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class Mk8sV1NodeGroupTemplateBootDiskArgs:
    def __init__(__self__, *,
                 block_size_bytes: Optional[pulumi.Input[float]] = None,
                 size_bytes: Optional[pulumi.Input[float]] = None,
                 size_gibibytes: Optional[pulumi.Input[float]] = None,
                 size_kibibytes: Optional[pulumi.Input[float]] = None,
                 size_mebibytes: Optional[pulumi.Input[float]] = None,
                 type: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[float] size_bytes: *Cannot be set alongside size_kibibytes or size_gibibytes.*
        :param pulumi.Input[float] size_gibibytes: *Cannot be set alongside size_bytes or size_mebibytes.*
        :param pulumi.Input[float] size_kibibytes: *Cannot be set alongside size_bytes or size_gibibytes.*
        :param pulumi.Input[float] size_mebibytes: *Cannot be set alongside size_bytes or size_gibibytes.*
        :param pulumi.Input[str] type: ### Supported values
               
               Possible values:
               
                - `UNSPECIFIED`
                - `NETWORK_SSD`
                - `NETWORK_HDD`
                - `NETWORK_SSD_IO_M3`
                - `NETWORK_SSD_NON_REPLICATED`
        """
        if block_size_bytes is not None:
            pulumi.set(__self__, "block_size_bytes", block_size_bytes)
        if size_bytes is not None:
            pulumi.set(__self__, "size_bytes", size_bytes)
        if size_gibibytes is not None:
            pulumi.set(__self__, "size_gibibytes", size_gibibytes)
        if size_kibibytes is not None:
            pulumi.set(__self__, "size_kibibytes", size_kibibytes)
        if size_mebibytes is not None:
            pulumi.set(__self__, "size_mebibytes", size_mebibytes)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter(name="blockSizeBytes")
    def block_size_bytes(self) -> Optional[pulumi.Input[float]]:
        return pulumi.get(self, "block_size_bytes")

    @block_size_bytes.setter
    def block_size_bytes(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "block_size_bytes", value)

    @property
    @pulumi.getter(name="sizeBytes")
    def size_bytes(self) -> Optional[pulumi.Input[float]]:
        """
        *Cannot be set alongside size_kibibytes or size_gibibytes.*
        """
        return pulumi.get(self, "size_bytes")

    @size_bytes.setter
    def size_bytes(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "size_bytes", value)

    @property
    @pulumi.getter(name="sizeGibibytes")
    def size_gibibytes(self) -> Optional[pulumi.Input[float]]:
        """
        *Cannot be set alongside size_bytes or size_mebibytes.*
        """
        return pulumi.get(self, "size_gibibytes")

    @size_gibibytes.setter
    def size_gibibytes(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "size_gibibytes", value)

    @property
    @pulumi.getter(name="sizeKibibytes")
    def size_kibibytes(self) -> Optional[pulumi.Input[float]]:
        """
        *Cannot be set alongside size_bytes or size_gibibytes.*
        """
        return pulumi.get(self, "size_kibibytes")

    @size_kibibytes.setter
    def size_kibibytes(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "size_kibibytes", value)

    @property
    @pulumi.getter(name="sizeMebibytes")
    def size_mebibytes(self) -> Optional[pulumi.Input[float]]:
        """
        *Cannot be set alongside size_bytes or size_gibibytes.*
        """
        return pulumi.get(self, "size_mebibytes")

    @size_mebibytes.setter
    def size_mebibytes(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "size_mebibytes", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[str]]:
        """
        ### Supported values

        Possible values:

         - `UNSPECIFIED`
         - `NETWORK_SSD`
         - `NETWORK_HDD`
         - `NETWORK_SSD_IO_M3`
         - `NETWORK_SSD_NON_REPLICATED`
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "type", value)


if not MYPY:
    class Mk8sV1NodeGroupTemplateFilesystemArgsDict(TypedDict):
        attach_mode: pulumi.Input[str]
        """
        ### Supported values

        Possible values:

         - `UNSPECIFIED`
         - `READ_ONLY`
         - `READ_WRITE`
        """
        mount_tag: pulumi.Input[str]
        """
        Specifies the user-defined identifier, allowing to use it as a device in mount command.
        """
        existing_filesystem: NotRequired[pulumi.Input['Mk8sV1NodeGroupTemplateFilesystemExistingFilesystemArgsDict']]
elif False:
    Mk8sV1NodeGroupTemplateFilesystemArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class Mk8sV1NodeGroupTemplateFilesystemArgs:
    def __init__(__self__, *,
                 attach_mode: pulumi.Input[str],
                 mount_tag: pulumi.Input[str],
                 existing_filesystem: Optional[pulumi.Input['Mk8sV1NodeGroupTemplateFilesystemExistingFilesystemArgs']] = None):
        """
        :param pulumi.Input[str] attach_mode: ### Supported values
               
               Possible values:
               
                - `UNSPECIFIED`
                - `READ_ONLY`
                - `READ_WRITE`
        :param pulumi.Input[str] mount_tag: Specifies the user-defined identifier, allowing to use it as a device in mount command.
        """
        pulumi.set(__self__, "attach_mode", attach_mode)
        pulumi.set(__self__, "mount_tag", mount_tag)
        if existing_filesystem is not None:
            pulumi.set(__self__, "existing_filesystem", existing_filesystem)

    @property
    @pulumi.getter(name="attachMode")
    def attach_mode(self) -> pulumi.Input[str]:
        """
        ### Supported values

        Possible values:

         - `UNSPECIFIED`
         - `READ_ONLY`
         - `READ_WRITE`
        """
        return pulumi.get(self, "attach_mode")

    @attach_mode.setter
    def attach_mode(self, value: pulumi.Input[str]):
        pulumi.set(self, "attach_mode", value)

    @property
    @pulumi.getter(name="mountTag")
    def mount_tag(self) -> pulumi.Input[str]:
        """
        Specifies the user-defined identifier, allowing to use it as a device in mount command.
        """
        return pulumi.get(self, "mount_tag")

    @mount_tag.setter
    def mount_tag(self, value: pulumi.Input[str]):
        pulumi.set(self, "mount_tag", value)

    @property
    @pulumi.getter(name="existingFilesystem")
    def existing_filesystem(self) -> Optional[pulumi.Input['Mk8sV1NodeGroupTemplateFilesystemExistingFilesystemArgs']]:
        return pulumi.get(self, "existing_filesystem")

    @existing_filesystem.setter
    def existing_filesystem(self, value: Optional[pulumi.Input['Mk8sV1NodeGroupTemplateFilesystemExistingFilesystemArgs']]):
        pulumi.set(self, "existing_filesystem", value)


if not MYPY:
    class Mk8sV1NodeGroupTemplateFilesystemExistingFilesystemArgsDict(TypedDict):
        id: pulumi.Input[str]
elif False:
    Mk8sV1NodeGroupTemplateFilesystemExistingFilesystemArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class Mk8sV1NodeGroupTemplateFilesystemExistingFilesystemArgs:
    def __init__(__self__, *,
                 id: pulumi.Input[str]):
        pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> pulumi.Input[str]:
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[str]):
        pulumi.set(self, "id", value)


if not MYPY:
    class Mk8sV1NodeGroupTemplateGpuClusterArgsDict(TypedDict):
        id: NotRequired[pulumi.Input[str]]
elif False:
    Mk8sV1NodeGroupTemplateGpuClusterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class Mk8sV1NodeGroupTemplateGpuClusterArgs:
    def __init__(__self__, *,
                 id: Optional[pulumi.Input[str]] = None):
        if id is not None:
            pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "id", value)


if not MYPY:
    class Mk8sV1NodeGroupTemplateMetadataArgsDict(TypedDict):
        labels: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[str]]]]
        """
        Kubernetes Node labels.
        For now change will not be propagated to existing nodes, so will be applied only to Kubernetes Nodes created after the field change.
        That behaviour may change later.
        So, for now you will need to manually set them to existing nodes, if that is needed.

        System labels containing "kubernetes.io" and "k8s.io" will be ignored.
        Field change will NOT trigger NodeGroup roll out.
        """
elif False:
    Mk8sV1NodeGroupTemplateMetadataArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class Mk8sV1NodeGroupTemplateMetadataArgs:
    def __init__(__self__, *,
                 labels: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] labels: Kubernetes Node labels.
               For now change will not be propagated to existing nodes, so will be applied only to Kubernetes Nodes created after the field change.
               That behaviour may change later.
               So, for now you will need to manually set them to existing nodes, if that is needed.
               
               System labels containing "kubernetes.io" and "k8s.io" will be ignored.
               Field change will NOT trigger NodeGroup roll out.
        """
        if labels is not None:
            pulumi.set(__self__, "labels", labels)

    @property
    @pulumi.getter
    def labels(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        Kubernetes Node labels.
        For now change will not be propagated to existing nodes, so will be applied only to Kubernetes Nodes created after the field change.
        That behaviour may change later.
        So, for now you will need to manually set them to existing nodes, if that is needed.

        System labels containing "kubernetes.io" and "k8s.io" will be ignored.
        Field change will NOT trigger NodeGroup roll out.
        """
        return pulumi.get(self, "labels")

    @labels.setter
    def labels(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "labels", value)


if not MYPY:
    class Mk8sV1NodeGroupTemplateNetworkInterfaceArgsDict(TypedDict):
        public_ip_address: NotRequired[pulumi.Input['Mk8sV1NodeGroupTemplateNetworkInterfacePublicIpAddressArgsDict']]
        """
        Parameters for Public IPv4 address associated with the interface.
        Set to empty value, to enable it.

        ### Inner value description

        Describes a public IP address.
        """
        subnet_id: NotRequired[pulumi.Input[str]]
        """
        Nebius VPC Subnet ID that will be attached to a node cloud instance network interface.
        By default Cluster control plane subnet_id used.
        Subnet should be located in the same network with control plane.
        """
elif False:
    Mk8sV1NodeGroupTemplateNetworkInterfaceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class Mk8sV1NodeGroupTemplateNetworkInterfaceArgs:
    def __init__(__self__, *,
                 public_ip_address: Optional[pulumi.Input['Mk8sV1NodeGroupTemplateNetworkInterfacePublicIpAddressArgs']] = None,
                 subnet_id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input['Mk8sV1NodeGroupTemplateNetworkInterfacePublicIpAddressArgs'] public_ip_address: Parameters for Public IPv4 address associated with the interface.
               Set to empty value, to enable it.
               
               ### Inner value description
               
               Describes a public IP address.
        :param pulumi.Input[str] subnet_id: Nebius VPC Subnet ID that will be attached to a node cloud instance network interface.
               By default Cluster control plane subnet_id used.
               Subnet should be located in the same network with control plane.
        """
        if public_ip_address is not None:
            pulumi.set(__self__, "public_ip_address", public_ip_address)
        if subnet_id is not None:
            pulumi.set(__self__, "subnet_id", subnet_id)

    @property
    @pulumi.getter(name="publicIpAddress")
    def public_ip_address(self) -> Optional[pulumi.Input['Mk8sV1NodeGroupTemplateNetworkInterfacePublicIpAddressArgs']]:
        """
        Parameters for Public IPv4 address associated with the interface.
        Set to empty value, to enable it.

        ### Inner value description

        Describes a public IP address.
        """
        return pulumi.get(self, "public_ip_address")

    @public_ip_address.setter
    def public_ip_address(self, value: Optional[pulumi.Input['Mk8sV1NodeGroupTemplateNetworkInterfacePublicIpAddressArgs']]):
        pulumi.set(self, "public_ip_address", value)

    @property
    @pulumi.getter(name="subnetId")
    def subnet_id(self) -> Optional[pulumi.Input[str]]:
        """
        Nebius VPC Subnet ID that will be attached to a node cloud instance network interface.
        By default Cluster control plane subnet_id used.
        Subnet should be located in the same network with control plane.
        """
        return pulumi.get(self, "subnet_id")

    @subnet_id.setter
    def subnet_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "subnet_id", value)


if not MYPY:
    class Mk8sV1NodeGroupTemplateNetworkInterfacePublicIpAddressArgsDict(TypedDict):
        pass
elif False:
    Mk8sV1NodeGroupTemplateNetworkInterfacePublicIpAddressArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class Mk8sV1NodeGroupTemplateNetworkInterfacePublicIpAddressArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class Mk8sV1NodeGroupTemplateResourcesArgsDict(TypedDict):
        platform: pulumi.Input[str]
        preset: NotRequired[pulumi.Input[str]]
elif False:
    Mk8sV1NodeGroupTemplateResourcesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class Mk8sV1NodeGroupTemplateResourcesArgs:
    def __init__(__self__, *,
                 platform: pulumi.Input[str],
                 preset: Optional[pulumi.Input[str]] = None):
        pulumi.set(__self__, "platform", platform)
        if preset is not None:
            pulumi.set(__self__, "preset", preset)

    @property
    @pulumi.getter
    def platform(self) -> pulumi.Input[str]:
        return pulumi.get(self, "platform")

    @platform.setter
    def platform(self, value: pulumi.Input[str]):
        pulumi.set(self, "platform", value)

    @property
    @pulumi.getter
    def preset(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "preset")

    @preset.setter
    def preset(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "preset", value)


if not MYPY:
    class Mk8sV1NodeGroupTemplateTaintArgsDict(TypedDict):
        effect: pulumi.Input[str]
        """
        ### Supported values

        Possible values:

         - `EFFECT_UNSPECIFIED`
         - `NO_EXECUTE`
         - `NO_SCHEDULE`
         - `PREFER_NO_SCHEDULE`
        """
        key: pulumi.Input[str]
        value: pulumi.Input[str]
elif False:
    Mk8sV1NodeGroupTemplateTaintArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class Mk8sV1NodeGroupTemplateTaintArgs:
    def __init__(__self__, *,
                 effect: pulumi.Input[str],
                 key: pulumi.Input[str],
                 value: pulumi.Input[str]):
        """
        :param pulumi.Input[str] effect: ### Supported values
               
               Possible values:
               
                - `EFFECT_UNSPECIFIED`
                - `NO_EXECUTE`
                - `NO_SCHEDULE`
                - `PREFER_NO_SCHEDULE`
        """
        pulumi.set(__self__, "effect", effect)
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def effect(self) -> pulumi.Input[str]:
        """
        ### Supported values

        Possible values:

         - `EFFECT_UNSPECIFIED`
         - `NO_EXECUTE`
         - `NO_SCHEDULE`
         - `PREFER_NO_SCHEDULE`
        """
        return pulumi.get(self, "effect")

    @effect.setter
    def effect(self, value: pulumi.Input[str]):
        pulumi.set(self, "effect", value)

    @property
    @pulumi.getter
    def key(self) -> pulumi.Input[str]:
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[str]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[str]:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[str]):
        pulumi.set(self, "value", value)


if not MYPY:
    class Mk8sV1alpha1ClusterControlPlaneArgsDict(TypedDict):
        subnet_id: pulumi.Input[str]
        """
        Subnet ID where control plane instances will be located.
        """
        endpoints: NotRequired[pulumi.Input['Mk8sV1alpha1ClusterControlPlaneEndpointsArgsDict']]
        etcd_cluster_size: NotRequired[pulumi.Input[float]]
        """
        Number of instances in etcd cluster.
        3 by default.
        Control plane with `etcd_cluster_size: 3` called "Highly Available" ("HA"), because it's Kubernetes API
        will be available despite a failure of one control plane instance.
        """
        version: NotRequired[pulumi.Input[str]]
        """
        Version is desired Kubernetes version of the cluster. For now only acceptable format is
        `MAJOR.MINOR` like "1.30". Option for patch version update will be added later.
        """
elif False:
    Mk8sV1alpha1ClusterControlPlaneArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class Mk8sV1alpha1ClusterControlPlaneArgs:
    def __init__(__self__, *,
                 subnet_id: pulumi.Input[str],
                 endpoints: Optional[pulumi.Input['Mk8sV1alpha1ClusterControlPlaneEndpointsArgs']] = None,
                 etcd_cluster_size: Optional[pulumi.Input[float]] = None,
                 version: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] subnet_id: Subnet ID where control plane instances will be located.
        :param pulumi.Input[float] etcd_cluster_size: Number of instances in etcd cluster.
               3 by default.
               Control plane with `etcd_cluster_size: 3` called "Highly Available" ("HA"), because it's Kubernetes API
               will be available despite a failure of one control plane instance.
        :param pulumi.Input[str] version: Version is desired Kubernetes version of the cluster. For now only acceptable format is
               `MAJOR.MINOR` like "1.30". Option for patch version update will be added later.
        """
        pulumi.set(__self__, "subnet_id", subnet_id)
        if endpoints is not None:
            pulumi.set(__self__, "endpoints", endpoints)
        if etcd_cluster_size is not None:
            pulumi.set(__self__, "etcd_cluster_size", etcd_cluster_size)
        if version is not None:
            pulumi.set(__self__, "version", version)

    @property
    @pulumi.getter(name="subnetId")
    def subnet_id(self) -> pulumi.Input[str]:
        """
        Subnet ID where control plane instances will be located.
        """
        return pulumi.get(self, "subnet_id")

    @subnet_id.setter
    def subnet_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "subnet_id", value)

    @property
    @pulumi.getter
    def endpoints(self) -> Optional[pulumi.Input['Mk8sV1alpha1ClusterControlPlaneEndpointsArgs']]:
        return pulumi.get(self, "endpoints")

    @endpoints.setter
    def endpoints(self, value: Optional[pulumi.Input['Mk8sV1alpha1ClusterControlPlaneEndpointsArgs']]):
        pulumi.set(self, "endpoints", value)

    @property
    @pulumi.getter(name="etcdClusterSize")
    def etcd_cluster_size(self) -> Optional[pulumi.Input[float]]:
        """
        Number of instances in etcd cluster.
        3 by default.
        Control plane with `etcd_cluster_size: 3` called "Highly Available" ("HA"), because it's Kubernetes API
        will be available despite a failure of one control plane instance.
        """
        return pulumi.get(self, "etcd_cluster_size")

    @etcd_cluster_size.setter
    def etcd_cluster_size(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "etcd_cluster_size", value)

    @property
    @pulumi.getter
    def version(self) -> Optional[pulumi.Input[str]]:
        """
        Version is desired Kubernetes version of the cluster. For now only acceptable format is
        `MAJOR.MINOR` like "1.30". Option for patch version update will be added later.
        """
        return pulumi.get(self, "version")

    @version.setter
    def version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "version", value)


if not MYPY:
    class Mk8sV1alpha1ClusterControlPlaneEndpointsArgsDict(TypedDict):
        public_endpoint: NotRequired[pulumi.Input['Mk8sV1alpha1ClusterControlPlaneEndpointsPublicEndpointArgsDict']]
        """
        PublicEndpointSpec is a specification of public endpoint for control plane.
        """
elif False:
    Mk8sV1alpha1ClusterControlPlaneEndpointsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class Mk8sV1alpha1ClusterControlPlaneEndpointsArgs:
    def __init__(__self__, *,
                 public_endpoint: Optional[pulumi.Input['Mk8sV1alpha1ClusterControlPlaneEndpointsPublicEndpointArgs']] = None):
        """
        :param pulumi.Input['Mk8sV1alpha1ClusterControlPlaneEndpointsPublicEndpointArgs'] public_endpoint: PublicEndpointSpec is a specification of public endpoint for control plane.
        """
        if public_endpoint is not None:
            pulumi.set(__self__, "public_endpoint", public_endpoint)

    @property
    @pulumi.getter(name="publicEndpoint")
    def public_endpoint(self) -> Optional[pulumi.Input['Mk8sV1alpha1ClusterControlPlaneEndpointsPublicEndpointArgs']]:
        """
        PublicEndpointSpec is a specification of public endpoint for control plane.
        """
        return pulumi.get(self, "public_endpoint")

    @public_endpoint.setter
    def public_endpoint(self, value: Optional[pulumi.Input['Mk8sV1alpha1ClusterControlPlaneEndpointsPublicEndpointArgs']]):
        pulumi.set(self, "public_endpoint", value)


if not MYPY:
    class Mk8sV1alpha1ClusterControlPlaneEndpointsPublicEndpointArgsDict(TypedDict):
        pass
elif False:
    Mk8sV1alpha1ClusterControlPlaneEndpointsPublicEndpointArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class Mk8sV1alpha1ClusterControlPlaneEndpointsPublicEndpointArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class Mk8sV1alpha1ClusterKubeNetworkArgsDict(TypedDict):
        service_cidrs: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        CIDR blocks for Service ClusterIP allocation. For now, only one value is supported.
        For now, value should be in prefix length form (such as "/16").
        Later a CIDR-formatted string (such as "10.1.2.0/16") will be supported.
        In case of prefix length, certain CIDR is auto allocated.
        Specified CIDR blocks will be reserved in Cluster.spec.control_plane.subnet_id to prevent address duplication.
        Allowed prefix length is from "/12" to "/28".
        Empty value treated as ["/16"].
        """
elif False:
    Mk8sV1alpha1ClusterKubeNetworkArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class Mk8sV1alpha1ClusterKubeNetworkArgs:
    def __init__(__self__, *,
                 service_cidrs: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] service_cidrs: CIDR blocks for Service ClusterIP allocation. For now, only one value is supported.
               For now, value should be in prefix length form (such as "/16").
               Later a CIDR-formatted string (such as "10.1.2.0/16") will be supported.
               In case of prefix length, certain CIDR is auto allocated.
               Specified CIDR blocks will be reserved in Cluster.spec.control_plane.subnet_id to prevent address duplication.
               Allowed prefix length is from "/12" to "/28".
               Empty value treated as ["/16"].
        """
        if service_cidrs is not None:
            pulumi.set(__self__, "service_cidrs", service_cidrs)

    @property
    @pulumi.getter(name="serviceCidrs")
    def service_cidrs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        CIDR blocks for Service ClusterIP allocation. For now, only one value is supported.
        For now, value should be in prefix length form (such as "/16").
        Later a CIDR-formatted string (such as "10.1.2.0/16") will be supported.
        In case of prefix length, certain CIDR is auto allocated.
        Specified CIDR blocks will be reserved in Cluster.spec.control_plane.subnet_id to prevent address duplication.
        Allowed prefix length is from "/12" to "/28".
        Empty value treated as ["/16"].
        """
        return pulumi.get(self, "service_cidrs")

    @service_cidrs.setter
    def service_cidrs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "service_cidrs", value)


if not MYPY:
    class Mk8sV1alpha1ClusterMetadataArgsDict(TypedDict):
        pass
elif False:
    Mk8sV1alpha1ClusterMetadataArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class Mk8sV1alpha1ClusterMetadataArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class Mk8sV1alpha1ClusterStatusArgsDict(TypedDict):
        control_plane: NotRequired[pulumi.Input['Mk8sV1alpha1ClusterStatusControlPlaneArgsDict']]
        reconciling: NotRequired[pulumi.Input[bool]]
        """
        Show that changes are in flight
        """
        state: NotRequired[pulumi.Input[str]]
        """
        ### Supported values

        Possible values:

         - `STATE_UNSPECIFIED`
         - `PROVISIONING`
         - `RUNNING`
         - `DELETING`
        """
elif False:
    Mk8sV1alpha1ClusterStatusArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class Mk8sV1alpha1ClusterStatusArgs:
    def __init__(__self__, *,
                 control_plane: Optional[pulumi.Input['Mk8sV1alpha1ClusterStatusControlPlaneArgs']] = None,
                 reconciling: Optional[pulumi.Input[bool]] = None,
                 state: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[bool] reconciling: Show that changes are in flight
        :param pulumi.Input[str] state: ### Supported values
               
               Possible values:
               
                - `STATE_UNSPECIFIED`
                - `PROVISIONING`
                - `RUNNING`
                - `DELETING`
        """
        if control_plane is not None:
            pulumi.set(__self__, "control_plane", control_plane)
        if reconciling is not None:
            pulumi.set(__self__, "reconciling", reconciling)
        if state is not None:
            pulumi.set(__self__, "state", state)

    @property
    @pulumi.getter(name="controlPlane")
    def control_plane(self) -> Optional[pulumi.Input['Mk8sV1alpha1ClusterStatusControlPlaneArgs']]:
        return pulumi.get(self, "control_plane")

    @control_plane.setter
    def control_plane(self, value: Optional[pulumi.Input['Mk8sV1alpha1ClusterStatusControlPlaneArgs']]):
        pulumi.set(self, "control_plane", value)

    @property
    @pulumi.getter
    def reconciling(self) -> Optional[pulumi.Input[bool]]:
        """
        Show that changes are in flight
        """
        return pulumi.get(self, "reconciling")

    @reconciling.setter
    def reconciling(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "reconciling", value)

    @property
    @pulumi.getter
    def state(self) -> Optional[pulumi.Input[str]]:
        """
        ### Supported values

        Possible values:

         - `STATE_UNSPECIFIED`
         - `PROVISIONING`
         - `RUNNING`
         - `DELETING`
        """
        return pulumi.get(self, "state")

    @state.setter
    def state(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "state", value)


if not MYPY:
    class Mk8sV1alpha1ClusterStatusControlPlaneArgsDict(TypedDict):
        auth: NotRequired[pulumi.Input['Mk8sV1alpha1ClusterStatusControlPlaneAuthArgsDict']]
        endpoints: NotRequired[pulumi.Input['Mk8sV1alpha1ClusterStatusControlPlaneEndpointsArgsDict']]
        """
        ### Inner value description

        Endpoints of Kubernetes control plane. Kubernetes API can be accessed at `https://endpoint/`.
        """
        etcd_cluster_size: NotRequired[pulumi.Input[float]]
        """
        Number of instances in etcd cluster.
        """
        version: NotRequired[pulumi.Input[str]]
        """
        Version have format `major.minor.patch-nebius-cp.n` like "1.30.0-nebius-cp.3".
        """
elif False:
    Mk8sV1alpha1ClusterStatusControlPlaneArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class Mk8sV1alpha1ClusterStatusControlPlaneArgs:
    def __init__(__self__, *,
                 auth: Optional[pulumi.Input['Mk8sV1alpha1ClusterStatusControlPlaneAuthArgs']] = None,
                 endpoints: Optional[pulumi.Input['Mk8sV1alpha1ClusterStatusControlPlaneEndpointsArgs']] = None,
                 etcd_cluster_size: Optional[pulumi.Input[float]] = None,
                 version: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input['Mk8sV1alpha1ClusterStatusControlPlaneEndpointsArgs'] endpoints: ### Inner value description
               
               Endpoints of Kubernetes control plane. Kubernetes API can be accessed at `https://endpoint/`.
        :param pulumi.Input[float] etcd_cluster_size: Number of instances in etcd cluster.
        :param pulumi.Input[str] version: Version have format `major.minor.patch-nebius-cp.n` like "1.30.0-nebius-cp.3".
        """
        if auth is not None:
            pulumi.set(__self__, "auth", auth)
        if endpoints is not None:
            pulumi.set(__self__, "endpoints", endpoints)
        if etcd_cluster_size is not None:
            pulumi.set(__self__, "etcd_cluster_size", etcd_cluster_size)
        if version is not None:
            pulumi.set(__self__, "version", version)

    @property
    @pulumi.getter
    def auth(self) -> Optional[pulumi.Input['Mk8sV1alpha1ClusterStatusControlPlaneAuthArgs']]:
        return pulumi.get(self, "auth")

    @auth.setter
    def auth(self, value: Optional[pulumi.Input['Mk8sV1alpha1ClusterStatusControlPlaneAuthArgs']]):
        pulumi.set(self, "auth", value)

    @property
    @pulumi.getter
    def endpoints(self) -> Optional[pulumi.Input['Mk8sV1alpha1ClusterStatusControlPlaneEndpointsArgs']]:
        """
        ### Inner value description

        Endpoints of Kubernetes control plane. Kubernetes API can be accessed at `https://endpoint/`.
        """
        return pulumi.get(self, "endpoints")

    @endpoints.setter
    def endpoints(self, value: Optional[pulumi.Input['Mk8sV1alpha1ClusterStatusControlPlaneEndpointsArgs']]):
        pulumi.set(self, "endpoints", value)

    @property
    @pulumi.getter(name="etcdClusterSize")
    def etcd_cluster_size(self) -> Optional[pulumi.Input[float]]:
        """
        Number of instances in etcd cluster.
        """
        return pulumi.get(self, "etcd_cluster_size")

    @etcd_cluster_size.setter
    def etcd_cluster_size(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "etcd_cluster_size", value)

    @property
    @pulumi.getter
    def version(self) -> Optional[pulumi.Input[str]]:
        """
        Version have format `major.minor.patch-nebius-cp.n` like "1.30.0-nebius-cp.3".
        """
        return pulumi.get(self, "version")

    @version.setter
    def version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "version", value)


if not MYPY:
    class Mk8sV1alpha1ClusterStatusControlPlaneAuthArgsDict(TypedDict):
        cluster_ca_certificate: NotRequired[pulumi.Input[str]]
elif False:
    Mk8sV1alpha1ClusterStatusControlPlaneAuthArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class Mk8sV1alpha1ClusterStatusControlPlaneAuthArgs:
    def __init__(__self__, *,
                 cluster_ca_certificate: Optional[pulumi.Input[str]] = None):
        if cluster_ca_certificate is not None:
            pulumi.set(__self__, "cluster_ca_certificate", cluster_ca_certificate)

    @property
    @pulumi.getter(name="clusterCaCertificate")
    def cluster_ca_certificate(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "cluster_ca_certificate")

    @cluster_ca_certificate.setter
    def cluster_ca_certificate(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "cluster_ca_certificate", value)


if not MYPY:
    class Mk8sV1alpha1ClusterStatusControlPlaneEndpointsArgsDict(TypedDict):
        private_endpoint: NotRequired[pulumi.Input[str]]
        """
        DNS name or IP address accessible from the user VPC.
        """
        public_endpoint: NotRequired[pulumi.Input[str]]
        """
        DNS name or IP address accessible from the Internet.
        """
elif False:
    Mk8sV1alpha1ClusterStatusControlPlaneEndpointsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class Mk8sV1alpha1ClusterStatusControlPlaneEndpointsArgs:
    def __init__(__self__, *,
                 private_endpoint: Optional[pulumi.Input[str]] = None,
                 public_endpoint: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] private_endpoint: DNS name or IP address accessible from the user VPC.
        :param pulumi.Input[str] public_endpoint: DNS name or IP address accessible from the Internet.
        """
        if private_endpoint is not None:
            pulumi.set(__self__, "private_endpoint", private_endpoint)
        if public_endpoint is not None:
            pulumi.set(__self__, "public_endpoint", public_endpoint)

    @property
    @pulumi.getter(name="privateEndpoint")
    def private_endpoint(self) -> Optional[pulumi.Input[str]]:
        """
        DNS name or IP address accessible from the user VPC.
        """
        return pulumi.get(self, "private_endpoint")

    @private_endpoint.setter
    def private_endpoint(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "private_endpoint", value)

    @property
    @pulumi.getter(name="publicEndpoint")
    def public_endpoint(self) -> Optional[pulumi.Input[str]]:
        """
        DNS name or IP address accessible from the Internet.
        """
        return pulumi.get(self, "public_endpoint")

    @public_endpoint.setter
    def public_endpoint(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "public_endpoint", value)


if not MYPY:
    class Mk8sV1alpha1NodeGroupAutoscalingArgsDict(TypedDict):
        max_node_count: NotRequired[pulumi.Input[float]]
        min_node_count: NotRequired[pulumi.Input[float]]
elif False:
    Mk8sV1alpha1NodeGroupAutoscalingArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class Mk8sV1alpha1NodeGroupAutoscalingArgs:
    def __init__(__self__, *,
                 max_node_count: Optional[pulumi.Input[float]] = None,
                 min_node_count: Optional[pulumi.Input[float]] = None):
        if max_node_count is not None:
            pulumi.set(__self__, "max_node_count", max_node_count)
        if min_node_count is not None:
            pulumi.set(__self__, "min_node_count", min_node_count)

    @property
    @pulumi.getter(name="maxNodeCount")
    def max_node_count(self) -> Optional[pulumi.Input[float]]:
        return pulumi.get(self, "max_node_count")

    @max_node_count.setter
    def max_node_count(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "max_node_count", value)

    @property
    @pulumi.getter(name="minNodeCount")
    def min_node_count(self) -> Optional[pulumi.Input[float]]:
        return pulumi.get(self, "min_node_count")

    @min_node_count.setter
    def min_node_count(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "min_node_count", value)


if not MYPY:
    class Mk8sV1alpha1NodeGroupMetadataArgsDict(TypedDict):
        pass
elif False:
    Mk8sV1alpha1NodeGroupMetadataArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class Mk8sV1alpha1NodeGroupMetadataArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class Mk8sV1alpha1NodeGroupStatusArgsDict(TypedDict):
        node_count: NotRequired[pulumi.Input[float]]
        """
        Total number of nodes that are currently in the node group.
        Both ready and not ready nodes are counted.
        """
        outdated_node_count: NotRequired[pulumi.Input[float]]
        """
        Total number of nodes that has outdated node configuration.
        These nodes will be replaced by new nodes with up-to-date configuration.
        """
        ready_node_count: NotRequired[pulumi.Input[float]]
        """
        Total number of nodes that successfully joined the cluster and are ready to serve workloads.
        Both outdated and up-to-date nodes are counted.
        """
        reconciling: NotRequired[pulumi.Input[bool]]
        """
        Show that changes are in flight
        """
        state: NotRequired[pulumi.Input[str]]
        """
        ### Supported values

        Possible values:

         - `STATE_UNSPECIFIED`
         - `PROVISIONING`
         - `RUNNING`
         - `DELETING`
        """
        target_node_count: NotRequired[pulumi.Input[float]]
        """
        Desired total number of nodes that should be in the node group.
        It is either fixed_node_count or arbitrary number between min_node_count and max_node_count decided by autoscaler.
        """
        version: NotRequired[pulumi.Input[str]]
        """
        Version have format `MAJOR.MINOR.PATCH-nebius-node.n` like "1.30.0-nebius-node.10".
        """
elif False:
    Mk8sV1alpha1NodeGroupStatusArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class Mk8sV1alpha1NodeGroupStatusArgs:
    def __init__(__self__, *,
                 node_count: Optional[pulumi.Input[float]] = None,
                 outdated_node_count: Optional[pulumi.Input[float]] = None,
                 ready_node_count: Optional[pulumi.Input[float]] = None,
                 reconciling: Optional[pulumi.Input[bool]] = None,
                 state: Optional[pulumi.Input[str]] = None,
                 target_node_count: Optional[pulumi.Input[float]] = None,
                 version: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[float] node_count: Total number of nodes that are currently in the node group.
               Both ready and not ready nodes are counted.
        :param pulumi.Input[float] outdated_node_count: Total number of nodes that has outdated node configuration.
               These nodes will be replaced by new nodes with up-to-date configuration.
        :param pulumi.Input[float] ready_node_count: Total number of nodes that successfully joined the cluster and are ready to serve workloads.
               Both outdated and up-to-date nodes are counted.
        :param pulumi.Input[bool] reconciling: Show that changes are in flight
        :param pulumi.Input[str] state: ### Supported values
               
               Possible values:
               
                - `STATE_UNSPECIFIED`
                - `PROVISIONING`
                - `RUNNING`
                - `DELETING`
        :param pulumi.Input[float] target_node_count: Desired total number of nodes that should be in the node group.
               It is either fixed_node_count or arbitrary number between min_node_count and max_node_count decided by autoscaler.
        :param pulumi.Input[str] version: Version have format `MAJOR.MINOR.PATCH-nebius-node.n` like "1.30.0-nebius-node.10".
        """
        if node_count is not None:
            pulumi.set(__self__, "node_count", node_count)
        if outdated_node_count is not None:
            pulumi.set(__self__, "outdated_node_count", outdated_node_count)
        if ready_node_count is not None:
            pulumi.set(__self__, "ready_node_count", ready_node_count)
        if reconciling is not None:
            pulumi.set(__self__, "reconciling", reconciling)
        if state is not None:
            pulumi.set(__self__, "state", state)
        if target_node_count is not None:
            pulumi.set(__self__, "target_node_count", target_node_count)
        if version is not None:
            pulumi.set(__self__, "version", version)

    @property
    @pulumi.getter(name="nodeCount")
    def node_count(self) -> Optional[pulumi.Input[float]]:
        """
        Total number of nodes that are currently in the node group.
        Both ready and not ready nodes are counted.
        """
        return pulumi.get(self, "node_count")

    @node_count.setter
    def node_count(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "node_count", value)

    @property
    @pulumi.getter(name="outdatedNodeCount")
    def outdated_node_count(self) -> Optional[pulumi.Input[float]]:
        """
        Total number of nodes that has outdated node configuration.
        These nodes will be replaced by new nodes with up-to-date configuration.
        """
        return pulumi.get(self, "outdated_node_count")

    @outdated_node_count.setter
    def outdated_node_count(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "outdated_node_count", value)

    @property
    @pulumi.getter(name="readyNodeCount")
    def ready_node_count(self) -> Optional[pulumi.Input[float]]:
        """
        Total number of nodes that successfully joined the cluster and are ready to serve workloads.
        Both outdated and up-to-date nodes are counted.
        """
        return pulumi.get(self, "ready_node_count")

    @ready_node_count.setter
    def ready_node_count(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "ready_node_count", value)

    @property
    @pulumi.getter
    def reconciling(self) -> Optional[pulumi.Input[bool]]:
        """
        Show that changes are in flight
        """
        return pulumi.get(self, "reconciling")

    @reconciling.setter
    def reconciling(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "reconciling", value)

    @property
    @pulumi.getter
    def state(self) -> Optional[pulumi.Input[str]]:
        """
        ### Supported values

        Possible values:

         - `STATE_UNSPECIFIED`
         - `PROVISIONING`
         - `RUNNING`
         - `DELETING`
        """
        return pulumi.get(self, "state")

    @state.setter
    def state(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "state", value)

    @property
    @pulumi.getter(name="targetNodeCount")
    def target_node_count(self) -> Optional[pulumi.Input[float]]:
        """
        Desired total number of nodes that should be in the node group.
        It is either fixed_node_count or arbitrary number between min_node_count and max_node_count decided by autoscaler.
        """
        return pulumi.get(self, "target_node_count")

    @target_node_count.setter
    def target_node_count(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "target_node_count", value)

    @property
    @pulumi.getter
    def version(self) -> Optional[pulumi.Input[str]]:
        """
        Version have format `MAJOR.MINOR.PATCH-nebius-node.n` like "1.30.0-nebius-node.10".
        """
        return pulumi.get(self, "version")

    @version.setter
    def version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "version", value)


if not MYPY:
    class Mk8sV1alpha1NodeGroupStrategyArgsDict(TypedDict):
        drain_timeout: NotRequired[pulumi.Input[str]]
        """
        DrainTimeout is the total amount of time that the service will spend on draining a node.
        By default, node can be drained without any time limitations.
        NOTE: NodeDrainTimeout is different from `kubectl drain --timeout`

        Duration as a string: possibly signed sequence of decimal numbers, each with optional fraction and a unit suffix, such as `300ms`, `-1.5h` or `2h45m`. Valid time units are `ns`, `us` (or `µs`), `ms`, `s`, `m`, `h`, `d`.
        """
        max_surge: NotRequired[pulumi.Input['Mk8sV1alpha1NodeGroupStrategyMaxSurgeArgsDict']]
        """
        The maximum number of machines that can be scheduled above the
        desired number of machines.
        Value can be an absolute number (ex: 5) or a percentage of
        desired machines (ex: 10%).
        This can not be 0 if MaxUnavailable is 0.
        Absolute number is calculated from percentage by rounding up.
        Defaults to 1.
        Example: when this is set to 30%, the new MachineSet can be scaled
        up immediately when the rolling update starts, such that the total
        number of old and new machines do not exceed 130% of desired
        machines. Once old machines have been killed, new MachineSet can
        be scaled up further, ensuring that total number of machines running
        at any time during the update is at most 130% of desired machines.
        """
        max_unavailable: NotRequired[pulumi.Input['Mk8sV1alpha1NodeGroupStrategyMaxUnavailableArgsDict']]
        """
        The maximum number of machines that can be unavailable during the update.
        Value can be an absolute number (ex: 5) or a percentage of desired
        machines (ex: 10%).
        Absolute number is calculated from percentage by rounding down.
        This can not be 0 if MaxSurge is 0.
        Defaults to 0.
        Example: when this is set to 30%, the old MachineSet can be scaled
        down to 70% of desired machines immediately when the rolling update
        starts. Once new machines are ready, old MachineSet can be scaled
        down further, followed by scaling up the new MachineSet, ensuring
        that the total number of machines available at all times
        during the update is at least 70% of desired machines.
        """
elif False:
    Mk8sV1alpha1NodeGroupStrategyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class Mk8sV1alpha1NodeGroupStrategyArgs:
    def __init__(__self__, *,
                 drain_timeout: Optional[pulumi.Input[str]] = None,
                 max_surge: Optional[pulumi.Input['Mk8sV1alpha1NodeGroupStrategyMaxSurgeArgs']] = None,
                 max_unavailable: Optional[pulumi.Input['Mk8sV1alpha1NodeGroupStrategyMaxUnavailableArgs']] = None):
        """
        :param pulumi.Input[str] drain_timeout: DrainTimeout is the total amount of time that the service will spend on draining a node.
               By default, node can be drained without any time limitations.
               NOTE: NodeDrainTimeout is different from `kubectl drain --timeout`
               
               Duration as a string: possibly signed sequence of decimal numbers, each with optional fraction and a unit suffix, such as `300ms`, `-1.5h` or `2h45m`. Valid time units are `ns`, `us` (or `µs`), `ms`, `s`, `m`, `h`, `d`.
        :param pulumi.Input['Mk8sV1alpha1NodeGroupStrategyMaxSurgeArgs'] max_surge: The maximum number of machines that can be scheduled above the
               desired number of machines.
               Value can be an absolute number (ex: 5) or a percentage of
               desired machines (ex: 10%).
               This can not be 0 if MaxUnavailable is 0.
               Absolute number is calculated from percentage by rounding up.
               Defaults to 1.
               Example: when this is set to 30%, the new MachineSet can be scaled
               up immediately when the rolling update starts, such that the total
               number of old and new machines do not exceed 130% of desired
               machines. Once old machines have been killed, new MachineSet can
               be scaled up further, ensuring that total number of machines running
               at any time during the update is at most 130% of desired machines.
        :param pulumi.Input['Mk8sV1alpha1NodeGroupStrategyMaxUnavailableArgs'] max_unavailable: The maximum number of machines that can be unavailable during the update.
               Value can be an absolute number (ex: 5) or a percentage of desired
               machines (ex: 10%).
               Absolute number is calculated from percentage by rounding down.
               This can not be 0 if MaxSurge is 0.
               Defaults to 0.
               Example: when this is set to 30%, the old MachineSet can be scaled
               down to 70% of desired machines immediately when the rolling update
               starts. Once new machines are ready, old MachineSet can be scaled
               down further, followed by scaling up the new MachineSet, ensuring
               that the total number of machines available at all times
               during the update is at least 70% of desired machines.
        """
        if drain_timeout is not None:
            pulumi.set(__self__, "drain_timeout", drain_timeout)
        if max_surge is not None:
            pulumi.set(__self__, "max_surge", max_surge)
        if max_unavailable is not None:
            pulumi.set(__self__, "max_unavailable", max_unavailable)

    @property
    @pulumi.getter(name="drainTimeout")
    def drain_timeout(self) -> Optional[pulumi.Input[str]]:
        """
        DrainTimeout is the total amount of time that the service will spend on draining a node.
        By default, node can be drained without any time limitations.
        NOTE: NodeDrainTimeout is different from `kubectl drain --timeout`

        Duration as a string: possibly signed sequence of decimal numbers, each with optional fraction and a unit suffix, such as `300ms`, `-1.5h` or `2h45m`. Valid time units are `ns`, `us` (or `µs`), `ms`, `s`, `m`, `h`, `d`.
        """
        return pulumi.get(self, "drain_timeout")

    @drain_timeout.setter
    def drain_timeout(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "drain_timeout", value)

    @property
    @pulumi.getter(name="maxSurge")
    def max_surge(self) -> Optional[pulumi.Input['Mk8sV1alpha1NodeGroupStrategyMaxSurgeArgs']]:
        """
        The maximum number of machines that can be scheduled above the
        desired number of machines.
        Value can be an absolute number (ex: 5) or a percentage of
        desired machines (ex: 10%).
        This can not be 0 if MaxUnavailable is 0.
        Absolute number is calculated from percentage by rounding up.
        Defaults to 1.
        Example: when this is set to 30%, the new MachineSet can be scaled
        up immediately when the rolling update starts, such that the total
        number of old and new machines do not exceed 130% of desired
        machines. Once old machines have been killed, new MachineSet can
        be scaled up further, ensuring that total number of machines running
        at any time during the update is at most 130% of desired machines.
        """
        return pulumi.get(self, "max_surge")

    @max_surge.setter
    def max_surge(self, value: Optional[pulumi.Input['Mk8sV1alpha1NodeGroupStrategyMaxSurgeArgs']]):
        pulumi.set(self, "max_surge", value)

    @property
    @pulumi.getter(name="maxUnavailable")
    def max_unavailable(self) -> Optional[pulumi.Input['Mk8sV1alpha1NodeGroupStrategyMaxUnavailableArgs']]:
        """
        The maximum number of machines that can be unavailable during the update.
        Value can be an absolute number (ex: 5) or a percentage of desired
        machines (ex: 10%).
        Absolute number is calculated from percentage by rounding down.
        This can not be 0 if MaxSurge is 0.
        Defaults to 0.
        Example: when this is set to 30%, the old MachineSet can be scaled
        down to 70% of desired machines immediately when the rolling update
        starts. Once new machines are ready, old MachineSet can be scaled
        down further, followed by scaling up the new MachineSet, ensuring
        that the total number of machines available at all times
        during the update is at least 70% of desired machines.
        """
        return pulumi.get(self, "max_unavailable")

    @max_unavailable.setter
    def max_unavailable(self, value: Optional[pulumi.Input['Mk8sV1alpha1NodeGroupStrategyMaxUnavailableArgs']]):
        pulumi.set(self, "max_unavailable", value)


if not MYPY:
    class Mk8sV1alpha1NodeGroupStrategyMaxSurgeArgsDict(TypedDict):
        count: NotRequired[pulumi.Input[float]]
        """
        *Cannot be set alongside percent.*
        """
        percent: NotRequired[pulumi.Input[float]]
        """
        *Cannot be set alongside count.*
        """
elif False:
    Mk8sV1alpha1NodeGroupStrategyMaxSurgeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class Mk8sV1alpha1NodeGroupStrategyMaxSurgeArgs:
    def __init__(__self__, *,
                 count: Optional[pulumi.Input[float]] = None,
                 percent: Optional[pulumi.Input[float]] = None):
        """
        :param pulumi.Input[float] count: *Cannot be set alongside percent.*
        :param pulumi.Input[float] percent: *Cannot be set alongside count.*
        """
        if count is not None:
            pulumi.set(__self__, "count", count)
        if percent is not None:
            pulumi.set(__self__, "percent", percent)

    @property
    @pulumi.getter
    def count(self) -> Optional[pulumi.Input[float]]:
        """
        *Cannot be set alongside percent.*
        """
        return pulumi.get(self, "count")

    @count.setter
    def count(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "count", value)

    @property
    @pulumi.getter
    def percent(self) -> Optional[pulumi.Input[float]]:
        """
        *Cannot be set alongside count.*
        """
        return pulumi.get(self, "percent")

    @percent.setter
    def percent(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "percent", value)


if not MYPY:
    class Mk8sV1alpha1NodeGroupStrategyMaxUnavailableArgsDict(TypedDict):
        count: NotRequired[pulumi.Input[float]]
        """
        *Cannot be set alongside percent.*
        """
        percent: NotRequired[pulumi.Input[float]]
        """
        *Cannot be set alongside count.*
        """
elif False:
    Mk8sV1alpha1NodeGroupStrategyMaxUnavailableArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class Mk8sV1alpha1NodeGroupStrategyMaxUnavailableArgs:
    def __init__(__self__, *,
                 count: Optional[pulumi.Input[float]] = None,
                 percent: Optional[pulumi.Input[float]] = None):
        """
        :param pulumi.Input[float] count: *Cannot be set alongside percent.*
        :param pulumi.Input[float] percent: *Cannot be set alongside count.*
        """
        if count is not None:
            pulumi.set(__self__, "count", count)
        if percent is not None:
            pulumi.set(__self__, "percent", percent)

    @property
    @pulumi.getter
    def count(self) -> Optional[pulumi.Input[float]]:
        """
        *Cannot be set alongside percent.*
        """
        return pulumi.get(self, "count")

    @count.setter
    def count(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "count", value)

    @property
    @pulumi.getter
    def percent(self) -> Optional[pulumi.Input[float]]:
        """
        *Cannot be set alongside count.*
        """
        return pulumi.get(self, "percent")

    @percent.setter
    def percent(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "percent", value)


if not MYPY:
    class Mk8sV1alpha1NodeGroupTemplateArgsDict(TypedDict):
        resources: pulumi.Input['Mk8sV1alpha1NodeGroupTemplateResourcesArgsDict']
        boot_disk: NotRequired[pulumi.Input['Mk8sV1alpha1NodeGroupTemplateBootDiskArgsDict']]
        cloud_init_user_data: NotRequired[pulumi.Input[str]]
        """
        cloud-init user-data. Must contain at least one SSH key.
        """
        filesystems: NotRequired[pulumi.Input[Sequence[pulumi.Input['Mk8sV1alpha1NodeGroupTemplateFilesystemArgsDict']]]]
        gpu_cluster: NotRequired[pulumi.Input['Mk8sV1alpha1NodeGroupTemplateGpuClusterArgsDict']]
        metadata: NotRequired[pulumi.Input['Mk8sV1alpha1NodeGroupTemplateMetadataArgsDict']]
        network_interfaces: NotRequired[pulumi.Input[Sequence[pulumi.Input['Mk8sV1alpha1NodeGroupTemplateNetworkInterfaceArgsDict']]]]
        service_account_id: NotRequired[pulumi.Input[str]]
        """
        the Nebius service account whose credentials will be available on the nodes of the group.
        With these credentials, it is possible to make `npc` or public API requests from the nodes without the need for extra authentication.
        This service account is also used to make requests to container registry.

        `resource.serviceaccount.issueAccessToken` permission is required to use this field.
        """
        taints: NotRequired[pulumi.Input[Sequence[pulumi.Input['Mk8sV1alpha1NodeGroupTemplateTaintArgsDict']]]]
        """
        ### Inner value description

        See https://kubernetes.io/docs/concepts/scheduling-eviction/taint-and-toleration/
        """
elif False:
    Mk8sV1alpha1NodeGroupTemplateArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class Mk8sV1alpha1NodeGroupTemplateArgs:
    def __init__(__self__, *,
                 resources: pulumi.Input['Mk8sV1alpha1NodeGroupTemplateResourcesArgs'],
                 boot_disk: Optional[pulumi.Input['Mk8sV1alpha1NodeGroupTemplateBootDiskArgs']] = None,
                 cloud_init_user_data: Optional[pulumi.Input[str]] = None,
                 filesystems: Optional[pulumi.Input[Sequence[pulumi.Input['Mk8sV1alpha1NodeGroupTemplateFilesystemArgs']]]] = None,
                 gpu_cluster: Optional[pulumi.Input['Mk8sV1alpha1NodeGroupTemplateGpuClusterArgs']] = None,
                 metadata: Optional[pulumi.Input['Mk8sV1alpha1NodeGroupTemplateMetadataArgs']] = None,
                 network_interfaces: Optional[pulumi.Input[Sequence[pulumi.Input['Mk8sV1alpha1NodeGroupTemplateNetworkInterfaceArgs']]]] = None,
                 service_account_id: Optional[pulumi.Input[str]] = None,
                 taints: Optional[pulumi.Input[Sequence[pulumi.Input['Mk8sV1alpha1NodeGroupTemplateTaintArgs']]]] = None):
        """
        :param pulumi.Input[str] cloud_init_user_data: cloud-init user-data. Must contain at least one SSH key.
        :param pulumi.Input[str] service_account_id: the Nebius service account whose credentials will be available on the nodes of the group.
               With these credentials, it is possible to make `npc` or public API requests from the nodes without the need for extra authentication.
               This service account is also used to make requests to container registry.
               
               `resource.serviceaccount.issueAccessToken` permission is required to use this field.
        :param pulumi.Input[Sequence[pulumi.Input['Mk8sV1alpha1NodeGroupTemplateTaintArgs']]] taints: ### Inner value description
               
               See https://kubernetes.io/docs/concepts/scheduling-eviction/taint-and-toleration/
        """
        pulumi.set(__self__, "resources", resources)
        if boot_disk is not None:
            pulumi.set(__self__, "boot_disk", boot_disk)
        if cloud_init_user_data is not None:
            pulumi.set(__self__, "cloud_init_user_data", cloud_init_user_data)
        if filesystems is not None:
            pulumi.set(__self__, "filesystems", filesystems)
        if gpu_cluster is not None:
            pulumi.set(__self__, "gpu_cluster", gpu_cluster)
        if metadata is not None:
            pulumi.set(__self__, "metadata", metadata)
        if network_interfaces is not None:
            pulumi.set(__self__, "network_interfaces", network_interfaces)
        if service_account_id is not None:
            pulumi.set(__self__, "service_account_id", service_account_id)
        if taints is not None:
            pulumi.set(__self__, "taints", taints)

    @property
    @pulumi.getter
    def resources(self) -> pulumi.Input['Mk8sV1alpha1NodeGroupTemplateResourcesArgs']:
        return pulumi.get(self, "resources")

    @resources.setter
    def resources(self, value: pulumi.Input['Mk8sV1alpha1NodeGroupTemplateResourcesArgs']):
        pulumi.set(self, "resources", value)

    @property
    @pulumi.getter(name="bootDisk")
    def boot_disk(self) -> Optional[pulumi.Input['Mk8sV1alpha1NodeGroupTemplateBootDiskArgs']]:
        return pulumi.get(self, "boot_disk")

    @boot_disk.setter
    def boot_disk(self, value: Optional[pulumi.Input['Mk8sV1alpha1NodeGroupTemplateBootDiskArgs']]):
        pulumi.set(self, "boot_disk", value)

    @property
    @pulumi.getter(name="cloudInitUserData")
    def cloud_init_user_data(self) -> Optional[pulumi.Input[str]]:
        """
        cloud-init user-data. Must contain at least one SSH key.
        """
        return pulumi.get(self, "cloud_init_user_data")

    @cloud_init_user_data.setter
    def cloud_init_user_data(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "cloud_init_user_data", value)

    @property
    @pulumi.getter
    def filesystems(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['Mk8sV1alpha1NodeGroupTemplateFilesystemArgs']]]]:
        return pulumi.get(self, "filesystems")

    @filesystems.setter
    def filesystems(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['Mk8sV1alpha1NodeGroupTemplateFilesystemArgs']]]]):
        pulumi.set(self, "filesystems", value)

    @property
    @pulumi.getter(name="gpuCluster")
    def gpu_cluster(self) -> Optional[pulumi.Input['Mk8sV1alpha1NodeGroupTemplateGpuClusterArgs']]:
        return pulumi.get(self, "gpu_cluster")

    @gpu_cluster.setter
    def gpu_cluster(self, value: Optional[pulumi.Input['Mk8sV1alpha1NodeGroupTemplateGpuClusterArgs']]):
        pulumi.set(self, "gpu_cluster", value)

    @property
    @pulumi.getter
    def metadata(self) -> Optional[pulumi.Input['Mk8sV1alpha1NodeGroupTemplateMetadataArgs']]:
        return pulumi.get(self, "metadata")

    @metadata.setter
    def metadata(self, value: Optional[pulumi.Input['Mk8sV1alpha1NodeGroupTemplateMetadataArgs']]):
        pulumi.set(self, "metadata", value)

    @property
    @pulumi.getter(name="networkInterfaces")
    def network_interfaces(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['Mk8sV1alpha1NodeGroupTemplateNetworkInterfaceArgs']]]]:
        return pulumi.get(self, "network_interfaces")

    @network_interfaces.setter
    def network_interfaces(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['Mk8sV1alpha1NodeGroupTemplateNetworkInterfaceArgs']]]]):
        pulumi.set(self, "network_interfaces", value)

    @property
    @pulumi.getter(name="serviceAccountId")
    def service_account_id(self) -> Optional[pulumi.Input[str]]:
        """
        the Nebius service account whose credentials will be available on the nodes of the group.
        With these credentials, it is possible to make `npc` or public API requests from the nodes without the need for extra authentication.
        This service account is also used to make requests to container registry.

        `resource.serviceaccount.issueAccessToken` permission is required to use this field.
        """
        return pulumi.get(self, "service_account_id")

    @service_account_id.setter
    def service_account_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "service_account_id", value)

    @property
    @pulumi.getter
    def taints(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['Mk8sV1alpha1NodeGroupTemplateTaintArgs']]]]:
        """
        ### Inner value description

        See https://kubernetes.io/docs/concepts/scheduling-eviction/taint-and-toleration/
        """
        return pulumi.get(self, "taints")

    @taints.setter
    def taints(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['Mk8sV1alpha1NodeGroupTemplateTaintArgs']]]]):
        pulumi.set(self, "taints", value)


if not MYPY:
    class Mk8sV1alpha1NodeGroupTemplateBootDiskArgsDict(TypedDict):
        block_size_bytes: NotRequired[pulumi.Input[float]]
        size_bytes: NotRequired[pulumi.Input[float]]
        """
        *Cannot be set alongside size_kibibytes or size_gibibytes.*
        """
        size_gibibytes: NotRequired[pulumi.Input[float]]
        """
        *Cannot be set alongside size_bytes or size_mebibytes.*
        """
        size_kibibytes: NotRequired[pulumi.Input[float]]
        """
        *Cannot be set alongside size_bytes or size_gibibytes.*
        """
        size_mebibytes: NotRequired[pulumi.Input[float]]
        """
        *Cannot be set alongside size_bytes or size_gibibytes.*
        """
        type: NotRequired[pulumi.Input[str]]
        """
        ### Supported values

        Possible values:

         - `UNSPECIFIED`
         - `NETWORK_SSD` - the list of available types will be clarified later, it is not final version
         - `NETWORK_HDD`
         - `NETWORK_SSD_IO_M3`
         - `NETWORK_SSD_NON_REPLICATED`
        """
elif False:
    Mk8sV1alpha1NodeGroupTemplateBootDiskArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class Mk8sV1alpha1NodeGroupTemplateBootDiskArgs:
    def __init__(__self__, *,
                 block_size_bytes: Optional[pulumi.Input[float]] = None,
                 size_bytes: Optional[pulumi.Input[float]] = None,
                 size_gibibytes: Optional[pulumi.Input[float]] = None,
                 size_kibibytes: Optional[pulumi.Input[float]] = None,
                 size_mebibytes: Optional[pulumi.Input[float]] = None,
                 type: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[float] size_bytes: *Cannot be set alongside size_kibibytes or size_gibibytes.*
        :param pulumi.Input[float] size_gibibytes: *Cannot be set alongside size_bytes or size_mebibytes.*
        :param pulumi.Input[float] size_kibibytes: *Cannot be set alongside size_bytes or size_gibibytes.*
        :param pulumi.Input[float] size_mebibytes: *Cannot be set alongside size_bytes or size_gibibytes.*
        :param pulumi.Input[str] type: ### Supported values
               
               Possible values:
               
                - `UNSPECIFIED`
                - `NETWORK_SSD` - the list of available types will be clarified later, it is not final version
                - `NETWORK_HDD`
                - `NETWORK_SSD_IO_M3`
                - `NETWORK_SSD_NON_REPLICATED`
        """
        if block_size_bytes is not None:
            pulumi.set(__self__, "block_size_bytes", block_size_bytes)
        if size_bytes is not None:
            pulumi.set(__self__, "size_bytes", size_bytes)
        if size_gibibytes is not None:
            pulumi.set(__self__, "size_gibibytes", size_gibibytes)
        if size_kibibytes is not None:
            pulumi.set(__self__, "size_kibibytes", size_kibibytes)
        if size_mebibytes is not None:
            pulumi.set(__self__, "size_mebibytes", size_mebibytes)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter(name="blockSizeBytes")
    def block_size_bytes(self) -> Optional[pulumi.Input[float]]:
        return pulumi.get(self, "block_size_bytes")

    @block_size_bytes.setter
    def block_size_bytes(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "block_size_bytes", value)

    @property
    @pulumi.getter(name="sizeBytes")
    def size_bytes(self) -> Optional[pulumi.Input[float]]:
        """
        *Cannot be set alongside size_kibibytes or size_gibibytes.*
        """
        return pulumi.get(self, "size_bytes")

    @size_bytes.setter
    def size_bytes(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "size_bytes", value)

    @property
    @pulumi.getter(name="sizeGibibytes")
    def size_gibibytes(self) -> Optional[pulumi.Input[float]]:
        """
        *Cannot be set alongside size_bytes or size_mebibytes.*
        """
        return pulumi.get(self, "size_gibibytes")

    @size_gibibytes.setter
    def size_gibibytes(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "size_gibibytes", value)

    @property
    @pulumi.getter(name="sizeKibibytes")
    def size_kibibytes(self) -> Optional[pulumi.Input[float]]:
        """
        *Cannot be set alongside size_bytes or size_gibibytes.*
        """
        return pulumi.get(self, "size_kibibytes")

    @size_kibibytes.setter
    def size_kibibytes(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "size_kibibytes", value)

    @property
    @pulumi.getter(name="sizeMebibytes")
    def size_mebibytes(self) -> Optional[pulumi.Input[float]]:
        """
        *Cannot be set alongside size_bytes or size_gibibytes.*
        """
        return pulumi.get(self, "size_mebibytes")

    @size_mebibytes.setter
    def size_mebibytes(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "size_mebibytes", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[str]]:
        """
        ### Supported values

        Possible values:

         - `UNSPECIFIED`
         - `NETWORK_SSD` - the list of available types will be clarified later, it is not final version
         - `NETWORK_HDD`
         - `NETWORK_SSD_IO_M3`
         - `NETWORK_SSD_NON_REPLICATED`
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "type", value)


if not MYPY:
    class Mk8sV1alpha1NodeGroupTemplateFilesystemArgsDict(TypedDict):
        attach_mode: pulumi.Input[str]
        """
        ### Supported values

        Possible values:

         - `UNSPECIFIED`
         - `READ_ONLY`
         - `READ_WRITE`
        """
        device_name: pulumi.Input[str]
        existing_filesystem: NotRequired[pulumi.Input['Mk8sV1alpha1NodeGroupTemplateFilesystemExistingFilesystemArgsDict']]
elif False:
    Mk8sV1alpha1NodeGroupTemplateFilesystemArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class Mk8sV1alpha1NodeGroupTemplateFilesystemArgs:
    def __init__(__self__, *,
                 attach_mode: pulumi.Input[str],
                 device_name: pulumi.Input[str],
                 existing_filesystem: Optional[pulumi.Input['Mk8sV1alpha1NodeGroupTemplateFilesystemExistingFilesystemArgs']] = None):
        """
        :param pulumi.Input[str] attach_mode: ### Supported values
               
               Possible values:
               
                - `UNSPECIFIED`
                - `READ_ONLY`
                - `READ_WRITE`
        """
        pulumi.set(__self__, "attach_mode", attach_mode)
        pulumi.set(__self__, "device_name", device_name)
        if existing_filesystem is not None:
            pulumi.set(__self__, "existing_filesystem", existing_filesystem)

    @property
    @pulumi.getter(name="attachMode")
    def attach_mode(self) -> pulumi.Input[str]:
        """
        ### Supported values

        Possible values:

         - `UNSPECIFIED`
         - `READ_ONLY`
         - `READ_WRITE`
        """
        return pulumi.get(self, "attach_mode")

    @attach_mode.setter
    def attach_mode(self, value: pulumi.Input[str]):
        pulumi.set(self, "attach_mode", value)

    @property
    @pulumi.getter(name="deviceName")
    def device_name(self) -> pulumi.Input[str]:
        return pulumi.get(self, "device_name")

    @device_name.setter
    def device_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "device_name", value)

    @property
    @pulumi.getter(name="existingFilesystem")
    def existing_filesystem(self) -> Optional[pulumi.Input['Mk8sV1alpha1NodeGroupTemplateFilesystemExistingFilesystemArgs']]:
        return pulumi.get(self, "existing_filesystem")

    @existing_filesystem.setter
    def existing_filesystem(self, value: Optional[pulumi.Input['Mk8sV1alpha1NodeGroupTemplateFilesystemExistingFilesystemArgs']]):
        pulumi.set(self, "existing_filesystem", value)


if not MYPY:
    class Mk8sV1alpha1NodeGroupTemplateFilesystemExistingFilesystemArgsDict(TypedDict):
        id: pulumi.Input[str]
elif False:
    Mk8sV1alpha1NodeGroupTemplateFilesystemExistingFilesystemArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class Mk8sV1alpha1NodeGroupTemplateFilesystemExistingFilesystemArgs:
    def __init__(__self__, *,
                 id: pulumi.Input[str]):
        pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> pulumi.Input[str]:
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[str]):
        pulumi.set(self, "id", value)


if not MYPY:
    class Mk8sV1alpha1NodeGroupTemplateGpuClusterArgsDict(TypedDict):
        id: NotRequired[pulumi.Input[str]]
elif False:
    Mk8sV1alpha1NodeGroupTemplateGpuClusterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class Mk8sV1alpha1NodeGroupTemplateGpuClusterArgs:
    def __init__(__self__, *,
                 id: Optional[pulumi.Input[str]] = None):
        if id is not None:
            pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "id", value)


if not MYPY:
    class Mk8sV1alpha1NodeGroupTemplateMetadataArgsDict(TypedDict):
        labels: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[str]]]]
        """
        Labels will be propagated into nodes metadata.
        System labels containing "kubernetes.io" and "k8s.io" will not be propagated.
        On update labels they will not be updated in nodes right away, only on node group update.
        """
elif False:
    Mk8sV1alpha1NodeGroupTemplateMetadataArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class Mk8sV1alpha1NodeGroupTemplateMetadataArgs:
    def __init__(__self__, *,
                 labels: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] labels: Labels will be propagated into nodes metadata.
               System labels containing "kubernetes.io" and "k8s.io" will not be propagated.
               On update labels they will not be updated in nodes right away, only on node group update.
        """
        if labels is not None:
            pulumi.set(__self__, "labels", labels)

    @property
    @pulumi.getter
    def labels(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        Labels will be propagated into nodes metadata.
        System labels containing "kubernetes.io" and "k8s.io" will not be propagated.
        On update labels they will not be updated in nodes right away, only on node group update.
        """
        return pulumi.get(self, "labels")

    @labels.setter
    def labels(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "labels", value)


if not MYPY:
    class Mk8sV1alpha1NodeGroupTemplateNetworkInterfaceArgsDict(TypedDict):
        public_ip_address: NotRequired[pulumi.Input['Mk8sV1alpha1NodeGroupTemplateNetworkInterfacePublicIpAddressArgsDict']]
        """
        Public IPv4 address associated with the interface.

        ### Inner value description

        Describes a public IP address.
        """
        subnet_id: NotRequired[pulumi.Input[str]]
        """
        Subnet ID that will be attached to a node cloud intstance network interface.
        By default control plane subnet_id used.
        Subnet should be located in the same network with control plane and have same parent ID as cluster.
        """
elif False:
    Mk8sV1alpha1NodeGroupTemplateNetworkInterfaceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class Mk8sV1alpha1NodeGroupTemplateNetworkInterfaceArgs:
    def __init__(__self__, *,
                 public_ip_address: Optional[pulumi.Input['Mk8sV1alpha1NodeGroupTemplateNetworkInterfacePublicIpAddressArgs']] = None,
                 subnet_id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input['Mk8sV1alpha1NodeGroupTemplateNetworkInterfacePublicIpAddressArgs'] public_ip_address: Public IPv4 address associated with the interface.
               
               ### Inner value description
               
               Describes a public IP address.
        :param pulumi.Input[str] subnet_id: Subnet ID that will be attached to a node cloud intstance network interface.
               By default control plane subnet_id used.
               Subnet should be located in the same network with control plane and have same parent ID as cluster.
        """
        if public_ip_address is not None:
            pulumi.set(__self__, "public_ip_address", public_ip_address)
        if subnet_id is not None:
            pulumi.set(__self__, "subnet_id", subnet_id)

    @property
    @pulumi.getter(name="publicIpAddress")
    def public_ip_address(self) -> Optional[pulumi.Input['Mk8sV1alpha1NodeGroupTemplateNetworkInterfacePublicIpAddressArgs']]:
        """
        Public IPv4 address associated with the interface.

        ### Inner value description

        Describes a public IP address.
        """
        return pulumi.get(self, "public_ip_address")

    @public_ip_address.setter
    def public_ip_address(self, value: Optional[pulumi.Input['Mk8sV1alpha1NodeGroupTemplateNetworkInterfacePublicIpAddressArgs']]):
        pulumi.set(self, "public_ip_address", value)

    @property
    @pulumi.getter(name="subnetId")
    def subnet_id(self) -> Optional[pulumi.Input[str]]:
        """
        Subnet ID that will be attached to a node cloud intstance network interface.
        By default control plane subnet_id used.
        Subnet should be located in the same network with control plane and have same parent ID as cluster.
        """
        return pulumi.get(self, "subnet_id")

    @subnet_id.setter
    def subnet_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "subnet_id", value)


if not MYPY:
    class Mk8sV1alpha1NodeGroupTemplateNetworkInterfacePublicIpAddressArgsDict(TypedDict):
        pass
elif False:
    Mk8sV1alpha1NodeGroupTemplateNetworkInterfacePublicIpAddressArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class Mk8sV1alpha1NodeGroupTemplateNetworkInterfacePublicIpAddressArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class Mk8sV1alpha1NodeGroupTemplateResourcesArgsDict(TypedDict):
        platform: pulumi.Input[str]
        preset: NotRequired[pulumi.Input[str]]
elif False:
    Mk8sV1alpha1NodeGroupTemplateResourcesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class Mk8sV1alpha1NodeGroupTemplateResourcesArgs:
    def __init__(__self__, *,
                 platform: pulumi.Input[str],
                 preset: Optional[pulumi.Input[str]] = None):
        pulumi.set(__self__, "platform", platform)
        if preset is not None:
            pulumi.set(__self__, "preset", preset)

    @property
    @pulumi.getter
    def platform(self) -> pulumi.Input[str]:
        return pulumi.get(self, "platform")

    @platform.setter
    def platform(self, value: pulumi.Input[str]):
        pulumi.set(self, "platform", value)

    @property
    @pulumi.getter
    def preset(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "preset")

    @preset.setter
    def preset(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "preset", value)


if not MYPY:
    class Mk8sV1alpha1NodeGroupTemplateTaintArgsDict(TypedDict):
        effect: pulumi.Input[str]
        """
        ### Supported values

        Possible values:

         - `EFFECT_UNSPECIFIED`
         - `NO_EXECUTE`
         - `NO_SCHEDULE`
         - `PREFER_NO_SCHEDULE`
        """
        key: pulumi.Input[str]
        value: pulumi.Input[str]
elif False:
    Mk8sV1alpha1NodeGroupTemplateTaintArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class Mk8sV1alpha1NodeGroupTemplateTaintArgs:
    def __init__(__self__, *,
                 effect: pulumi.Input[str],
                 key: pulumi.Input[str],
                 value: pulumi.Input[str]):
        """
        :param pulumi.Input[str] effect: ### Supported values
               
               Possible values:
               
                - `EFFECT_UNSPECIFIED`
                - `NO_EXECUTE`
                - `NO_SCHEDULE`
                - `PREFER_NO_SCHEDULE`
        """
        pulumi.set(__self__, "effect", effect)
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def effect(self) -> pulumi.Input[str]:
        """
        ### Supported values

        Possible values:

         - `EFFECT_UNSPECIFIED`
         - `NO_EXECUTE`
         - `NO_SCHEDULE`
         - `PREFER_NO_SCHEDULE`
        """
        return pulumi.get(self, "effect")

    @effect.setter
    def effect(self, value: pulumi.Input[str]):
        pulumi.set(self, "effect", value)

    @property
    @pulumi.getter
    def key(self) -> pulumi.Input[str]:
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[str]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[str]:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[str]):
        pulumi.set(self, "value", value)


if not MYPY:
    class MspMlflowV1alpha1ClusterMetadataArgsDict(TypedDict):
        pass
elif False:
    MspMlflowV1alpha1ClusterMetadataArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MspMlflowV1alpha1ClusterMetadataArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class MspMlflowV1alpha1ClusterStatusArgsDict(TypedDict):
        effective_storage_bucket_name: NotRequired[pulumi.Input[str]]
        """
        Name of the Nebius S3 bucket for MLflow artifacts.
        """
        experiments_count: NotRequired[pulumi.Input[float]]
        """
        Count of experiments in the MLflow cluster
        """
        mlflow_version: NotRequired[pulumi.Input[str]]
        """
        MLflow version
        """
        phase: NotRequired[pulumi.Input[str]]
        """
        Current phase of the cluster.

        ### Supported values

        Possible values:

         - `PHASE_UNSPECIFIED`
         - `PHASE_PROVISIONING`
         - `PHASE_RUNNING`
         - `PHASE_UPDATING`
         - `PHASE_DELETING`
         - `PHASE_DELETED`
         - `PHASE_PURGING`
         - `PHASE_STOPPING`
         - `PHASE_RESUMING`
        """
        state: NotRequired[pulumi.Input[str]]
        """
        State reflects substatus of the phase to define whether it's healthy or not.

        ### Supported values

        Possible values:

         - `STATE_UNSPECIFIED`
         - `STATE_IN_PROGRESS`
         - `STATE_FINISHED`
         - `STATE_ERROR`
         - `STATE_DEGRADED`
         - `STATE_SCHEDULED`
        """
        tracking_endpoint: NotRequired[pulumi.Input[str]]
        """
        Tracking endpoint url.
        Will be removed soon in favor of private_tracking_endpoint and public_tracking_endpoint.
        """
        tracking_endpoints: NotRequired[pulumi.Input['MspMlflowV1alpha1ClusterStatusTrackingEndpointsArgsDict']]
        """
        Public and private tracking endpoints
        """
elif False:
    MspMlflowV1alpha1ClusterStatusArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MspMlflowV1alpha1ClusterStatusArgs:
    def __init__(__self__, *,
                 effective_storage_bucket_name: Optional[pulumi.Input[str]] = None,
                 experiments_count: Optional[pulumi.Input[float]] = None,
                 mlflow_version: Optional[pulumi.Input[str]] = None,
                 phase: Optional[pulumi.Input[str]] = None,
                 state: Optional[pulumi.Input[str]] = None,
                 tracking_endpoint: Optional[pulumi.Input[str]] = None,
                 tracking_endpoints: Optional[pulumi.Input['MspMlflowV1alpha1ClusterStatusTrackingEndpointsArgs']] = None):
        """
        :param pulumi.Input[str] effective_storage_bucket_name: Name of the Nebius S3 bucket for MLflow artifacts.
        :param pulumi.Input[float] experiments_count: Count of experiments in the MLflow cluster
        :param pulumi.Input[str] mlflow_version: MLflow version
        :param pulumi.Input[str] phase: Current phase of the cluster.
               
               ### Supported values
               
               Possible values:
               
                - `PHASE_UNSPECIFIED`
                - `PHASE_PROVISIONING`
                - `PHASE_RUNNING`
                - `PHASE_UPDATING`
                - `PHASE_DELETING`
                - `PHASE_DELETED`
                - `PHASE_PURGING`
                - `PHASE_STOPPING`
                - `PHASE_RESUMING`
        :param pulumi.Input[str] state: State reflects substatus of the phase to define whether it's healthy or not.
               
               ### Supported values
               
               Possible values:
               
                - `STATE_UNSPECIFIED`
                - `STATE_IN_PROGRESS`
                - `STATE_FINISHED`
                - `STATE_ERROR`
                - `STATE_DEGRADED`
                - `STATE_SCHEDULED`
        :param pulumi.Input[str] tracking_endpoint: Tracking endpoint url.
               Will be removed soon in favor of private_tracking_endpoint and public_tracking_endpoint.
        :param pulumi.Input['MspMlflowV1alpha1ClusterStatusTrackingEndpointsArgs'] tracking_endpoints: Public and private tracking endpoints
        """
        if effective_storage_bucket_name is not None:
            pulumi.set(__self__, "effective_storage_bucket_name", effective_storage_bucket_name)
        if experiments_count is not None:
            pulumi.set(__self__, "experiments_count", experiments_count)
        if mlflow_version is not None:
            pulumi.set(__self__, "mlflow_version", mlflow_version)
        if phase is not None:
            pulumi.set(__self__, "phase", phase)
        if state is not None:
            pulumi.set(__self__, "state", state)
        if tracking_endpoint is not None:
            pulumi.set(__self__, "tracking_endpoint", tracking_endpoint)
        if tracking_endpoints is not None:
            pulumi.set(__self__, "tracking_endpoints", tracking_endpoints)

    @property
    @pulumi.getter(name="effectiveStorageBucketName")
    def effective_storage_bucket_name(self) -> Optional[pulumi.Input[str]]:
        """
        Name of the Nebius S3 bucket for MLflow artifacts.
        """
        return pulumi.get(self, "effective_storage_bucket_name")

    @effective_storage_bucket_name.setter
    def effective_storage_bucket_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "effective_storage_bucket_name", value)

    @property
    @pulumi.getter(name="experimentsCount")
    def experiments_count(self) -> Optional[pulumi.Input[float]]:
        """
        Count of experiments in the MLflow cluster
        """
        return pulumi.get(self, "experiments_count")

    @experiments_count.setter
    def experiments_count(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "experiments_count", value)

    @property
    @pulumi.getter(name="mlflowVersion")
    def mlflow_version(self) -> Optional[pulumi.Input[str]]:
        """
        MLflow version
        """
        return pulumi.get(self, "mlflow_version")

    @mlflow_version.setter
    def mlflow_version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "mlflow_version", value)

    @property
    @pulumi.getter
    def phase(self) -> Optional[pulumi.Input[str]]:
        """
        Current phase of the cluster.

        ### Supported values

        Possible values:

         - `PHASE_UNSPECIFIED`
         - `PHASE_PROVISIONING`
         - `PHASE_RUNNING`
         - `PHASE_UPDATING`
         - `PHASE_DELETING`
         - `PHASE_DELETED`
         - `PHASE_PURGING`
         - `PHASE_STOPPING`
         - `PHASE_RESUMING`
        """
        return pulumi.get(self, "phase")

    @phase.setter
    def phase(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "phase", value)

    @property
    @pulumi.getter
    def state(self) -> Optional[pulumi.Input[str]]:
        """
        State reflects substatus of the phase to define whether it's healthy or not.

        ### Supported values

        Possible values:

         - `STATE_UNSPECIFIED`
         - `STATE_IN_PROGRESS`
         - `STATE_FINISHED`
         - `STATE_ERROR`
         - `STATE_DEGRADED`
         - `STATE_SCHEDULED`
        """
        return pulumi.get(self, "state")

    @state.setter
    def state(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "state", value)

    @property
    @pulumi.getter(name="trackingEndpoint")
    def tracking_endpoint(self) -> Optional[pulumi.Input[str]]:
        """
        Tracking endpoint url.
        Will be removed soon in favor of private_tracking_endpoint and public_tracking_endpoint.
        """
        return pulumi.get(self, "tracking_endpoint")

    @tracking_endpoint.setter
    def tracking_endpoint(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "tracking_endpoint", value)

    @property
    @pulumi.getter(name="trackingEndpoints")
    def tracking_endpoints(self) -> Optional[pulumi.Input['MspMlflowV1alpha1ClusterStatusTrackingEndpointsArgs']]:
        """
        Public and private tracking endpoints
        """
        return pulumi.get(self, "tracking_endpoints")

    @tracking_endpoints.setter
    def tracking_endpoints(self, value: Optional[pulumi.Input['MspMlflowV1alpha1ClusterStatusTrackingEndpointsArgs']]):
        pulumi.set(self, "tracking_endpoints", value)


if not MYPY:
    class MspMlflowV1alpha1ClusterStatusTrackingEndpointsArgsDict(TypedDict):
        private: NotRequired[pulumi.Input[str]]
        """
        Private endpoint
        """
        public: NotRequired[pulumi.Input[str]]
        """
        Public endpoint
        """
elif False:
    MspMlflowV1alpha1ClusterStatusTrackingEndpointsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MspMlflowV1alpha1ClusterStatusTrackingEndpointsArgs:
    def __init__(__self__, *,
                 private: Optional[pulumi.Input[str]] = None,
                 public: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] private: Private endpoint
        :param pulumi.Input[str] public: Public endpoint
        """
        if private is not None:
            pulumi.set(__self__, "private", private)
        if public is not None:
            pulumi.set(__self__, "public", public)

    @property
    @pulumi.getter
    def private(self) -> Optional[pulumi.Input[str]]:
        """
        Private endpoint
        """
        return pulumi.get(self, "private")

    @private.setter
    def private(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "private", value)

    @property
    @pulumi.getter
    def public(self) -> Optional[pulumi.Input[str]]:
        """
        Public endpoint
        """
        return pulumi.get(self, "public")

    @public.setter
    def public(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "public", value)


if not MYPY:
    class MspPostgresqlV1alpha1ClusterBackupArgsDict(TypedDict):
        backup_window_start: NotRequired[pulumi.Input[str]]
        """
        Backup window start in "HH:MM:SS" format (UTC Time)
        """
        retention_policy: NotRequired[pulumi.Input[str]]
        """
        Retention policy to be used for backups and WALs (i.e. '7d')
        """
elif False:
    MspPostgresqlV1alpha1ClusterBackupArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MspPostgresqlV1alpha1ClusterBackupArgs:
    def __init__(__self__, *,
                 backup_window_start: Optional[pulumi.Input[str]] = None,
                 retention_policy: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] backup_window_start: Backup window start in "HH:MM:SS" format (UTC Time)
        :param pulumi.Input[str] retention_policy: Retention policy to be used for backups and WALs (i.e. '7d')
        """
        if backup_window_start is not None:
            pulumi.set(__self__, "backup_window_start", backup_window_start)
        if retention_policy is not None:
            pulumi.set(__self__, "retention_policy", retention_policy)

    @property
    @pulumi.getter(name="backupWindowStart")
    def backup_window_start(self) -> Optional[pulumi.Input[str]]:
        """
        Backup window start in "HH:MM:SS" format (UTC Time)
        """
        return pulumi.get(self, "backup_window_start")

    @backup_window_start.setter
    def backup_window_start(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "backup_window_start", value)

    @property
    @pulumi.getter(name="retentionPolicy")
    def retention_policy(self) -> Optional[pulumi.Input[str]]:
        """
        Retention policy to be used for backups and WALs (i.e. '7d')
        """
        return pulumi.get(self, "retention_policy")

    @retention_policy.setter
    def retention_policy(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "retention_policy", value)


if not MYPY:
    class MspPostgresqlV1alpha1ClusterBootstrapArgsDict(TypedDict):
        db_name: pulumi.Input[str]
        """
        Name of the PostgreSQL database. 1-63 characters long.
        """
        user_name: pulumi.Input[str]
        """
        Name of the bootstrap PostgreSQL user.
        """
        user_password: NotRequired[pulumi.Input[str]]
        """
        Password of the bootstrap PostgreSQL user.
        """
elif False:
    MspPostgresqlV1alpha1ClusterBootstrapArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MspPostgresqlV1alpha1ClusterBootstrapArgs:
    def __init__(__self__, *,
                 db_name: pulumi.Input[str],
                 user_name: pulumi.Input[str],
                 user_password: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] db_name: Name of the PostgreSQL database. 1-63 characters long.
        :param pulumi.Input[str] user_name: Name of the bootstrap PostgreSQL user.
        :param pulumi.Input[str] user_password: Password of the bootstrap PostgreSQL user.
        """
        pulumi.set(__self__, "db_name", db_name)
        pulumi.set(__self__, "user_name", user_name)
        if user_password is not None:
            pulumi.set(__self__, "user_password", user_password)

    @property
    @pulumi.getter(name="dbName")
    def db_name(self) -> pulumi.Input[str]:
        """
        Name of the PostgreSQL database. 1-63 characters long.
        """
        return pulumi.get(self, "db_name")

    @db_name.setter
    def db_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "db_name", value)

    @property
    @pulumi.getter(name="userName")
    def user_name(self) -> pulumi.Input[str]:
        """
        Name of the bootstrap PostgreSQL user.
        """
        return pulumi.get(self, "user_name")

    @user_name.setter
    def user_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "user_name", value)

    @property
    @pulumi.getter(name="userPassword")
    def user_password(self) -> Optional[pulumi.Input[str]]:
        """
        Password of the bootstrap PostgreSQL user.
        """
        return pulumi.get(self, "user_password")

    @user_password.setter
    def user_password(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "user_password", value)


if not MYPY:
    class MspPostgresqlV1alpha1ClusterConfigArgsDict(TypedDict):
        version: pulumi.Input[str]
        """
        Version of PostgreSQL used in the cluster.
        Possible values: `16`
        """
        pooler_config: NotRequired[pulumi.Input['MspPostgresqlV1alpha1ClusterConfigPoolerConfigArgsDict']]
        """
        Configuration of the connection pooler.
        """
        postgresql_config16: NotRequired[pulumi.Input['MspPostgresqlV1alpha1ClusterConfigPostgresqlConfig16ArgsDict']]
        """
        Configuration parameters for postgres
        """
        public_access: NotRequired[pulumi.Input[bool]]
        """
        Either make cluster public accessible or accessible only via private VPC.
        """
        resources: NotRequired[pulumi.Input['MspPostgresqlV1alpha1ClusterConfigResourcesArgsDict']]
        """
        Resources allocated to PostgreSQL hosts.

        use template instead
        """
        template: NotRequired[pulumi.Input['MspPostgresqlV1alpha1ClusterConfigTemplateArgsDict']]
        """
        Resources allocated to PostgreSQL hosts.
        """
elif False:
    MspPostgresqlV1alpha1ClusterConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MspPostgresqlV1alpha1ClusterConfigArgs:
    def __init__(__self__, *,
                 version: pulumi.Input[str],
                 pooler_config: Optional[pulumi.Input['MspPostgresqlV1alpha1ClusterConfigPoolerConfigArgs']] = None,
                 postgresql_config16: Optional[pulumi.Input['MspPostgresqlV1alpha1ClusterConfigPostgresqlConfig16Args']] = None,
                 public_access: Optional[pulumi.Input[bool]] = None,
                 resources: Optional[pulumi.Input['MspPostgresqlV1alpha1ClusterConfigResourcesArgs']] = None,
                 template: Optional[pulumi.Input['MspPostgresqlV1alpha1ClusterConfigTemplateArgs']] = None):
        """
        :param pulumi.Input[str] version: Version of PostgreSQL used in the cluster.
               Possible values: `16`
        :param pulumi.Input['MspPostgresqlV1alpha1ClusterConfigPoolerConfigArgs'] pooler_config: Configuration of the connection pooler.
        :param pulumi.Input['MspPostgresqlV1alpha1ClusterConfigPostgresqlConfig16Args'] postgresql_config16: Configuration parameters for postgres
        :param pulumi.Input[bool] public_access: Either make cluster public accessible or accessible only via private VPC.
        :param pulumi.Input['MspPostgresqlV1alpha1ClusterConfigResourcesArgs'] resources: Resources allocated to PostgreSQL hosts.
               
               use template instead
        :param pulumi.Input['MspPostgresqlV1alpha1ClusterConfigTemplateArgs'] template: Resources allocated to PostgreSQL hosts.
        """
        pulumi.set(__self__, "version", version)
        if pooler_config is not None:
            pulumi.set(__self__, "pooler_config", pooler_config)
        if postgresql_config16 is not None:
            pulumi.set(__self__, "postgresql_config16", postgresql_config16)
        if public_access is not None:
            pulumi.set(__self__, "public_access", public_access)
        if resources is not None:
            warnings.warn("""Deprecated""", DeprecationWarning)
            pulumi.log.warn("""resources is deprecated: Deprecated""")
        if resources is not None:
            pulumi.set(__self__, "resources", resources)
        if template is not None:
            pulumi.set(__self__, "template", template)

    @property
    @pulumi.getter
    def version(self) -> pulumi.Input[str]:
        """
        Version of PostgreSQL used in the cluster.
        Possible values: `16`
        """
        return pulumi.get(self, "version")

    @version.setter
    def version(self, value: pulumi.Input[str]):
        pulumi.set(self, "version", value)

    @property
    @pulumi.getter(name="poolerConfig")
    def pooler_config(self) -> Optional[pulumi.Input['MspPostgresqlV1alpha1ClusterConfigPoolerConfigArgs']]:
        """
        Configuration of the connection pooler.
        """
        return pulumi.get(self, "pooler_config")

    @pooler_config.setter
    def pooler_config(self, value: Optional[pulumi.Input['MspPostgresqlV1alpha1ClusterConfigPoolerConfigArgs']]):
        pulumi.set(self, "pooler_config", value)

    @property
    @pulumi.getter(name="postgresqlConfig16")
    def postgresql_config16(self) -> Optional[pulumi.Input['MspPostgresqlV1alpha1ClusterConfigPostgresqlConfig16Args']]:
        """
        Configuration parameters for postgres
        """
        return pulumi.get(self, "postgresql_config16")

    @postgresql_config16.setter
    def postgresql_config16(self, value: Optional[pulumi.Input['MspPostgresqlV1alpha1ClusterConfigPostgresqlConfig16Args']]):
        pulumi.set(self, "postgresql_config16", value)

    @property
    @pulumi.getter(name="publicAccess")
    def public_access(self) -> Optional[pulumi.Input[bool]]:
        """
        Either make cluster public accessible or accessible only via private VPC.
        """
        return pulumi.get(self, "public_access")

    @public_access.setter
    def public_access(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "public_access", value)

    @property
    @pulumi.getter
    @_utilities.deprecated("""Deprecated""")
    def resources(self) -> Optional[pulumi.Input['MspPostgresqlV1alpha1ClusterConfigResourcesArgs']]:
        """
        Resources allocated to PostgreSQL hosts.

        use template instead
        """
        return pulumi.get(self, "resources")

    @resources.setter
    def resources(self, value: Optional[pulumi.Input['MspPostgresqlV1alpha1ClusterConfigResourcesArgs']]):
        pulumi.set(self, "resources", value)

    @property
    @pulumi.getter
    def template(self) -> Optional[pulumi.Input['MspPostgresqlV1alpha1ClusterConfigTemplateArgs']]:
        """
        Resources allocated to PostgreSQL hosts.
        """
        return pulumi.get(self, "template")

    @template.setter
    def template(self, value: Optional[pulumi.Input['MspPostgresqlV1alpha1ClusterConfigTemplateArgs']]):
        pulumi.set(self, "template", value)


if not MYPY:
    class MspPostgresqlV1alpha1ClusterConfigPoolerConfigArgsDict(TypedDict):
        max_pool_size: NotRequired[pulumi.Input[float]]
        """
        Maximum number of connections in the pool for a single database.
        """
        pooling_mode: NotRequired[pulumi.Input[str]]
        """
        Mode that the connection pooler is working in.

        ### Supported values

        Possible values:

         - `POOLING_MODE_UNSPECIFIED`
         - `SESSION` - Session pooling mode.
         - `TRANSACTION` - Transaction pooling mode.
        """
elif False:
    MspPostgresqlV1alpha1ClusterConfigPoolerConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MspPostgresqlV1alpha1ClusterConfigPoolerConfigArgs:
    def __init__(__self__, *,
                 max_pool_size: Optional[pulumi.Input[float]] = None,
                 pooling_mode: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[float] max_pool_size: Maximum number of connections in the pool for a single database.
        :param pulumi.Input[str] pooling_mode: Mode that the connection pooler is working in.
               
               ### Supported values
               
               Possible values:
               
                - `POOLING_MODE_UNSPECIFIED`
                - `SESSION` - Session pooling mode.
                - `TRANSACTION` - Transaction pooling mode.
        """
        if max_pool_size is not None:
            pulumi.set(__self__, "max_pool_size", max_pool_size)
        if pooling_mode is not None:
            pulumi.set(__self__, "pooling_mode", pooling_mode)

    @property
    @pulumi.getter(name="maxPoolSize")
    def max_pool_size(self) -> Optional[pulumi.Input[float]]:
        """
        Maximum number of connections in the pool for a single database.
        """
        return pulumi.get(self, "max_pool_size")

    @max_pool_size.setter
    def max_pool_size(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "max_pool_size", value)

    @property
    @pulumi.getter(name="poolingMode")
    def pooling_mode(self) -> Optional[pulumi.Input[str]]:
        """
        Mode that the connection pooler is working in.

        ### Supported values

        Possible values:

         - `POOLING_MODE_UNSPECIFIED`
         - `SESSION` - Session pooling mode.
         - `TRANSACTION` - Transaction pooling mode.
        """
        return pulumi.get(self, "pooling_mode")

    @pooling_mode.setter
    def pooling_mode(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "pooling_mode", value)


if not MYPY:
    class MspPostgresqlV1alpha1ClusterConfigPostgresqlConfig16ArgsDict(TypedDict):
        autovacuum_analyze_scale_factor: NotRequired[pulumi.Input[float]]
        autovacuum_naptime: NotRequired[pulumi.Input[float]]
        """
        in seconds.
        """
        autovacuum_vacuum_cost_delay: NotRequired[pulumi.Input[float]]
        """
        in milliseconds.
        """
        autovacuum_vacuum_cost_limit: NotRequired[pulumi.Input[float]]
        autovacuum_vacuum_scale_factor: NotRequired[pulumi.Input[float]]
        autovacuum_work_mem: NotRequired[pulumi.Input[float]]
        """
        in kilobytes.
        """
        default_transaction_read_only: NotRequired[pulumi.Input[bool]]
        idle_in_transaction_session_timeout: NotRequired[pulumi.Input[float]]
        """
        in milliseconds.
        """
        max_connections: NotRequired[pulumi.Input[float]]
        search_path: NotRequired[pulumi.Input[str]]
        shared_buffers: NotRequired[pulumi.Input[float]]
        """
        in kilobytes.
        """
        statement_timeout: NotRequired[pulumi.Input[float]]
        """
        in milliseconds.
        """
elif False:
    MspPostgresqlV1alpha1ClusterConfigPostgresqlConfig16ArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MspPostgresqlV1alpha1ClusterConfigPostgresqlConfig16Args:
    def __init__(__self__, *,
                 autovacuum_analyze_scale_factor: Optional[pulumi.Input[float]] = None,
                 autovacuum_naptime: Optional[pulumi.Input[float]] = None,
                 autovacuum_vacuum_cost_delay: Optional[pulumi.Input[float]] = None,
                 autovacuum_vacuum_cost_limit: Optional[pulumi.Input[float]] = None,
                 autovacuum_vacuum_scale_factor: Optional[pulumi.Input[float]] = None,
                 autovacuum_work_mem: Optional[pulumi.Input[float]] = None,
                 default_transaction_read_only: Optional[pulumi.Input[bool]] = None,
                 idle_in_transaction_session_timeout: Optional[pulumi.Input[float]] = None,
                 max_connections: Optional[pulumi.Input[float]] = None,
                 search_path: Optional[pulumi.Input[str]] = None,
                 shared_buffers: Optional[pulumi.Input[float]] = None,
                 statement_timeout: Optional[pulumi.Input[float]] = None):
        """
        :param pulumi.Input[float] autovacuum_naptime: in seconds.
        :param pulumi.Input[float] autovacuum_vacuum_cost_delay: in milliseconds.
        :param pulumi.Input[float] autovacuum_work_mem: in kilobytes.
        :param pulumi.Input[float] idle_in_transaction_session_timeout: in milliseconds.
        :param pulumi.Input[float] shared_buffers: in kilobytes.
        :param pulumi.Input[float] statement_timeout: in milliseconds.
        """
        if autovacuum_analyze_scale_factor is not None:
            pulumi.set(__self__, "autovacuum_analyze_scale_factor", autovacuum_analyze_scale_factor)
        if autovacuum_naptime is not None:
            pulumi.set(__self__, "autovacuum_naptime", autovacuum_naptime)
        if autovacuum_vacuum_cost_delay is not None:
            pulumi.set(__self__, "autovacuum_vacuum_cost_delay", autovacuum_vacuum_cost_delay)
        if autovacuum_vacuum_cost_limit is not None:
            pulumi.set(__self__, "autovacuum_vacuum_cost_limit", autovacuum_vacuum_cost_limit)
        if autovacuum_vacuum_scale_factor is not None:
            pulumi.set(__self__, "autovacuum_vacuum_scale_factor", autovacuum_vacuum_scale_factor)
        if autovacuum_work_mem is not None:
            pulumi.set(__self__, "autovacuum_work_mem", autovacuum_work_mem)
        if default_transaction_read_only is not None:
            pulumi.set(__self__, "default_transaction_read_only", default_transaction_read_only)
        if idle_in_transaction_session_timeout is not None:
            pulumi.set(__self__, "idle_in_transaction_session_timeout", idle_in_transaction_session_timeout)
        if max_connections is not None:
            pulumi.set(__self__, "max_connections", max_connections)
        if search_path is not None:
            pulumi.set(__self__, "search_path", search_path)
        if shared_buffers is not None:
            pulumi.set(__self__, "shared_buffers", shared_buffers)
        if statement_timeout is not None:
            pulumi.set(__self__, "statement_timeout", statement_timeout)

    @property
    @pulumi.getter(name="autovacuumAnalyzeScaleFactor")
    def autovacuum_analyze_scale_factor(self) -> Optional[pulumi.Input[float]]:
        return pulumi.get(self, "autovacuum_analyze_scale_factor")

    @autovacuum_analyze_scale_factor.setter
    def autovacuum_analyze_scale_factor(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "autovacuum_analyze_scale_factor", value)

    @property
    @pulumi.getter(name="autovacuumNaptime")
    def autovacuum_naptime(self) -> Optional[pulumi.Input[float]]:
        """
        in seconds.
        """
        return pulumi.get(self, "autovacuum_naptime")

    @autovacuum_naptime.setter
    def autovacuum_naptime(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "autovacuum_naptime", value)

    @property
    @pulumi.getter(name="autovacuumVacuumCostDelay")
    def autovacuum_vacuum_cost_delay(self) -> Optional[pulumi.Input[float]]:
        """
        in milliseconds.
        """
        return pulumi.get(self, "autovacuum_vacuum_cost_delay")

    @autovacuum_vacuum_cost_delay.setter
    def autovacuum_vacuum_cost_delay(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "autovacuum_vacuum_cost_delay", value)

    @property
    @pulumi.getter(name="autovacuumVacuumCostLimit")
    def autovacuum_vacuum_cost_limit(self) -> Optional[pulumi.Input[float]]:
        return pulumi.get(self, "autovacuum_vacuum_cost_limit")

    @autovacuum_vacuum_cost_limit.setter
    def autovacuum_vacuum_cost_limit(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "autovacuum_vacuum_cost_limit", value)

    @property
    @pulumi.getter(name="autovacuumVacuumScaleFactor")
    def autovacuum_vacuum_scale_factor(self) -> Optional[pulumi.Input[float]]:
        return pulumi.get(self, "autovacuum_vacuum_scale_factor")

    @autovacuum_vacuum_scale_factor.setter
    def autovacuum_vacuum_scale_factor(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "autovacuum_vacuum_scale_factor", value)

    @property
    @pulumi.getter(name="autovacuumWorkMem")
    def autovacuum_work_mem(self) -> Optional[pulumi.Input[float]]:
        """
        in kilobytes.
        """
        return pulumi.get(self, "autovacuum_work_mem")

    @autovacuum_work_mem.setter
    def autovacuum_work_mem(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "autovacuum_work_mem", value)

    @property
    @pulumi.getter(name="defaultTransactionReadOnly")
    def default_transaction_read_only(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "default_transaction_read_only")

    @default_transaction_read_only.setter
    def default_transaction_read_only(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "default_transaction_read_only", value)

    @property
    @pulumi.getter(name="idleInTransactionSessionTimeout")
    def idle_in_transaction_session_timeout(self) -> Optional[pulumi.Input[float]]:
        """
        in milliseconds.
        """
        return pulumi.get(self, "idle_in_transaction_session_timeout")

    @idle_in_transaction_session_timeout.setter
    def idle_in_transaction_session_timeout(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "idle_in_transaction_session_timeout", value)

    @property
    @pulumi.getter(name="maxConnections")
    def max_connections(self) -> Optional[pulumi.Input[float]]:
        return pulumi.get(self, "max_connections")

    @max_connections.setter
    def max_connections(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "max_connections", value)

    @property
    @pulumi.getter(name="searchPath")
    def search_path(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "search_path")

    @search_path.setter
    def search_path(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "search_path", value)

    @property
    @pulumi.getter(name="sharedBuffers")
    def shared_buffers(self) -> Optional[pulumi.Input[float]]:
        """
        in kilobytes.
        """
        return pulumi.get(self, "shared_buffers")

    @shared_buffers.setter
    def shared_buffers(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "shared_buffers", value)

    @property
    @pulumi.getter(name="statementTimeout")
    def statement_timeout(self) -> Optional[pulumi.Input[float]]:
        """
        in milliseconds.
        """
        return pulumi.get(self, "statement_timeout")

    @statement_timeout.setter
    def statement_timeout(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "statement_timeout", value)


if not MYPY:
    class MspPostgresqlV1alpha1ClusterConfigResourcesArgsDict(TypedDict):
        disk: pulumi.Input['MspPostgresqlV1alpha1ClusterConfigResourcesDiskArgsDict']
        hosts: pulumi.Input['MspPostgresqlV1alpha1ClusterConfigResourcesHostsArgsDict']
        resources: NotRequired[pulumi.Input['MspPostgresqlV1alpha1ClusterConfigResourcesResourcesArgsDict']]
elif False:
    MspPostgresqlV1alpha1ClusterConfigResourcesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MspPostgresqlV1alpha1ClusterConfigResourcesArgs:
    def __init__(__self__, *,
                 disk: pulumi.Input['MspPostgresqlV1alpha1ClusterConfigResourcesDiskArgs'],
                 hosts: pulumi.Input['MspPostgresqlV1alpha1ClusterConfigResourcesHostsArgs'],
                 resources: Optional[pulumi.Input['MspPostgresqlV1alpha1ClusterConfigResourcesResourcesArgs']] = None):
        pulumi.set(__self__, "disk", disk)
        pulumi.set(__self__, "hosts", hosts)
        if resources is not None:
            pulumi.set(__self__, "resources", resources)

    @property
    @pulumi.getter
    def disk(self) -> pulumi.Input['MspPostgresqlV1alpha1ClusterConfigResourcesDiskArgs']:
        return pulumi.get(self, "disk")

    @disk.setter
    def disk(self, value: pulumi.Input['MspPostgresqlV1alpha1ClusterConfigResourcesDiskArgs']):
        pulumi.set(self, "disk", value)

    @property
    @pulumi.getter
    def hosts(self) -> pulumi.Input['MspPostgresqlV1alpha1ClusterConfigResourcesHostsArgs']:
        return pulumi.get(self, "hosts")

    @hosts.setter
    def hosts(self, value: pulumi.Input['MspPostgresqlV1alpha1ClusterConfigResourcesHostsArgs']):
        pulumi.set(self, "hosts", value)

    @property
    @pulumi.getter
    def resources(self) -> Optional[pulumi.Input['MspPostgresqlV1alpha1ClusterConfigResourcesResourcesArgs']]:
        return pulumi.get(self, "resources")

    @resources.setter
    def resources(self, value: Optional[pulumi.Input['MspPostgresqlV1alpha1ClusterConfigResourcesResourcesArgs']]):
        pulumi.set(self, "resources", value)


if not MYPY:
    class MspPostgresqlV1alpha1ClusterConfigResourcesDiskArgsDict(TypedDict):
        size_gibibytes: pulumi.Input[float]
        type: pulumi.Input[str]
elif False:
    MspPostgresqlV1alpha1ClusterConfigResourcesDiskArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MspPostgresqlV1alpha1ClusterConfigResourcesDiskArgs:
    def __init__(__self__, *,
                 size_gibibytes: pulumi.Input[float],
                 type: pulumi.Input[str]):
        pulumi.set(__self__, "size_gibibytes", size_gibibytes)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter(name="sizeGibibytes")
    def size_gibibytes(self) -> pulumi.Input[float]:
        return pulumi.get(self, "size_gibibytes")

    @size_gibibytes.setter
    def size_gibibytes(self, value: pulumi.Input[float]):
        pulumi.set(self, "size_gibibytes", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)


if not MYPY:
    class MspPostgresqlV1alpha1ClusterConfigResourcesHostsArgsDict(TypedDict):
        count: pulumi.Input[float]
elif False:
    MspPostgresqlV1alpha1ClusterConfigResourcesHostsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MspPostgresqlV1alpha1ClusterConfigResourcesHostsArgs:
    def __init__(__self__, *,
                 count: pulumi.Input[float]):
        pulumi.set(__self__, "count", count)

    @property
    @pulumi.getter
    def count(self) -> pulumi.Input[float]:
        return pulumi.get(self, "count")

    @count.setter
    def count(self, value: pulumi.Input[float]):
        pulumi.set(self, "count", value)


if not MYPY:
    class MspPostgresqlV1alpha1ClusterConfigResourcesResourcesArgsDict(TypedDict):
        platform: pulumi.Input[str]
        preset: pulumi.Input[str]
elif False:
    MspPostgresqlV1alpha1ClusterConfigResourcesResourcesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MspPostgresqlV1alpha1ClusterConfigResourcesResourcesArgs:
    def __init__(__self__, *,
                 platform: pulumi.Input[str],
                 preset: pulumi.Input[str]):
        pulumi.set(__self__, "platform", platform)
        pulumi.set(__self__, "preset", preset)

    @property
    @pulumi.getter
    def platform(self) -> pulumi.Input[str]:
        return pulumi.get(self, "platform")

    @platform.setter
    def platform(self, value: pulumi.Input[str]):
        pulumi.set(self, "platform", value)

    @property
    @pulumi.getter
    def preset(self) -> pulumi.Input[str]:
        return pulumi.get(self, "preset")

    @preset.setter
    def preset(self, value: pulumi.Input[str]):
        pulumi.set(self, "preset", value)


if not MYPY:
    class MspPostgresqlV1alpha1ClusterConfigTemplateArgsDict(TypedDict):
        disk: pulumi.Input['MspPostgresqlV1alpha1ClusterConfigTemplateDiskArgsDict']
        hosts: pulumi.Input['MspPostgresqlV1alpha1ClusterConfigTemplateHostsArgsDict']
        resources: pulumi.Input['MspPostgresqlV1alpha1ClusterConfigTemplateResourcesArgsDict']
        """
        reduced msp.v1alpha1.resource.TemplateSpec
        """
elif False:
    MspPostgresqlV1alpha1ClusterConfigTemplateArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MspPostgresqlV1alpha1ClusterConfigTemplateArgs:
    def __init__(__self__, *,
                 disk: pulumi.Input['MspPostgresqlV1alpha1ClusterConfigTemplateDiskArgs'],
                 hosts: pulumi.Input['MspPostgresqlV1alpha1ClusterConfigTemplateHostsArgs'],
                 resources: pulumi.Input['MspPostgresqlV1alpha1ClusterConfigTemplateResourcesArgs']):
        """
        :param pulumi.Input['MspPostgresqlV1alpha1ClusterConfigTemplateResourcesArgs'] resources: reduced msp.v1alpha1.resource.TemplateSpec
        """
        pulumi.set(__self__, "disk", disk)
        pulumi.set(__self__, "hosts", hosts)
        pulumi.set(__self__, "resources", resources)

    @property
    @pulumi.getter
    def disk(self) -> pulumi.Input['MspPostgresqlV1alpha1ClusterConfigTemplateDiskArgs']:
        return pulumi.get(self, "disk")

    @disk.setter
    def disk(self, value: pulumi.Input['MspPostgresqlV1alpha1ClusterConfigTemplateDiskArgs']):
        pulumi.set(self, "disk", value)

    @property
    @pulumi.getter
    def hosts(self) -> pulumi.Input['MspPostgresqlV1alpha1ClusterConfigTemplateHostsArgs']:
        return pulumi.get(self, "hosts")

    @hosts.setter
    def hosts(self, value: pulumi.Input['MspPostgresqlV1alpha1ClusterConfigTemplateHostsArgs']):
        pulumi.set(self, "hosts", value)

    @property
    @pulumi.getter
    def resources(self) -> pulumi.Input['MspPostgresqlV1alpha1ClusterConfigTemplateResourcesArgs']:
        """
        reduced msp.v1alpha1.resource.TemplateSpec
        """
        return pulumi.get(self, "resources")

    @resources.setter
    def resources(self, value: pulumi.Input['MspPostgresqlV1alpha1ClusterConfigTemplateResourcesArgs']):
        pulumi.set(self, "resources", value)


if not MYPY:
    class MspPostgresqlV1alpha1ClusterConfigTemplateDiskArgsDict(TypedDict):
        size_gibibytes: pulumi.Input[float]
        type: pulumi.Input[str]
elif False:
    MspPostgresqlV1alpha1ClusterConfigTemplateDiskArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MspPostgresqlV1alpha1ClusterConfigTemplateDiskArgs:
    def __init__(__self__, *,
                 size_gibibytes: pulumi.Input[float],
                 type: pulumi.Input[str]):
        pulumi.set(__self__, "size_gibibytes", size_gibibytes)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter(name="sizeGibibytes")
    def size_gibibytes(self) -> pulumi.Input[float]:
        return pulumi.get(self, "size_gibibytes")

    @size_gibibytes.setter
    def size_gibibytes(self, value: pulumi.Input[float]):
        pulumi.set(self, "size_gibibytes", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)


if not MYPY:
    class MspPostgresqlV1alpha1ClusterConfigTemplateHostsArgsDict(TypedDict):
        count: pulumi.Input[float]
elif False:
    MspPostgresqlV1alpha1ClusterConfigTemplateHostsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MspPostgresqlV1alpha1ClusterConfigTemplateHostsArgs:
    def __init__(__self__, *,
                 count: pulumi.Input[float]):
        pulumi.set(__self__, "count", count)

    @property
    @pulumi.getter
    def count(self) -> pulumi.Input[float]:
        return pulumi.get(self, "count")

    @count.setter
    def count(self, value: pulumi.Input[float]):
        pulumi.set(self, "count", value)


if not MYPY:
    class MspPostgresqlV1alpha1ClusterConfigTemplateResourcesArgsDict(TypedDict):
        platform: pulumi.Input[str]
        preset: pulumi.Input[str]
elif False:
    MspPostgresqlV1alpha1ClusterConfigTemplateResourcesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MspPostgresqlV1alpha1ClusterConfigTemplateResourcesArgs:
    def __init__(__self__, *,
                 platform: pulumi.Input[str],
                 preset: pulumi.Input[str]):
        pulumi.set(__self__, "platform", platform)
        pulumi.set(__self__, "preset", preset)

    @property
    @pulumi.getter
    def platform(self) -> pulumi.Input[str]:
        return pulumi.get(self, "platform")

    @platform.setter
    def platform(self, value: pulumi.Input[str]):
        pulumi.set(self, "platform", value)

    @property
    @pulumi.getter
    def preset(self) -> pulumi.Input[str]:
        return pulumi.get(self, "preset")

    @preset.setter
    def preset(self, value: pulumi.Input[str]):
        pulumi.set(self, "preset", value)


if not MYPY:
    class MspPostgresqlV1alpha1ClusterMetadataArgsDict(TypedDict):
        pass
elif False:
    MspPostgresqlV1alpha1ClusterMetadataArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MspPostgresqlV1alpha1ClusterMetadataArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class MspPostgresqlV1alpha1ClusterStatusArgsDict(TypedDict):
        connection_endpoints: NotRequired[pulumi.Input['MspPostgresqlV1alpha1ClusterStatusConnectionEndpointsArgsDict']]
        """
        Connection endpoints of the PostgreSQL cluster.
        """
        phase: NotRequired[pulumi.Input[str]]
        """
        Current phase of the cluster.

        ### Supported values

        Possible values:

         - `PHASE_UNSPECIFIED`
         - `PHASE_PROVISIONING`
         - `PHASE_RUNNING`
         - `PHASE_UPDATING`
         - `PHASE_DELETING`
         - `PHASE_DELETED`
         - `PHASE_PURGING`
         - `PHASE_STOPPING`
         - `PHASE_RESUMING`
        """
        preset_details: NotRequired[pulumi.Input['MspPostgresqlV1alpha1ClusterStatusPresetDetailsArgsDict']]
        """
        Cluster resource preset details
        """
        state: NotRequired[pulumi.Input[str]]
        """
        State reflects substatus of the phase to define whether it's healthy or not.

        ### Supported values

        Possible values:

         - `STATE_UNSPECIFIED`
         - `STATE_IN_PROGRESS`
         - `STATE_FINISHED`
         - `STATE_ERROR`
         - `STATE_DEGRADED`
         - `STATE_SCHEDULED`
        """
elif False:
    MspPostgresqlV1alpha1ClusterStatusArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MspPostgresqlV1alpha1ClusterStatusArgs:
    def __init__(__self__, *,
                 connection_endpoints: Optional[pulumi.Input['MspPostgresqlV1alpha1ClusterStatusConnectionEndpointsArgs']] = None,
                 phase: Optional[pulumi.Input[str]] = None,
                 preset_details: Optional[pulumi.Input['MspPostgresqlV1alpha1ClusterStatusPresetDetailsArgs']] = None,
                 state: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input['MspPostgresqlV1alpha1ClusterStatusConnectionEndpointsArgs'] connection_endpoints: Connection endpoints of the PostgreSQL cluster.
        :param pulumi.Input[str] phase: Current phase of the cluster.
               
               ### Supported values
               
               Possible values:
               
                - `PHASE_UNSPECIFIED`
                - `PHASE_PROVISIONING`
                - `PHASE_RUNNING`
                - `PHASE_UPDATING`
                - `PHASE_DELETING`
                - `PHASE_DELETED`
                - `PHASE_PURGING`
                - `PHASE_STOPPING`
                - `PHASE_RESUMING`
        :param pulumi.Input['MspPostgresqlV1alpha1ClusterStatusPresetDetailsArgs'] preset_details: Cluster resource preset details
        :param pulumi.Input[str] state: State reflects substatus of the phase to define whether it's healthy or not.
               
               ### Supported values
               
               Possible values:
               
                - `STATE_UNSPECIFIED`
                - `STATE_IN_PROGRESS`
                - `STATE_FINISHED`
                - `STATE_ERROR`
                - `STATE_DEGRADED`
                - `STATE_SCHEDULED`
        """
        if connection_endpoints is not None:
            pulumi.set(__self__, "connection_endpoints", connection_endpoints)
        if phase is not None:
            pulumi.set(__self__, "phase", phase)
        if preset_details is not None:
            pulumi.set(__self__, "preset_details", preset_details)
        if state is not None:
            pulumi.set(__self__, "state", state)

    @property
    @pulumi.getter(name="connectionEndpoints")
    def connection_endpoints(self) -> Optional[pulumi.Input['MspPostgresqlV1alpha1ClusterStatusConnectionEndpointsArgs']]:
        """
        Connection endpoints of the PostgreSQL cluster.
        """
        return pulumi.get(self, "connection_endpoints")

    @connection_endpoints.setter
    def connection_endpoints(self, value: Optional[pulumi.Input['MspPostgresqlV1alpha1ClusterStatusConnectionEndpointsArgs']]):
        pulumi.set(self, "connection_endpoints", value)

    @property
    @pulumi.getter
    def phase(self) -> Optional[pulumi.Input[str]]:
        """
        Current phase of the cluster.

        ### Supported values

        Possible values:

         - `PHASE_UNSPECIFIED`
         - `PHASE_PROVISIONING`
         - `PHASE_RUNNING`
         - `PHASE_UPDATING`
         - `PHASE_DELETING`
         - `PHASE_DELETED`
         - `PHASE_PURGING`
         - `PHASE_STOPPING`
         - `PHASE_RESUMING`
        """
        return pulumi.get(self, "phase")

    @phase.setter
    def phase(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "phase", value)

    @property
    @pulumi.getter(name="presetDetails")
    def preset_details(self) -> Optional[pulumi.Input['MspPostgresqlV1alpha1ClusterStatusPresetDetailsArgs']]:
        """
        Cluster resource preset details
        """
        return pulumi.get(self, "preset_details")

    @preset_details.setter
    def preset_details(self, value: Optional[pulumi.Input['MspPostgresqlV1alpha1ClusterStatusPresetDetailsArgs']]):
        pulumi.set(self, "preset_details", value)

    @property
    @pulumi.getter
    def state(self) -> Optional[pulumi.Input[str]]:
        """
        State reflects substatus of the phase to define whether it's healthy or not.

        ### Supported values

        Possible values:

         - `STATE_UNSPECIFIED`
         - `STATE_IN_PROGRESS`
         - `STATE_FINISHED`
         - `STATE_ERROR`
         - `STATE_DEGRADED`
         - `STATE_SCHEDULED`
        """
        return pulumi.get(self, "state")

    @state.setter
    def state(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "state", value)


if not MYPY:
    class MspPostgresqlV1alpha1ClusterStatusConnectionEndpointsArgsDict(TypedDict):
        private_read_only: NotRequired[pulumi.Input[str]]
        """
        Read only endpoint of the PostgreSQL cluster accessible from the private VPC.
        """
        private_read_write: NotRequired[pulumi.Input[str]]
        """
        Read write endpoint of the PostgreSQL cluster accessible from the private VPC.
        """
        public_read_only: NotRequired[pulumi.Input[str]]
        """
        Read only endpoint of the PostgreSQL cluster accessible from the internet.
        """
        public_read_write: NotRequired[pulumi.Input[str]]
        """
        Read write endpoint of the PostgreSQL cluster accessible from the internet.
        """
elif False:
    MspPostgresqlV1alpha1ClusterStatusConnectionEndpointsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MspPostgresqlV1alpha1ClusterStatusConnectionEndpointsArgs:
    def __init__(__self__, *,
                 private_read_only: Optional[pulumi.Input[str]] = None,
                 private_read_write: Optional[pulumi.Input[str]] = None,
                 public_read_only: Optional[pulumi.Input[str]] = None,
                 public_read_write: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] private_read_only: Read only endpoint of the PostgreSQL cluster accessible from the private VPC.
        :param pulumi.Input[str] private_read_write: Read write endpoint of the PostgreSQL cluster accessible from the private VPC.
        :param pulumi.Input[str] public_read_only: Read only endpoint of the PostgreSQL cluster accessible from the internet.
        :param pulumi.Input[str] public_read_write: Read write endpoint of the PostgreSQL cluster accessible from the internet.
        """
        if private_read_only is not None:
            pulumi.set(__self__, "private_read_only", private_read_only)
        if private_read_write is not None:
            pulumi.set(__self__, "private_read_write", private_read_write)
        if public_read_only is not None:
            pulumi.set(__self__, "public_read_only", public_read_only)
        if public_read_write is not None:
            pulumi.set(__self__, "public_read_write", public_read_write)

    @property
    @pulumi.getter(name="privateReadOnly")
    def private_read_only(self) -> Optional[pulumi.Input[str]]:
        """
        Read only endpoint of the PostgreSQL cluster accessible from the private VPC.
        """
        return pulumi.get(self, "private_read_only")

    @private_read_only.setter
    def private_read_only(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "private_read_only", value)

    @property
    @pulumi.getter(name="privateReadWrite")
    def private_read_write(self) -> Optional[pulumi.Input[str]]:
        """
        Read write endpoint of the PostgreSQL cluster accessible from the private VPC.
        """
        return pulumi.get(self, "private_read_write")

    @private_read_write.setter
    def private_read_write(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "private_read_write", value)

    @property
    @pulumi.getter(name="publicReadOnly")
    def public_read_only(self) -> Optional[pulumi.Input[str]]:
        """
        Read only endpoint of the PostgreSQL cluster accessible from the internet.
        """
        return pulumi.get(self, "public_read_only")

    @public_read_only.setter
    def public_read_only(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "public_read_only", value)

    @property
    @pulumi.getter(name="publicReadWrite")
    def public_read_write(self) -> Optional[pulumi.Input[str]]:
        """
        Read write endpoint of the PostgreSQL cluster accessible from the internet.
        """
        return pulumi.get(self, "public_read_write")

    @public_read_write.setter
    def public_read_write(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "public_read_write", value)


if not MYPY:
    class MspPostgresqlV1alpha1ClusterStatusPresetDetailsArgsDict(TypedDict):
        cpu_count: NotRequired[pulumi.Input[float]]
        memory_gibibytes: NotRequired[pulumi.Input[float]]
elif False:
    MspPostgresqlV1alpha1ClusterStatusPresetDetailsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MspPostgresqlV1alpha1ClusterStatusPresetDetailsArgs:
    def __init__(__self__, *,
                 cpu_count: Optional[pulumi.Input[float]] = None,
                 memory_gibibytes: Optional[pulumi.Input[float]] = None):
        if cpu_count is not None:
            pulumi.set(__self__, "cpu_count", cpu_count)
        if memory_gibibytes is not None:
            pulumi.set(__self__, "memory_gibibytes", memory_gibibytes)

    @property
    @pulumi.getter(name="cpuCount")
    def cpu_count(self) -> Optional[pulumi.Input[float]]:
        return pulumi.get(self, "cpu_count")

    @cpu_count.setter
    def cpu_count(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "cpu_count", value)

    @property
    @pulumi.getter(name="memoryGibibytes")
    def memory_gibibytes(self) -> Optional[pulumi.Input[float]]:
        return pulumi.get(self, "memory_gibibytes")

    @memory_gibibytes.setter
    def memory_gibibytes(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "memory_gibibytes", value)


if not MYPY:
    class MspSparkV1alpha1ClusterAuthorizationArgsDict(TypedDict):
        password: pulumi.Input[str]
elif False:
    MspSparkV1alpha1ClusterAuthorizationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MspSparkV1alpha1ClusterAuthorizationArgs:
    def __init__(__self__, *,
                 password: pulumi.Input[str]):
        pulumi.set(__self__, "password", password)

    @property
    @pulumi.getter
    def password(self) -> pulumi.Input[str]:
        return pulumi.get(self, "password")

    @password.setter
    def password(self, value: pulumi.Input[str]):
        pulumi.set(self, "password", value)


if not MYPY:
    class MspSparkV1alpha1ClusterLimitsArgsDict(TypedDict):
        cpu: pulumi.Input[float]
        memory_gibibytes: pulumi.Input[float]
elif False:
    MspSparkV1alpha1ClusterLimitsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MspSparkV1alpha1ClusterLimitsArgs:
    def __init__(__self__, *,
                 cpu: pulumi.Input[float],
                 memory_gibibytes: pulumi.Input[float]):
        pulumi.set(__self__, "cpu", cpu)
        pulumi.set(__self__, "memory_gibibytes", memory_gibibytes)

    @property
    @pulumi.getter
    def cpu(self) -> pulumi.Input[float]:
        return pulumi.get(self, "cpu")

    @cpu.setter
    def cpu(self, value: pulumi.Input[float]):
        pulumi.set(self, "cpu", value)

    @property
    @pulumi.getter(name="memoryGibibytes")
    def memory_gibibytes(self) -> pulumi.Input[float]:
        return pulumi.get(self, "memory_gibibytes")

    @memory_gibibytes.setter
    def memory_gibibytes(self, value: pulumi.Input[float]):
        pulumi.set(self, "memory_gibibytes", value)


if not MYPY:
    class MspSparkV1alpha1ClusterMetadataArgsDict(TypedDict):
        pass
elif False:
    MspSparkV1alpha1ClusterMetadataArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MspSparkV1alpha1ClusterMetadataArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class MspSparkV1alpha1ClusterStatusArgsDict(TypedDict):
        history_server_endpoint: NotRequired[pulumi.Input[str]]
        """
        History Server WebUI endpoint
        """
        phase: NotRequired[pulumi.Input[str]]
        """
        Current phase (or stage) of the cluster.

        ### Supported values

        Possible values:

         - `PHASE_UNSPECIFIED`
         - `PHASE_PROVISIONING`
         - `PHASE_RUNNING`
         - `PHASE_UPDATING`
         - `PHASE_DELETING`
         - `PHASE_DELETED`
         - `PHASE_PURGING`
         - `PHASE_STOPPING`
         - `PHASE_RESUMING`
        """
        state: NotRequired[pulumi.Input[str]]
        """
        State reflects substatus of the stage to define whether it's healthy or not.

        ### Supported values

        Possible values:

         - `STATE_UNSPECIFIED`
         - `STATE_IN_PROGRESS`
         - `STATE_FINISHED`
         - `STATE_ERROR`
         - `STATE_DEGRADED`
         - `STATE_SCHEDULED`
        """
elif False:
    MspSparkV1alpha1ClusterStatusArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MspSparkV1alpha1ClusterStatusArgs:
    def __init__(__self__, *,
                 history_server_endpoint: Optional[pulumi.Input[str]] = None,
                 phase: Optional[pulumi.Input[str]] = None,
                 state: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] history_server_endpoint: History Server WebUI endpoint
        :param pulumi.Input[str] phase: Current phase (or stage) of the cluster.
               
               ### Supported values
               
               Possible values:
               
                - `PHASE_UNSPECIFIED`
                - `PHASE_PROVISIONING`
                - `PHASE_RUNNING`
                - `PHASE_UPDATING`
                - `PHASE_DELETING`
                - `PHASE_DELETED`
                - `PHASE_PURGING`
                - `PHASE_STOPPING`
                - `PHASE_RESUMING`
        :param pulumi.Input[str] state: State reflects substatus of the stage to define whether it's healthy or not.
               
               ### Supported values
               
               Possible values:
               
                - `STATE_UNSPECIFIED`
                - `STATE_IN_PROGRESS`
                - `STATE_FINISHED`
                - `STATE_ERROR`
                - `STATE_DEGRADED`
                - `STATE_SCHEDULED`
        """
        if history_server_endpoint is not None:
            pulumi.set(__self__, "history_server_endpoint", history_server_endpoint)
        if phase is not None:
            pulumi.set(__self__, "phase", phase)
        if state is not None:
            pulumi.set(__self__, "state", state)

    @property
    @pulumi.getter(name="historyServerEndpoint")
    def history_server_endpoint(self) -> Optional[pulumi.Input[str]]:
        """
        History Server WebUI endpoint
        """
        return pulumi.get(self, "history_server_endpoint")

    @history_server_endpoint.setter
    def history_server_endpoint(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "history_server_endpoint", value)

    @property
    @pulumi.getter
    def phase(self) -> Optional[pulumi.Input[str]]:
        """
        Current phase (or stage) of the cluster.

        ### Supported values

        Possible values:

         - `PHASE_UNSPECIFIED`
         - `PHASE_PROVISIONING`
         - `PHASE_RUNNING`
         - `PHASE_UPDATING`
         - `PHASE_DELETING`
         - `PHASE_DELETED`
         - `PHASE_PURGING`
         - `PHASE_STOPPING`
         - `PHASE_RESUMING`
        """
        return pulumi.get(self, "phase")

    @phase.setter
    def phase(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "phase", value)

    @property
    @pulumi.getter
    def state(self) -> Optional[pulumi.Input[str]]:
        """
        State reflects substatus of the stage to define whether it's healthy or not.

        ### Supported values

        Possible values:

         - `STATE_UNSPECIFIED`
         - `STATE_IN_PROGRESS`
         - `STATE_FINISHED`
         - `STATE_ERROR`
         - `STATE_DEGRADED`
         - `STATE_SCHEDULED`
        """
        return pulumi.get(self, "state")

    @state.setter
    def state(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "state", value)


if not MYPY:
    class MspSparkV1alpha1SessionDriverArgsDict(TypedDict):
        disk: pulumi.Input['MspSparkV1alpha1SessionDriverDiskArgsDict']
        resources: NotRequired[pulumi.Input['MspSparkV1alpha1SessionDriverResourcesArgsDict']]
elif False:
    MspSparkV1alpha1SessionDriverArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MspSparkV1alpha1SessionDriverArgs:
    def __init__(__self__, *,
                 disk: pulumi.Input['MspSparkV1alpha1SessionDriverDiskArgs'],
                 resources: Optional[pulumi.Input['MspSparkV1alpha1SessionDriverResourcesArgs']] = None):
        pulumi.set(__self__, "disk", disk)
        if resources is not None:
            pulumi.set(__self__, "resources", resources)

    @property
    @pulumi.getter
    def disk(self) -> pulumi.Input['MspSparkV1alpha1SessionDriverDiskArgs']:
        return pulumi.get(self, "disk")

    @disk.setter
    def disk(self, value: pulumi.Input['MspSparkV1alpha1SessionDriverDiskArgs']):
        pulumi.set(self, "disk", value)

    @property
    @pulumi.getter
    def resources(self) -> Optional[pulumi.Input['MspSparkV1alpha1SessionDriverResourcesArgs']]:
        return pulumi.get(self, "resources")

    @resources.setter
    def resources(self, value: Optional[pulumi.Input['MspSparkV1alpha1SessionDriverResourcesArgs']]):
        pulumi.set(self, "resources", value)


if not MYPY:
    class MspSparkV1alpha1SessionDriverDiskArgsDict(TypedDict):
        size_gibibytes: pulumi.Input[float]
        type: pulumi.Input[str]
elif False:
    MspSparkV1alpha1SessionDriverDiskArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MspSparkV1alpha1SessionDriverDiskArgs:
    def __init__(__self__, *,
                 size_gibibytes: pulumi.Input[float],
                 type: pulumi.Input[str]):
        pulumi.set(__self__, "size_gibibytes", size_gibibytes)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter(name="sizeGibibytes")
    def size_gibibytes(self) -> pulumi.Input[float]:
        return pulumi.get(self, "size_gibibytes")

    @size_gibibytes.setter
    def size_gibibytes(self, value: pulumi.Input[float]):
        pulumi.set(self, "size_gibibytes", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)


if not MYPY:
    class MspSparkV1alpha1SessionDriverResourcesArgsDict(TypedDict):
        platform: pulumi.Input[str]
        preset: pulumi.Input[str]
elif False:
    MspSparkV1alpha1SessionDriverResourcesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MspSparkV1alpha1SessionDriverResourcesArgs:
    def __init__(__self__, *,
                 platform: pulumi.Input[str],
                 preset: pulumi.Input[str]):
        pulumi.set(__self__, "platform", platform)
        pulumi.set(__self__, "preset", preset)

    @property
    @pulumi.getter
    def platform(self) -> pulumi.Input[str]:
        return pulumi.get(self, "platform")

    @platform.setter
    def platform(self, value: pulumi.Input[str]):
        pulumi.set(self, "platform", value)

    @property
    @pulumi.getter
    def preset(self) -> pulumi.Input[str]:
        return pulumi.get(self, "preset")

    @preset.setter
    def preset(self, value: pulumi.Input[str]):
        pulumi.set(self, "preset", value)


if not MYPY:
    class MspSparkV1alpha1SessionExecutorArgsDict(TypedDict):
        disk: pulumi.Input['MspSparkV1alpha1SessionExecutorDiskArgsDict']
        hosts: NotRequired[pulumi.Input['MspSparkV1alpha1SessionExecutorHostsArgsDict']]
        """
        *Cannot be set alongside hosts_dynamic_allocation.*
        """
        hosts_dynamic_allocation: NotRequired[pulumi.Input['MspSparkV1alpha1SessionExecutorHostsDynamicAllocationArgsDict']]
        """
        *Cannot be set alongside hosts.*
        """
        resources: NotRequired[pulumi.Input['MspSparkV1alpha1SessionExecutorResourcesArgsDict']]
elif False:
    MspSparkV1alpha1SessionExecutorArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MspSparkV1alpha1SessionExecutorArgs:
    def __init__(__self__, *,
                 disk: pulumi.Input['MspSparkV1alpha1SessionExecutorDiskArgs'],
                 hosts: Optional[pulumi.Input['MspSparkV1alpha1SessionExecutorHostsArgs']] = None,
                 hosts_dynamic_allocation: Optional[pulumi.Input['MspSparkV1alpha1SessionExecutorHostsDynamicAllocationArgs']] = None,
                 resources: Optional[pulumi.Input['MspSparkV1alpha1SessionExecutorResourcesArgs']] = None):
        """
        :param pulumi.Input['MspSparkV1alpha1SessionExecutorHostsArgs'] hosts: *Cannot be set alongside hosts_dynamic_allocation.*
        :param pulumi.Input['MspSparkV1alpha1SessionExecutorHostsDynamicAllocationArgs'] hosts_dynamic_allocation: *Cannot be set alongside hosts.*
        """
        pulumi.set(__self__, "disk", disk)
        if hosts is not None:
            pulumi.set(__self__, "hosts", hosts)
        if hosts_dynamic_allocation is not None:
            pulumi.set(__self__, "hosts_dynamic_allocation", hosts_dynamic_allocation)
        if resources is not None:
            pulumi.set(__self__, "resources", resources)

    @property
    @pulumi.getter
    def disk(self) -> pulumi.Input['MspSparkV1alpha1SessionExecutorDiskArgs']:
        return pulumi.get(self, "disk")

    @disk.setter
    def disk(self, value: pulumi.Input['MspSparkV1alpha1SessionExecutorDiskArgs']):
        pulumi.set(self, "disk", value)

    @property
    @pulumi.getter
    def hosts(self) -> Optional[pulumi.Input['MspSparkV1alpha1SessionExecutorHostsArgs']]:
        """
        *Cannot be set alongside hosts_dynamic_allocation.*
        """
        return pulumi.get(self, "hosts")

    @hosts.setter
    def hosts(self, value: Optional[pulumi.Input['MspSparkV1alpha1SessionExecutorHostsArgs']]):
        pulumi.set(self, "hosts", value)

    @property
    @pulumi.getter(name="hostsDynamicAllocation")
    def hosts_dynamic_allocation(self) -> Optional[pulumi.Input['MspSparkV1alpha1SessionExecutorHostsDynamicAllocationArgs']]:
        """
        *Cannot be set alongside hosts.*
        """
        return pulumi.get(self, "hosts_dynamic_allocation")

    @hosts_dynamic_allocation.setter
    def hosts_dynamic_allocation(self, value: Optional[pulumi.Input['MspSparkV1alpha1SessionExecutorHostsDynamicAllocationArgs']]):
        pulumi.set(self, "hosts_dynamic_allocation", value)

    @property
    @pulumi.getter
    def resources(self) -> Optional[pulumi.Input['MspSparkV1alpha1SessionExecutorResourcesArgs']]:
        return pulumi.get(self, "resources")

    @resources.setter
    def resources(self, value: Optional[pulumi.Input['MspSparkV1alpha1SessionExecutorResourcesArgs']]):
        pulumi.set(self, "resources", value)


if not MYPY:
    class MspSparkV1alpha1SessionExecutorDiskArgsDict(TypedDict):
        size_gibibytes: pulumi.Input[float]
        type: pulumi.Input[str]
elif False:
    MspSparkV1alpha1SessionExecutorDiskArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MspSparkV1alpha1SessionExecutorDiskArgs:
    def __init__(__self__, *,
                 size_gibibytes: pulumi.Input[float],
                 type: pulumi.Input[str]):
        pulumi.set(__self__, "size_gibibytes", size_gibibytes)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter(name="sizeGibibytes")
    def size_gibibytes(self) -> pulumi.Input[float]:
        return pulumi.get(self, "size_gibibytes")

    @size_gibibytes.setter
    def size_gibibytes(self, value: pulumi.Input[float]):
        pulumi.set(self, "size_gibibytes", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)


if not MYPY:
    class MspSparkV1alpha1SessionExecutorHostsArgsDict(TypedDict):
        count: pulumi.Input[float]
elif False:
    MspSparkV1alpha1SessionExecutorHostsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MspSparkV1alpha1SessionExecutorHostsArgs:
    def __init__(__self__, *,
                 count: pulumi.Input[float]):
        pulumi.set(__self__, "count", count)

    @property
    @pulumi.getter
    def count(self) -> pulumi.Input[float]:
        return pulumi.get(self, "count")

    @count.setter
    def count(self, value: pulumi.Input[float]):
        pulumi.set(self, "count", value)


if not MYPY:
    class MspSparkV1alpha1SessionExecutorHostsDynamicAllocationArgsDict(TypedDict):
        max: pulumi.Input[float]
        min: pulumi.Input[float]
elif False:
    MspSparkV1alpha1SessionExecutorHostsDynamicAllocationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MspSparkV1alpha1SessionExecutorHostsDynamicAllocationArgs:
    def __init__(__self__, *,
                 max: pulumi.Input[float],
                 min: pulumi.Input[float]):
        pulumi.set(__self__, "max", max)
        pulumi.set(__self__, "min", min)

    @property
    @pulumi.getter
    def max(self) -> pulumi.Input[float]:
        return pulumi.get(self, "max")

    @max.setter
    def max(self, value: pulumi.Input[float]):
        pulumi.set(self, "max", value)

    @property
    @pulumi.getter
    def min(self) -> pulumi.Input[float]:
        return pulumi.get(self, "min")

    @min.setter
    def min(self, value: pulumi.Input[float]):
        pulumi.set(self, "min", value)


if not MYPY:
    class MspSparkV1alpha1SessionExecutorResourcesArgsDict(TypedDict):
        platform: pulumi.Input[str]
        preset: pulumi.Input[str]
elif False:
    MspSparkV1alpha1SessionExecutorResourcesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MspSparkV1alpha1SessionExecutorResourcesArgs:
    def __init__(__self__, *,
                 platform: pulumi.Input[str],
                 preset: pulumi.Input[str]):
        pulumi.set(__self__, "platform", platform)
        pulumi.set(__self__, "preset", preset)

    @property
    @pulumi.getter
    def platform(self) -> pulumi.Input[str]:
        return pulumi.get(self, "platform")

    @platform.setter
    def platform(self, value: pulumi.Input[str]):
        pulumi.set(self, "platform", value)

    @property
    @pulumi.getter
    def preset(self) -> pulumi.Input[str]:
        return pulumi.get(self, "preset")

    @preset.setter
    def preset(self, value: pulumi.Input[str]):
        pulumi.set(self, "preset", value)


if not MYPY:
    class MspSparkV1alpha1SessionMetadataArgsDict(TypedDict):
        pass
elif False:
    MspSparkV1alpha1SessionMetadataArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MspSparkV1alpha1SessionMetadataArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class MspSparkV1alpha1SessionPythonArgsDict(TypedDict):
        file_uris: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        S3 URIs of files to be placed in PYTHONPATH of driver and executors for python applications (.py, .zip, .egg)
        """
        requirements: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Python requirements
        """
elif False:
    MspSparkV1alpha1SessionPythonArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MspSparkV1alpha1SessionPythonArgs:
    def __init__(__self__, *,
                 file_uris: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 requirements: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] file_uris: S3 URIs of files to be placed in PYTHONPATH of driver and executors for python applications (.py, .zip, .egg)
        :param pulumi.Input[Sequence[pulumi.Input[str]]] requirements: Python requirements
        """
        if file_uris is not None:
            pulumi.set(__self__, "file_uris", file_uris)
        if requirements is not None:
            pulumi.set(__self__, "requirements", requirements)

    @property
    @pulumi.getter(name="fileUris")
    def file_uris(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        S3 URIs of files to be placed in PYTHONPATH of driver and executors for python applications (.py, .zip, .egg)
        """
        return pulumi.get(self, "file_uris")

    @file_uris.setter
    def file_uris(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "file_uris", value)

    @property
    @pulumi.getter
    def requirements(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Python requirements
        """
        return pulumi.get(self, "requirements")

    @requirements.setter
    def requirements(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "requirements", value)


if not MYPY:
    class MspSparkV1alpha1SessionStatusArgsDict(TypedDict):
        driver_preset_details: NotRequired[pulumi.Input['MspSparkV1alpha1SessionStatusDriverPresetDetailsArgsDict']]
        """
        Session driver resource preset details
        """
        executor_preset_details: NotRequired[pulumi.Input['MspSparkV1alpha1SessionStatusExecutorPresetDetailsArgsDict']]
        """
        Session executor resource preset details
        """
        phase: NotRequired[pulumi.Input[str]]
        """
        Current phase (or stage) of the cluster.

        ### Supported values

        Possible values:

         - `PHASE_UNSPECIFIED`
         - `PHASE_PROVISIONING`
         - `PHASE_RUNNING`
         - `PHASE_UPDATING`
         - `PHASE_DELETING`
         - `PHASE_DELETED`
         - `PHASE_PURGING`
         - `PHASE_STOPPING`
         - `PHASE_RESUMING`
        """
        spark_connect_endpoint: NotRequired[pulumi.Input[str]]
        """
        Spark Connect endpoint
        """
        state: NotRequired[pulumi.Input[str]]
        """
        State reflects substatus of the stage to define whether it's healthy or not.

        ### Supported values

        Possible values:

         - `STATE_UNSPECIFIED`
         - `STATE_IN_PROGRESS`
         - `STATE_FINISHED`
         - `STATE_ERROR`
         - `STATE_DEGRADED`
         - `STATE_SCHEDULED`
        """
elif False:
    MspSparkV1alpha1SessionStatusArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MspSparkV1alpha1SessionStatusArgs:
    def __init__(__self__, *,
                 driver_preset_details: Optional[pulumi.Input['MspSparkV1alpha1SessionStatusDriverPresetDetailsArgs']] = None,
                 executor_preset_details: Optional[pulumi.Input['MspSparkV1alpha1SessionStatusExecutorPresetDetailsArgs']] = None,
                 phase: Optional[pulumi.Input[str]] = None,
                 spark_connect_endpoint: Optional[pulumi.Input[str]] = None,
                 state: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input['MspSparkV1alpha1SessionStatusDriverPresetDetailsArgs'] driver_preset_details: Session driver resource preset details
        :param pulumi.Input['MspSparkV1alpha1SessionStatusExecutorPresetDetailsArgs'] executor_preset_details: Session executor resource preset details
        :param pulumi.Input[str] phase: Current phase (or stage) of the cluster.
               
               ### Supported values
               
               Possible values:
               
                - `PHASE_UNSPECIFIED`
                - `PHASE_PROVISIONING`
                - `PHASE_RUNNING`
                - `PHASE_UPDATING`
                - `PHASE_DELETING`
                - `PHASE_DELETED`
                - `PHASE_PURGING`
                - `PHASE_STOPPING`
                - `PHASE_RESUMING`
        :param pulumi.Input[str] spark_connect_endpoint: Spark Connect endpoint
        :param pulumi.Input[str] state: State reflects substatus of the stage to define whether it's healthy or not.
               
               ### Supported values
               
               Possible values:
               
                - `STATE_UNSPECIFIED`
                - `STATE_IN_PROGRESS`
                - `STATE_FINISHED`
                - `STATE_ERROR`
                - `STATE_DEGRADED`
                - `STATE_SCHEDULED`
        """
        if driver_preset_details is not None:
            pulumi.set(__self__, "driver_preset_details", driver_preset_details)
        if executor_preset_details is not None:
            pulumi.set(__self__, "executor_preset_details", executor_preset_details)
        if phase is not None:
            pulumi.set(__self__, "phase", phase)
        if spark_connect_endpoint is not None:
            pulumi.set(__self__, "spark_connect_endpoint", spark_connect_endpoint)
        if state is not None:
            pulumi.set(__self__, "state", state)

    @property
    @pulumi.getter(name="driverPresetDetails")
    def driver_preset_details(self) -> Optional[pulumi.Input['MspSparkV1alpha1SessionStatusDriverPresetDetailsArgs']]:
        """
        Session driver resource preset details
        """
        return pulumi.get(self, "driver_preset_details")

    @driver_preset_details.setter
    def driver_preset_details(self, value: Optional[pulumi.Input['MspSparkV1alpha1SessionStatusDriverPresetDetailsArgs']]):
        pulumi.set(self, "driver_preset_details", value)

    @property
    @pulumi.getter(name="executorPresetDetails")
    def executor_preset_details(self) -> Optional[pulumi.Input['MspSparkV1alpha1SessionStatusExecutorPresetDetailsArgs']]:
        """
        Session executor resource preset details
        """
        return pulumi.get(self, "executor_preset_details")

    @executor_preset_details.setter
    def executor_preset_details(self, value: Optional[pulumi.Input['MspSparkV1alpha1SessionStatusExecutorPresetDetailsArgs']]):
        pulumi.set(self, "executor_preset_details", value)

    @property
    @pulumi.getter
    def phase(self) -> Optional[pulumi.Input[str]]:
        """
        Current phase (or stage) of the cluster.

        ### Supported values

        Possible values:

         - `PHASE_UNSPECIFIED`
         - `PHASE_PROVISIONING`
         - `PHASE_RUNNING`
         - `PHASE_UPDATING`
         - `PHASE_DELETING`
         - `PHASE_DELETED`
         - `PHASE_PURGING`
         - `PHASE_STOPPING`
         - `PHASE_RESUMING`
        """
        return pulumi.get(self, "phase")

    @phase.setter
    def phase(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "phase", value)

    @property
    @pulumi.getter(name="sparkConnectEndpoint")
    def spark_connect_endpoint(self) -> Optional[pulumi.Input[str]]:
        """
        Spark Connect endpoint
        """
        return pulumi.get(self, "spark_connect_endpoint")

    @spark_connect_endpoint.setter
    def spark_connect_endpoint(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "spark_connect_endpoint", value)

    @property
    @pulumi.getter
    def state(self) -> Optional[pulumi.Input[str]]:
        """
        State reflects substatus of the stage to define whether it's healthy or not.

        ### Supported values

        Possible values:

         - `STATE_UNSPECIFIED`
         - `STATE_IN_PROGRESS`
         - `STATE_FINISHED`
         - `STATE_ERROR`
         - `STATE_DEGRADED`
         - `STATE_SCHEDULED`
        """
        return pulumi.get(self, "state")

    @state.setter
    def state(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "state", value)


if not MYPY:
    class MspSparkV1alpha1SessionStatusDriverPresetDetailsArgsDict(TypedDict):
        cpu_count: NotRequired[pulumi.Input[float]]
        memory_gibibytes: NotRequired[pulumi.Input[float]]
elif False:
    MspSparkV1alpha1SessionStatusDriverPresetDetailsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MspSparkV1alpha1SessionStatusDriverPresetDetailsArgs:
    def __init__(__self__, *,
                 cpu_count: Optional[pulumi.Input[float]] = None,
                 memory_gibibytes: Optional[pulumi.Input[float]] = None):
        if cpu_count is not None:
            pulumi.set(__self__, "cpu_count", cpu_count)
        if memory_gibibytes is not None:
            pulumi.set(__self__, "memory_gibibytes", memory_gibibytes)

    @property
    @pulumi.getter(name="cpuCount")
    def cpu_count(self) -> Optional[pulumi.Input[float]]:
        return pulumi.get(self, "cpu_count")

    @cpu_count.setter
    def cpu_count(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "cpu_count", value)

    @property
    @pulumi.getter(name="memoryGibibytes")
    def memory_gibibytes(self) -> Optional[pulumi.Input[float]]:
        return pulumi.get(self, "memory_gibibytes")

    @memory_gibibytes.setter
    def memory_gibibytes(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "memory_gibibytes", value)


if not MYPY:
    class MspSparkV1alpha1SessionStatusExecutorPresetDetailsArgsDict(TypedDict):
        cpu_count: NotRequired[pulumi.Input[float]]
        memory_gibibytes: NotRequired[pulumi.Input[float]]
elif False:
    MspSparkV1alpha1SessionStatusExecutorPresetDetailsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MspSparkV1alpha1SessionStatusExecutorPresetDetailsArgs:
    def __init__(__self__, *,
                 cpu_count: Optional[pulumi.Input[float]] = None,
                 memory_gibibytes: Optional[pulumi.Input[float]] = None):
        if cpu_count is not None:
            pulumi.set(__self__, "cpu_count", cpu_count)
        if memory_gibibytes is not None:
            pulumi.set(__self__, "memory_gibibytes", memory_gibibytes)

    @property
    @pulumi.getter(name="cpuCount")
    def cpu_count(self) -> Optional[pulumi.Input[float]]:
        return pulumi.get(self, "cpu_count")

    @cpu_count.setter
    def cpu_count(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "cpu_count", value)

    @property
    @pulumi.getter(name="memoryGibibytes")
    def memory_gibibytes(self) -> Optional[pulumi.Input[float]]:
        return pulumi.get(self, "memory_gibibytes")

    @memory_gibibytes.setter
    def memory_gibibytes(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "memory_gibibytes", value)


if not MYPY:
    class ProviderAddressOptionsArgsDict(TypedDict):
        insecure: NotRequired[pulumi.Input[bool]]
        """
        use plain http connection
        """
        no_tls_verify: NotRequired[pulumi.Input[bool]]
        """
        don't verify TLS certificates
        """
elif False:
    ProviderAddressOptionsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ProviderAddressOptionsArgs:
    def __init__(__self__, *,
                 insecure: Optional[pulumi.Input[bool]] = None,
                 no_tls_verify: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[bool] insecure: use plain http connection
        :param pulumi.Input[bool] no_tls_verify: don't verify TLS certificates
        """
        if insecure is not None:
            pulumi.set(__self__, "insecure", insecure)
        if no_tls_verify is not None:
            pulumi.set(__self__, "no_tls_verify", no_tls_verify)

    @property
    @pulumi.getter
    def insecure(self) -> Optional[pulumi.Input[bool]]:
        """
        use plain http connection
        """
        return pulumi.get(self, "insecure")

    @insecure.setter
    def insecure(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "insecure", value)

    @property
    @pulumi.getter(name="noTlsVerify")
    def no_tls_verify(self) -> Optional[pulumi.Input[bool]]:
        """
        don't verify TLS certificates
        """
        return pulumi.get(self, "no_tls_verify")

    @no_tls_verify.setter
    def no_tls_verify(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "no_tls_verify", value)


if not MYPY:
    class ProviderAddressTemplateArgsDict(TypedDict):
        find: pulumi.Input[str]
        replace: pulumi.Input[str]
elif False:
    ProviderAddressTemplateArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ProviderAddressTemplateArgs:
    def __init__(__self__, *,
                 find: pulumi.Input[str],
                 replace: pulumi.Input[str]):
        pulumi.set(__self__, "find", find)
        pulumi.set(__self__, "replace", replace)

    @property
    @pulumi.getter
    def find(self) -> pulumi.Input[str]:
        return pulumi.get(self, "find")

    @find.setter
    def find(self, value: pulumi.Input[str]):
        pulumi.set(self, "find", value)

    @property
    @pulumi.getter
    def replace(self) -> pulumi.Input[str]:
        return pulumi.get(self, "replace")

    @replace.setter
    def replace(self, value: pulumi.Input[str]):
        pulumi.set(self, "replace", value)


if not MYPY:
    class ProviderServiceAccountArgsDict(TypedDict):
        account_id: NotRequired[pulumi.Input[str]]
        """
        service account ID (overrides account_id_env)
        """
        account_id_env: NotRequired[pulumi.Input[str]]
        """
        env var containing service account ID
        """
        credentials_file: NotRequired[pulumi.Input[str]]
        """
        file path of the service account credentials file (overrides credentials_file_env)
        You can set this file instead of other parameters here, it will silently override them.
        """
        credentials_file_env: NotRequired[pulumi.Input[str]]
        """
        env var containing file path of the service account credentials, same as credentials_file
        """
        private_key: NotRequired[pulumi.Input[str]]
        """
        private key (overrides private_key_file and private_key_file_env)
        """
        private_key_file: NotRequired[pulumi.Input[str]]
        """
        file path of the service account private key (overrides private_key_file_env)
        """
        private_key_file_env: NotRequired[pulumi.Input[str]]
        """
        env var containing file path of the service account private key
        """
        public_key_id: NotRequired[pulumi.Input[str]]
        """
        service account public key ID (overrides public_key_id_env)
        """
        public_key_id_env: NotRequired[pulumi.Input[str]]
        """
        env var containing service account public key ID
        """
elif False:
    ProviderServiceAccountArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ProviderServiceAccountArgs:
    def __init__(__self__, *,
                 account_id: Optional[pulumi.Input[str]] = None,
                 account_id_env: Optional[pulumi.Input[str]] = None,
                 credentials_file: Optional[pulumi.Input[str]] = None,
                 credentials_file_env: Optional[pulumi.Input[str]] = None,
                 private_key: Optional[pulumi.Input[str]] = None,
                 private_key_file: Optional[pulumi.Input[str]] = None,
                 private_key_file_env: Optional[pulumi.Input[str]] = None,
                 public_key_id: Optional[pulumi.Input[str]] = None,
                 public_key_id_env: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] account_id: service account ID (overrides account_id_env)
        :param pulumi.Input[str] account_id_env: env var containing service account ID
        :param pulumi.Input[str] credentials_file: file path of the service account credentials file (overrides credentials_file_env)
               You can set this file instead of other parameters here, it will silently override them.
        :param pulumi.Input[str] credentials_file_env: env var containing file path of the service account credentials, same as credentials_file
        :param pulumi.Input[str] private_key: private key (overrides private_key_file and private_key_file_env)
        :param pulumi.Input[str] private_key_file: file path of the service account private key (overrides private_key_file_env)
        :param pulumi.Input[str] private_key_file_env: env var containing file path of the service account private key
        :param pulumi.Input[str] public_key_id: service account public key ID (overrides public_key_id_env)
        :param pulumi.Input[str] public_key_id_env: env var containing service account public key ID
        """
        if account_id is not None:
            pulumi.set(__self__, "account_id", account_id)
        if account_id_env is not None:
            pulumi.set(__self__, "account_id_env", account_id_env)
        if credentials_file is not None:
            pulumi.set(__self__, "credentials_file", credentials_file)
        if credentials_file_env is not None:
            pulumi.set(__self__, "credentials_file_env", credentials_file_env)
        if private_key is not None:
            pulumi.set(__self__, "private_key", private_key)
        if private_key_file is not None:
            pulumi.set(__self__, "private_key_file", private_key_file)
        if private_key_file_env is not None:
            pulumi.set(__self__, "private_key_file_env", private_key_file_env)
        if public_key_id is not None:
            pulumi.set(__self__, "public_key_id", public_key_id)
        if public_key_id_env is not None:
            pulumi.set(__self__, "public_key_id_env", public_key_id_env)

    @property
    @pulumi.getter(name="accountId")
    def account_id(self) -> Optional[pulumi.Input[str]]:
        """
        service account ID (overrides account_id_env)
        """
        return pulumi.get(self, "account_id")

    @account_id.setter
    def account_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "account_id", value)

    @property
    @pulumi.getter(name="accountIdEnv")
    def account_id_env(self) -> Optional[pulumi.Input[str]]:
        """
        env var containing service account ID
        """
        return pulumi.get(self, "account_id_env")

    @account_id_env.setter
    def account_id_env(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "account_id_env", value)

    @property
    @pulumi.getter(name="credentialsFile")
    def credentials_file(self) -> Optional[pulumi.Input[str]]:
        """
        file path of the service account credentials file (overrides credentials_file_env)
        You can set this file instead of other parameters here, it will silently override them.
        """
        return pulumi.get(self, "credentials_file")

    @credentials_file.setter
    def credentials_file(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "credentials_file", value)

    @property
    @pulumi.getter(name="credentialsFileEnv")
    def credentials_file_env(self) -> Optional[pulumi.Input[str]]:
        """
        env var containing file path of the service account credentials, same as credentials_file
        """
        return pulumi.get(self, "credentials_file_env")

    @credentials_file_env.setter
    def credentials_file_env(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "credentials_file_env", value)

    @property
    @pulumi.getter(name="privateKey")
    def private_key(self) -> Optional[pulumi.Input[str]]:
        """
        private key (overrides private_key_file and private_key_file_env)
        """
        return pulumi.get(self, "private_key")

    @private_key.setter
    def private_key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "private_key", value)

    @property
    @pulumi.getter(name="privateKeyFile")
    def private_key_file(self) -> Optional[pulumi.Input[str]]:
        """
        file path of the service account private key (overrides private_key_file_env)
        """
        return pulumi.get(self, "private_key_file")

    @private_key_file.setter
    def private_key_file(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "private_key_file", value)

    @property
    @pulumi.getter(name="privateKeyFileEnv")
    def private_key_file_env(self) -> Optional[pulumi.Input[str]]:
        """
        env var containing file path of the service account private key
        """
        return pulumi.get(self, "private_key_file_env")

    @private_key_file_env.setter
    def private_key_file_env(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "private_key_file_env", value)

    @property
    @pulumi.getter(name="publicKeyId")
    def public_key_id(self) -> Optional[pulumi.Input[str]]:
        """
        service account public key ID (overrides public_key_id_env)
        """
        return pulumi.get(self, "public_key_id")

    @public_key_id.setter
    def public_key_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "public_key_id", value)

    @property
    @pulumi.getter(name="publicKeyIdEnv")
    def public_key_id_env(self) -> Optional[pulumi.Input[str]]:
        """
        env var containing service account public key ID
        """
        return pulumi.get(self, "public_key_id_env")

    @public_key_id_env.setter
    def public_key_id_env(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "public_key_id_env", value)


if not MYPY:
    class RegistryV1RegistryMetadataArgsDict(TypedDict):
        pass
elif False:
    RegistryV1RegistryMetadataArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RegistryV1RegistryMetadataArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class RegistryV1RegistryStatusArgsDict(TypedDict):
        images_count: NotRequired[pulumi.Input[float]]
        state: NotRequired[pulumi.Input[str]]
        """
        ### Supported values

        Possible values:

         - `CREATING`
         - `ACTIVE`
         - `DELETING`
         - `SUSPENDED`
        """
elif False:
    RegistryV1RegistryStatusArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RegistryV1RegistryStatusArgs:
    def __init__(__self__, *,
                 images_count: Optional[pulumi.Input[float]] = None,
                 state: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] state: ### Supported values
               
               Possible values:
               
                - `CREATING`
                - `ACTIVE`
                - `DELETING`
                - `SUSPENDED`
        """
        if images_count is not None:
            pulumi.set(__self__, "images_count", images_count)
        if state is not None:
            pulumi.set(__self__, "state", state)

    @property
    @pulumi.getter(name="imagesCount")
    def images_count(self) -> Optional[pulumi.Input[float]]:
        return pulumi.get(self, "images_count")

    @images_count.setter
    def images_count(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "images_count", value)

    @property
    @pulumi.getter
    def state(self) -> Optional[pulumi.Input[str]]:
        """
        ### Supported values

        Possible values:

         - `CREATING`
         - `ACTIVE`
         - `DELETING`
         - `SUSPENDED`
        """
        return pulumi.get(self, "state")

    @state.setter
    def state(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "state", value)


if not MYPY:
    class StorageV1BucketLifecycleConfigurationArgsDict(TypedDict):
        rules: NotRequired[pulumi.Input[Sequence[pulumi.Input['StorageV1BucketLifecycleConfigurationRuleArgsDict']]]]
elif False:
    StorageV1BucketLifecycleConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class StorageV1BucketLifecycleConfigurationArgs:
    def __init__(__self__, *,
                 rules: Optional[pulumi.Input[Sequence[pulumi.Input['StorageV1BucketLifecycleConfigurationRuleArgs']]]] = None):
        if rules is not None:
            pulumi.set(__self__, "rules", rules)

    @property
    @pulumi.getter
    def rules(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['StorageV1BucketLifecycleConfigurationRuleArgs']]]]:
        return pulumi.get(self, "rules")

    @rules.setter
    def rules(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['StorageV1BucketLifecycleConfigurationRuleArgs']]]]):
        pulumi.set(self, "rules", value)


if not MYPY:
    class StorageV1BucketLifecycleConfigurationRuleArgsDict(TypedDict):
        id: pulumi.Input[str]
        """
        Unique identifier for the rule per configuration.
        The value cannot be longer than 255 characters.
        """
        status: pulumi.Input[str]
        """
        ### Supported values

        Possible values:

         - `STATUS_UNSPECIFIED`
         - `ENABLED`
         - `DISABLED`
        """
        abort_incomplete_multipart_upload: NotRequired[pulumi.Input['StorageV1BucketLifecycleConfigurationRuleAbortIncompleteMultipartUploadArgsDict']]
        """
        Specifies the days since the initiation of an incomplete multipart upload that
        the system will wait before permanently removing all parts of the upload.
        """
        expiration: NotRequired[pulumi.Input['StorageV1BucketLifecycleConfigurationRuleExpirationArgsDict']]
        """
        Specifies the expiration for the lifecycle of the object in the form of date, days and,
        whether the object has a delete marker.
        """
        filter: NotRequired[pulumi.Input['StorageV1BucketLifecycleConfigurationRuleFilterArgsDict']]
        """
        The Filter is used to identify objects that a Lifecycle Rule applies to.
        The Lifecycle Rule will apply to any object matching all of the predicates
        configured inside (using logical AND).
        """
        noncurrent_version_expiration: NotRequired[pulumi.Input['StorageV1BucketLifecycleConfigurationRuleNoncurrentVersionExpirationArgsDict']]
        """
        Specifies when noncurrent object versions expire.
        It works only on a bucket that has versioning enabled (or suspended).
        """
elif False:
    StorageV1BucketLifecycleConfigurationRuleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class StorageV1BucketLifecycleConfigurationRuleArgs:
    def __init__(__self__, *,
                 id: pulumi.Input[str],
                 status: pulumi.Input[str],
                 abort_incomplete_multipart_upload: Optional[pulumi.Input['StorageV1BucketLifecycleConfigurationRuleAbortIncompleteMultipartUploadArgs']] = None,
                 expiration: Optional[pulumi.Input['StorageV1BucketLifecycleConfigurationRuleExpirationArgs']] = None,
                 filter: Optional[pulumi.Input['StorageV1BucketLifecycleConfigurationRuleFilterArgs']] = None,
                 noncurrent_version_expiration: Optional[pulumi.Input['StorageV1BucketLifecycleConfigurationRuleNoncurrentVersionExpirationArgs']] = None):
        """
        :param pulumi.Input[str] id: Unique identifier for the rule per configuration.
               The value cannot be longer than 255 characters.
        :param pulumi.Input[str] status: ### Supported values
               
               Possible values:
               
                - `STATUS_UNSPECIFIED`
                - `ENABLED`
                - `DISABLED`
        :param pulumi.Input['StorageV1BucketLifecycleConfigurationRuleAbortIncompleteMultipartUploadArgs'] abort_incomplete_multipart_upload: Specifies the days since the initiation of an incomplete multipart upload that
               the system will wait before permanently removing all parts of the upload.
        :param pulumi.Input['StorageV1BucketLifecycleConfigurationRuleExpirationArgs'] expiration: Specifies the expiration for the lifecycle of the object in the form of date, days and,
               whether the object has a delete marker.
        :param pulumi.Input['StorageV1BucketLifecycleConfigurationRuleFilterArgs'] filter: The Filter is used to identify objects that a Lifecycle Rule applies to.
               The Lifecycle Rule will apply to any object matching all of the predicates
               configured inside (using logical AND).
        :param pulumi.Input['StorageV1BucketLifecycleConfigurationRuleNoncurrentVersionExpirationArgs'] noncurrent_version_expiration: Specifies when noncurrent object versions expire.
               It works only on a bucket that has versioning enabled (or suspended).
        """
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "status", status)
        if abort_incomplete_multipart_upload is not None:
            pulumi.set(__self__, "abort_incomplete_multipart_upload", abort_incomplete_multipart_upload)
        if expiration is not None:
            pulumi.set(__self__, "expiration", expiration)
        if filter is not None:
            pulumi.set(__self__, "filter", filter)
        if noncurrent_version_expiration is not None:
            pulumi.set(__self__, "noncurrent_version_expiration", noncurrent_version_expiration)

    @property
    @pulumi.getter
    def id(self) -> pulumi.Input[str]:
        """
        Unique identifier for the rule per configuration.
        The value cannot be longer than 255 characters.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[str]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter
    def status(self) -> pulumi.Input[str]:
        """
        ### Supported values

        Possible values:

         - `STATUS_UNSPECIFIED`
         - `ENABLED`
         - `DISABLED`
        """
        return pulumi.get(self, "status")

    @status.setter
    def status(self, value: pulumi.Input[str]):
        pulumi.set(self, "status", value)

    @property
    @pulumi.getter(name="abortIncompleteMultipartUpload")
    def abort_incomplete_multipart_upload(self) -> Optional[pulumi.Input['StorageV1BucketLifecycleConfigurationRuleAbortIncompleteMultipartUploadArgs']]:
        """
        Specifies the days since the initiation of an incomplete multipart upload that
        the system will wait before permanently removing all parts of the upload.
        """
        return pulumi.get(self, "abort_incomplete_multipart_upload")

    @abort_incomplete_multipart_upload.setter
    def abort_incomplete_multipart_upload(self, value: Optional[pulumi.Input['StorageV1BucketLifecycleConfigurationRuleAbortIncompleteMultipartUploadArgs']]):
        pulumi.set(self, "abort_incomplete_multipart_upload", value)

    @property
    @pulumi.getter
    def expiration(self) -> Optional[pulumi.Input['StorageV1BucketLifecycleConfigurationRuleExpirationArgs']]:
        """
        Specifies the expiration for the lifecycle of the object in the form of date, days and,
        whether the object has a delete marker.
        """
        return pulumi.get(self, "expiration")

    @expiration.setter
    def expiration(self, value: Optional[pulumi.Input['StorageV1BucketLifecycleConfigurationRuleExpirationArgs']]):
        pulumi.set(self, "expiration", value)

    @property
    @pulumi.getter
    def filter(self) -> Optional[pulumi.Input['StorageV1BucketLifecycleConfigurationRuleFilterArgs']]:
        """
        The Filter is used to identify objects that a Lifecycle Rule applies to.
        The Lifecycle Rule will apply to any object matching all of the predicates
        configured inside (using logical AND).
        """
        return pulumi.get(self, "filter")

    @filter.setter
    def filter(self, value: Optional[pulumi.Input['StorageV1BucketLifecycleConfigurationRuleFilterArgs']]):
        pulumi.set(self, "filter", value)

    @property
    @pulumi.getter(name="noncurrentVersionExpiration")
    def noncurrent_version_expiration(self) -> Optional[pulumi.Input['StorageV1BucketLifecycleConfigurationRuleNoncurrentVersionExpirationArgs']]:
        """
        Specifies when noncurrent object versions expire.
        It works only on a bucket that has versioning enabled (or suspended).
        """
        return pulumi.get(self, "noncurrent_version_expiration")

    @noncurrent_version_expiration.setter
    def noncurrent_version_expiration(self, value: Optional[pulumi.Input['StorageV1BucketLifecycleConfigurationRuleNoncurrentVersionExpirationArgs']]):
        pulumi.set(self, "noncurrent_version_expiration", value)


if not MYPY:
    class StorageV1BucketLifecycleConfigurationRuleAbortIncompleteMultipartUploadArgsDict(TypedDict):
        days_after_initiation: NotRequired[pulumi.Input[float]]
        """
        Specifies the days since the initiation of an incomplete multipart upload that
        the system will wait before permanently removing all parts of the upload.
        """
elif False:
    StorageV1BucketLifecycleConfigurationRuleAbortIncompleteMultipartUploadArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class StorageV1BucketLifecycleConfigurationRuleAbortIncompleteMultipartUploadArgs:
    def __init__(__self__, *,
                 days_after_initiation: Optional[pulumi.Input[float]] = None):
        """
        :param pulumi.Input[float] days_after_initiation: Specifies the days since the initiation of an incomplete multipart upload that
               the system will wait before permanently removing all parts of the upload.
        """
        if days_after_initiation is not None:
            pulumi.set(__self__, "days_after_initiation", days_after_initiation)

    @property
    @pulumi.getter(name="daysAfterInitiation")
    def days_after_initiation(self) -> Optional[pulumi.Input[float]]:
        """
        Specifies the days since the initiation of an incomplete multipart upload that
        the system will wait before permanently removing all parts of the upload.
        """
        return pulumi.get(self, "days_after_initiation")

    @days_after_initiation.setter
    def days_after_initiation(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "days_after_initiation", value)


if not MYPY:
    class StorageV1BucketLifecycleConfigurationRuleExpirationArgsDict(TypedDict):
        date: NotRequired[pulumi.Input[str]]
        """
        Indicates at what date the object will be deleted. The time is always midnight UTC.

        A string representing a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ` or `YYYY-MM-DDTHH:MM:SS.SSS±HH:MM`

        *Cannot be set alongside days.*
        """
        days: NotRequired[pulumi.Input[float]]
        """
        Indicates the lifetime, in days, of the objects that are subject to the rule.
        The value must be a non-zero positive integer.

        *Cannot be set alongside date.*
        """
        expired_object_delete_marker: NotRequired[pulumi.Input[bool]]
        """
        Indicates whether the system will remove a "delete marker" with no noncurrent versions.
        If set to true, the "delete marker" will be permanently removed.
        If set to false the policy takes no action.
        This cannot be specified with Days or Date in a LifecycleExpiration Policy.
        """
elif False:
    StorageV1BucketLifecycleConfigurationRuleExpirationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class StorageV1BucketLifecycleConfigurationRuleExpirationArgs:
    def __init__(__self__, *,
                 date: Optional[pulumi.Input[str]] = None,
                 days: Optional[pulumi.Input[float]] = None,
                 expired_object_delete_marker: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[str] date: Indicates at what date the object will be deleted. The time is always midnight UTC.
               
               A string representing a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ` or `YYYY-MM-DDTHH:MM:SS.SSS±HH:MM`
               
               *Cannot be set alongside days.*
        :param pulumi.Input[float] days: Indicates the lifetime, in days, of the objects that are subject to the rule.
               The value must be a non-zero positive integer.
               
               *Cannot be set alongside date.*
        :param pulumi.Input[bool] expired_object_delete_marker: Indicates whether the system will remove a "delete marker" with no noncurrent versions.
               If set to true, the "delete marker" will be permanently removed.
               If set to false the policy takes no action.
               This cannot be specified with Days or Date in a LifecycleExpiration Policy.
        """
        if date is not None:
            pulumi.set(__self__, "date", date)
        if days is not None:
            pulumi.set(__self__, "days", days)
        if expired_object_delete_marker is not None:
            pulumi.set(__self__, "expired_object_delete_marker", expired_object_delete_marker)

    @property
    @pulumi.getter
    def date(self) -> Optional[pulumi.Input[str]]:
        """
        Indicates at what date the object will be deleted. The time is always midnight UTC.

        A string representing a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ` or `YYYY-MM-DDTHH:MM:SS.SSS±HH:MM`

        *Cannot be set alongside days.*
        """
        return pulumi.get(self, "date")

    @date.setter
    def date(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "date", value)

    @property
    @pulumi.getter
    def days(self) -> Optional[pulumi.Input[float]]:
        """
        Indicates the lifetime, in days, of the objects that are subject to the rule.
        The value must be a non-zero positive integer.

        *Cannot be set alongside date.*
        """
        return pulumi.get(self, "days")

    @days.setter
    def days(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "days", value)

    @property
    @pulumi.getter(name="expiredObjectDeleteMarker")
    def expired_object_delete_marker(self) -> Optional[pulumi.Input[bool]]:
        """
        Indicates whether the system will remove a "delete marker" with no noncurrent versions.
        If set to true, the "delete marker" will be permanently removed.
        If set to false the policy takes no action.
        This cannot be specified with Days or Date in a LifecycleExpiration Policy.
        """
        return pulumi.get(self, "expired_object_delete_marker")

    @expired_object_delete_marker.setter
    def expired_object_delete_marker(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "expired_object_delete_marker", value)


if not MYPY:
    class StorageV1BucketLifecycleConfigurationRuleFilterArgsDict(TypedDict):
        object_size_greater_than_bytes: NotRequired[pulumi.Input[float]]
        """
        Minimum object size to which the rule applies.
        """
        object_size_less_than_bytes: NotRequired[pulumi.Input[float]]
        """
        Maximum object size to which the rule applies.
        """
        prefix: NotRequired[pulumi.Input[str]]
        """
        Prefix identifying one or more objects to which the rule applies.
        If prefix is empty, the rule applies to all objects in the bucket.
        """
elif False:
    StorageV1BucketLifecycleConfigurationRuleFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class StorageV1BucketLifecycleConfigurationRuleFilterArgs:
    def __init__(__self__, *,
                 object_size_greater_than_bytes: Optional[pulumi.Input[float]] = None,
                 object_size_less_than_bytes: Optional[pulumi.Input[float]] = None,
                 prefix: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[float] object_size_greater_than_bytes: Minimum object size to which the rule applies.
        :param pulumi.Input[float] object_size_less_than_bytes: Maximum object size to which the rule applies.
        :param pulumi.Input[str] prefix: Prefix identifying one or more objects to which the rule applies.
               If prefix is empty, the rule applies to all objects in the bucket.
        """
        if object_size_greater_than_bytes is not None:
            pulumi.set(__self__, "object_size_greater_than_bytes", object_size_greater_than_bytes)
        if object_size_less_than_bytes is not None:
            pulumi.set(__self__, "object_size_less_than_bytes", object_size_less_than_bytes)
        if prefix is not None:
            pulumi.set(__self__, "prefix", prefix)

    @property
    @pulumi.getter(name="objectSizeGreaterThanBytes")
    def object_size_greater_than_bytes(self) -> Optional[pulumi.Input[float]]:
        """
        Minimum object size to which the rule applies.
        """
        return pulumi.get(self, "object_size_greater_than_bytes")

    @object_size_greater_than_bytes.setter
    def object_size_greater_than_bytes(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "object_size_greater_than_bytes", value)

    @property
    @pulumi.getter(name="objectSizeLessThanBytes")
    def object_size_less_than_bytes(self) -> Optional[pulumi.Input[float]]:
        """
        Maximum object size to which the rule applies.
        """
        return pulumi.get(self, "object_size_less_than_bytes")

    @object_size_less_than_bytes.setter
    def object_size_less_than_bytes(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "object_size_less_than_bytes", value)

    @property
    @pulumi.getter
    def prefix(self) -> Optional[pulumi.Input[str]]:
        """
        Prefix identifying one or more objects to which the rule applies.
        If prefix is empty, the rule applies to all objects in the bucket.
        """
        return pulumi.get(self, "prefix")

    @prefix.setter
    def prefix(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "prefix", value)


if not MYPY:
    class StorageV1BucketLifecycleConfigurationRuleNoncurrentVersionExpirationArgsDict(TypedDict):
        newer_noncurrent_versions: NotRequired[pulumi.Input[float]]
        """
        Specifies how many noncurrent versions the system will retain.
        """
        noncurrent_days: NotRequired[pulumi.Input[float]]
        """
        Specifies the number of days an object is noncurrent before the system will expire it.
        """
elif False:
    StorageV1BucketLifecycleConfigurationRuleNoncurrentVersionExpirationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class StorageV1BucketLifecycleConfigurationRuleNoncurrentVersionExpirationArgs:
    def __init__(__self__, *,
                 newer_noncurrent_versions: Optional[pulumi.Input[float]] = None,
                 noncurrent_days: Optional[pulumi.Input[float]] = None):
        """
        :param pulumi.Input[float] newer_noncurrent_versions: Specifies how many noncurrent versions the system will retain.
        :param pulumi.Input[float] noncurrent_days: Specifies the number of days an object is noncurrent before the system will expire it.
        """
        if newer_noncurrent_versions is not None:
            pulumi.set(__self__, "newer_noncurrent_versions", newer_noncurrent_versions)
        if noncurrent_days is not None:
            pulumi.set(__self__, "noncurrent_days", noncurrent_days)

    @property
    @pulumi.getter(name="newerNoncurrentVersions")
    def newer_noncurrent_versions(self) -> Optional[pulumi.Input[float]]:
        """
        Specifies how many noncurrent versions the system will retain.
        """
        return pulumi.get(self, "newer_noncurrent_versions")

    @newer_noncurrent_versions.setter
    def newer_noncurrent_versions(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "newer_noncurrent_versions", value)

    @property
    @pulumi.getter(name="noncurrentDays")
    def noncurrent_days(self) -> Optional[pulumi.Input[float]]:
        """
        Specifies the number of days an object is noncurrent before the system will expire it.
        """
        return pulumi.get(self, "noncurrent_days")

    @noncurrent_days.setter
    def noncurrent_days(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "noncurrent_days", value)


if not MYPY:
    class StorageV1BucketMetadataArgsDict(TypedDict):
        pass
elif False:
    StorageV1BucketMetadataArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class StorageV1BucketMetadataArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class StorageV1BucketStatusArgsDict(TypedDict):
        counters: NotRequired[pulumi.Input[Sequence[pulumi.Input['StorageV1BucketStatusCounterArgsDict']]]]
        deleted_at: NotRequired[pulumi.Input[str]]
        """
        The time when the bucket was deleted (or scheduled for deletion).
        It resets to null if the bucket is undeleted.

        A string representing a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ` or `YYYY-MM-DDTHH:MM:SS.SSS±HH:MM`
        """
        domain_name: NotRequired[pulumi.Input[str]]
        """
        The domain of the endpoint where the bucket can be accessed. It omits the scheme (HTTPS) and the port (443)
        and contains only the FQDN address.
        """
        purge_at: NotRequired[pulumi.Input[str]]
        """
        The time when the bucket will be automatically purged in case it was soft-deleted.

        A string representing a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ` or `YYYY-MM-DDTHH:MM:SS.SSS±HH:MM`
        """
        state: NotRequired[pulumi.Input[str]]
        """
        ### Supported values

        Possible values:

         - `STATE_UNSPECIFIED`
         - `CREATING` - Bucket is under creation and cannot be used yet.
         - `ACTIVE` - Bucket is active and ready for usage.
         - `UPDATING` - Bucket is being updated.
        It can be used, but some settings are being modified and you can observe their inconsistency.
         - `SCHEDULED_FOR_DELETION` - Bucket is scheduled for deletion.
        It cannot be used in s3 api anymore.
        """
        suspension_state: NotRequired[pulumi.Input[str]]
        """
        ### Supported values

        Possible values:

         - `SUSPENSION_STATE_UNSPECIFIED`
         - `NOT_SUSPENDED`
         - `SUSPENDED`
        """
elif False:
    StorageV1BucketStatusArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class StorageV1BucketStatusArgs:
    def __init__(__self__, *,
                 counters: Optional[pulumi.Input[Sequence[pulumi.Input['StorageV1BucketStatusCounterArgs']]]] = None,
                 deleted_at: Optional[pulumi.Input[str]] = None,
                 domain_name: Optional[pulumi.Input[str]] = None,
                 purge_at: Optional[pulumi.Input[str]] = None,
                 state: Optional[pulumi.Input[str]] = None,
                 suspension_state: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] deleted_at: The time when the bucket was deleted (or scheduled for deletion).
               It resets to null if the bucket is undeleted.
               
               A string representing a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ` or `YYYY-MM-DDTHH:MM:SS.SSS±HH:MM`
        :param pulumi.Input[str] domain_name: The domain of the endpoint where the bucket can be accessed. It omits the scheme (HTTPS) and the port (443)
               and contains only the FQDN address.
        :param pulumi.Input[str] purge_at: The time when the bucket will be automatically purged in case it was soft-deleted.
               
               A string representing a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ` or `YYYY-MM-DDTHH:MM:SS.SSS±HH:MM`
        :param pulumi.Input[str] state: ### Supported values
               
               Possible values:
               
                - `STATE_UNSPECIFIED`
                - `CREATING` - Bucket is under creation and cannot be used yet.
                - `ACTIVE` - Bucket is active and ready for usage.
                - `UPDATING` - Bucket is being updated.
               It can be used, but some settings are being modified and you can observe their inconsistency.
                - `SCHEDULED_FOR_DELETION` - Bucket is scheduled for deletion.
               It cannot be used in s3 api anymore.
        :param pulumi.Input[str] suspension_state: ### Supported values
               
               Possible values:
               
                - `SUSPENSION_STATE_UNSPECIFIED`
                - `NOT_SUSPENDED`
                - `SUSPENDED`
        """
        if counters is not None:
            pulumi.set(__self__, "counters", counters)
        if deleted_at is not None:
            pulumi.set(__self__, "deleted_at", deleted_at)
        if domain_name is not None:
            pulumi.set(__self__, "domain_name", domain_name)
        if purge_at is not None:
            pulumi.set(__self__, "purge_at", purge_at)
        if state is not None:
            pulumi.set(__self__, "state", state)
        if suspension_state is not None:
            pulumi.set(__self__, "suspension_state", suspension_state)

    @property
    @pulumi.getter
    def counters(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['StorageV1BucketStatusCounterArgs']]]]:
        return pulumi.get(self, "counters")

    @counters.setter
    def counters(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['StorageV1BucketStatusCounterArgs']]]]):
        pulumi.set(self, "counters", value)

    @property
    @pulumi.getter(name="deletedAt")
    def deleted_at(self) -> Optional[pulumi.Input[str]]:
        """
        The time when the bucket was deleted (or scheduled for deletion).
        It resets to null if the bucket is undeleted.

        A string representing a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ` or `YYYY-MM-DDTHH:MM:SS.SSS±HH:MM`
        """
        return pulumi.get(self, "deleted_at")

    @deleted_at.setter
    def deleted_at(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "deleted_at", value)

    @property
    @pulumi.getter(name="domainName")
    def domain_name(self) -> Optional[pulumi.Input[str]]:
        """
        The domain of the endpoint where the bucket can be accessed. It omits the scheme (HTTPS) and the port (443)
        and contains only the FQDN address.
        """
        return pulumi.get(self, "domain_name")

    @domain_name.setter
    def domain_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "domain_name", value)

    @property
    @pulumi.getter(name="purgeAt")
    def purge_at(self) -> Optional[pulumi.Input[str]]:
        """
        The time when the bucket will be automatically purged in case it was soft-deleted.

        A string representing a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ` or `YYYY-MM-DDTHH:MM:SS.SSS±HH:MM`
        """
        return pulumi.get(self, "purge_at")

    @purge_at.setter
    def purge_at(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "purge_at", value)

    @property
    @pulumi.getter
    def state(self) -> Optional[pulumi.Input[str]]:
        """
        ### Supported values

        Possible values:

         - `STATE_UNSPECIFIED`
         - `CREATING` - Bucket is under creation and cannot be used yet.
         - `ACTIVE` - Bucket is active and ready for usage.
         - `UPDATING` - Bucket is being updated.
        It can be used, but some settings are being modified and you can observe their inconsistency.
         - `SCHEDULED_FOR_DELETION` - Bucket is scheduled for deletion.
        It cannot be used in s3 api anymore.
        """
        return pulumi.get(self, "state")

    @state.setter
    def state(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "state", value)

    @property
    @pulumi.getter(name="suspensionState")
    def suspension_state(self) -> Optional[pulumi.Input[str]]:
        """
        ### Supported values

        Possible values:

         - `SUSPENSION_STATE_UNSPECIFIED`
         - `NOT_SUSPENDED`
         - `SUSPENDED`
        """
        return pulumi.get(self, "suspension_state")

    @suspension_state.setter
    def suspension_state(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "suspension_state", value)


if not MYPY:
    class StorageV1BucketStatusCounterArgsDict(TypedDict):
        counters: NotRequired[pulumi.Input['StorageV1BucketStatusCounterCountersArgsDict']]
        non_current_counters: NotRequired[pulumi.Input['StorageV1BucketStatusCounterNonCurrentCountersArgsDict']]
        """
        ### Inner value description

        Counters for non-current object versions (for versioning buckets).
        """
        storage_class: NotRequired[pulumi.Input[str]]
        """
        ### Supported values

        Possible values:

         - `STORAGE_CLASS_UNSPECIFIED`
         - `STANDARD`
        """
elif False:
    StorageV1BucketStatusCounterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class StorageV1BucketStatusCounterArgs:
    def __init__(__self__, *,
                 counters: Optional[pulumi.Input['StorageV1BucketStatusCounterCountersArgs']] = None,
                 non_current_counters: Optional[pulumi.Input['StorageV1BucketStatusCounterNonCurrentCountersArgs']] = None,
                 storage_class: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input['StorageV1BucketStatusCounterNonCurrentCountersArgs'] non_current_counters: ### Inner value description
               
               Counters for non-current object versions (for versioning buckets).
        :param pulumi.Input[str] storage_class: ### Supported values
               
               Possible values:
               
                - `STORAGE_CLASS_UNSPECIFIED`
                - `STANDARD`
        """
        if counters is not None:
            pulumi.set(__self__, "counters", counters)
        if non_current_counters is not None:
            pulumi.set(__self__, "non_current_counters", non_current_counters)
        if storage_class is not None:
            pulumi.set(__self__, "storage_class", storage_class)

    @property
    @pulumi.getter
    def counters(self) -> Optional[pulumi.Input['StorageV1BucketStatusCounterCountersArgs']]:
        return pulumi.get(self, "counters")

    @counters.setter
    def counters(self, value: Optional[pulumi.Input['StorageV1BucketStatusCounterCountersArgs']]):
        pulumi.set(self, "counters", value)

    @property
    @pulumi.getter(name="nonCurrentCounters")
    def non_current_counters(self) -> Optional[pulumi.Input['StorageV1BucketStatusCounterNonCurrentCountersArgs']]:
        """
        ### Inner value description

        Counters for non-current object versions (for versioning buckets).
        """
        return pulumi.get(self, "non_current_counters")

    @non_current_counters.setter
    def non_current_counters(self, value: Optional[pulumi.Input['StorageV1BucketStatusCounterNonCurrentCountersArgs']]):
        pulumi.set(self, "non_current_counters", value)

    @property
    @pulumi.getter(name="storageClass")
    def storage_class(self) -> Optional[pulumi.Input[str]]:
        """
        ### Supported values

        Possible values:

         - `STORAGE_CLASS_UNSPECIFIED`
         - `STANDARD`
        """
        return pulumi.get(self, "storage_class")

    @storage_class.setter
    def storage_class(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "storage_class", value)


if not MYPY:
    class StorageV1BucketStatusCounterCountersArgsDict(TypedDict):
        inflight_parts_quantity: NotRequired[pulumi.Input[float]]
        inflight_parts_size: NotRequired[pulumi.Input[float]]
        multipart_objects_quantity: NotRequired[pulumi.Input[float]]
        multipart_objects_size: NotRequired[pulumi.Input[float]]
        multipart_uploads_quantity: NotRequired[pulumi.Input[float]]
        simple_objects_quantity: NotRequired[pulumi.Input[float]]
        simple_objects_size: NotRequired[pulumi.Input[float]]
elif False:
    StorageV1BucketStatusCounterCountersArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class StorageV1BucketStatusCounterCountersArgs:
    def __init__(__self__, *,
                 inflight_parts_quantity: Optional[pulumi.Input[float]] = None,
                 inflight_parts_size: Optional[pulumi.Input[float]] = None,
                 multipart_objects_quantity: Optional[pulumi.Input[float]] = None,
                 multipart_objects_size: Optional[pulumi.Input[float]] = None,
                 multipart_uploads_quantity: Optional[pulumi.Input[float]] = None,
                 simple_objects_quantity: Optional[pulumi.Input[float]] = None,
                 simple_objects_size: Optional[pulumi.Input[float]] = None):
        if inflight_parts_quantity is not None:
            pulumi.set(__self__, "inflight_parts_quantity", inflight_parts_quantity)
        if inflight_parts_size is not None:
            pulumi.set(__self__, "inflight_parts_size", inflight_parts_size)
        if multipart_objects_quantity is not None:
            pulumi.set(__self__, "multipart_objects_quantity", multipart_objects_quantity)
        if multipart_objects_size is not None:
            pulumi.set(__self__, "multipart_objects_size", multipart_objects_size)
        if multipart_uploads_quantity is not None:
            pulumi.set(__self__, "multipart_uploads_quantity", multipart_uploads_quantity)
        if simple_objects_quantity is not None:
            pulumi.set(__self__, "simple_objects_quantity", simple_objects_quantity)
        if simple_objects_size is not None:
            pulumi.set(__self__, "simple_objects_size", simple_objects_size)

    @property
    @pulumi.getter(name="inflightPartsQuantity")
    def inflight_parts_quantity(self) -> Optional[pulumi.Input[float]]:
        return pulumi.get(self, "inflight_parts_quantity")

    @inflight_parts_quantity.setter
    def inflight_parts_quantity(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "inflight_parts_quantity", value)

    @property
    @pulumi.getter(name="inflightPartsSize")
    def inflight_parts_size(self) -> Optional[pulumi.Input[float]]:
        return pulumi.get(self, "inflight_parts_size")

    @inflight_parts_size.setter
    def inflight_parts_size(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "inflight_parts_size", value)

    @property
    @pulumi.getter(name="multipartObjectsQuantity")
    def multipart_objects_quantity(self) -> Optional[pulumi.Input[float]]:
        return pulumi.get(self, "multipart_objects_quantity")

    @multipart_objects_quantity.setter
    def multipart_objects_quantity(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "multipart_objects_quantity", value)

    @property
    @pulumi.getter(name="multipartObjectsSize")
    def multipart_objects_size(self) -> Optional[pulumi.Input[float]]:
        return pulumi.get(self, "multipart_objects_size")

    @multipart_objects_size.setter
    def multipart_objects_size(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "multipart_objects_size", value)

    @property
    @pulumi.getter(name="multipartUploadsQuantity")
    def multipart_uploads_quantity(self) -> Optional[pulumi.Input[float]]:
        return pulumi.get(self, "multipart_uploads_quantity")

    @multipart_uploads_quantity.setter
    def multipart_uploads_quantity(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "multipart_uploads_quantity", value)

    @property
    @pulumi.getter(name="simpleObjectsQuantity")
    def simple_objects_quantity(self) -> Optional[pulumi.Input[float]]:
        return pulumi.get(self, "simple_objects_quantity")

    @simple_objects_quantity.setter
    def simple_objects_quantity(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "simple_objects_quantity", value)

    @property
    @pulumi.getter(name="simpleObjectsSize")
    def simple_objects_size(self) -> Optional[pulumi.Input[float]]:
        return pulumi.get(self, "simple_objects_size")

    @simple_objects_size.setter
    def simple_objects_size(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "simple_objects_size", value)


if not MYPY:
    class StorageV1BucketStatusCounterNonCurrentCountersArgsDict(TypedDict):
        multipart_objects_quantity: NotRequired[pulumi.Input[float]]
        multipart_objects_size: NotRequired[pulumi.Input[float]]
        simple_objects_quantity: NotRequired[pulumi.Input[float]]
        simple_objects_size: NotRequired[pulumi.Input[float]]
elif False:
    StorageV1BucketStatusCounterNonCurrentCountersArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class StorageV1BucketStatusCounterNonCurrentCountersArgs:
    def __init__(__self__, *,
                 multipart_objects_quantity: Optional[pulumi.Input[float]] = None,
                 multipart_objects_size: Optional[pulumi.Input[float]] = None,
                 simple_objects_quantity: Optional[pulumi.Input[float]] = None,
                 simple_objects_size: Optional[pulumi.Input[float]] = None):
        if multipart_objects_quantity is not None:
            pulumi.set(__self__, "multipart_objects_quantity", multipart_objects_quantity)
        if multipart_objects_size is not None:
            pulumi.set(__self__, "multipart_objects_size", multipart_objects_size)
        if simple_objects_quantity is not None:
            pulumi.set(__self__, "simple_objects_quantity", simple_objects_quantity)
        if simple_objects_size is not None:
            pulumi.set(__self__, "simple_objects_size", simple_objects_size)

    @property
    @pulumi.getter(name="multipartObjectsQuantity")
    def multipart_objects_quantity(self) -> Optional[pulumi.Input[float]]:
        return pulumi.get(self, "multipart_objects_quantity")

    @multipart_objects_quantity.setter
    def multipart_objects_quantity(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "multipart_objects_quantity", value)

    @property
    @pulumi.getter(name="multipartObjectsSize")
    def multipart_objects_size(self) -> Optional[pulumi.Input[float]]:
        return pulumi.get(self, "multipart_objects_size")

    @multipart_objects_size.setter
    def multipart_objects_size(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "multipart_objects_size", value)

    @property
    @pulumi.getter(name="simpleObjectsQuantity")
    def simple_objects_quantity(self) -> Optional[pulumi.Input[float]]:
        return pulumi.get(self, "simple_objects_quantity")

    @simple_objects_quantity.setter
    def simple_objects_quantity(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "simple_objects_quantity", value)

    @property
    @pulumi.getter(name="simpleObjectsSize")
    def simple_objects_size(self) -> Optional[pulumi.Input[float]]:
        return pulumi.get(self, "simple_objects_size")

    @simple_objects_size.setter
    def simple_objects_size(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "simple_objects_size", value)


if not MYPY:
    class VpcV1AllocationIpv4PrivateArgsDict(TypedDict):
        cidr: NotRequired[pulumi.Input[str]]
        """
        CIDR block for IPv4 Allocation.
        May be a single IP address (such as 10.2.3.4),
        a prefix length (such as /24) or a CIDR-formatted string (such as 10.1.2.0/24).
        Random address (/32) from pool would be allocated if field is omitted.
        """
        pool_id: NotRequired[pulumi.Input[str]]
        """
        Pool for the IPv4 private allocation.

        *Cannot be set alongside subnet_id.*
        """
        subnet_id: NotRequired[pulumi.Input[str]]
        """
        Subnet ID.
        Required same subnet to use allocation in subnet-resources (e.g. Network Interface)

        *Cannot be set alongside pool_id.*
        """
elif False:
    VpcV1AllocationIpv4PrivateArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VpcV1AllocationIpv4PrivateArgs:
    def __init__(__self__, *,
                 cidr: Optional[pulumi.Input[str]] = None,
                 pool_id: Optional[pulumi.Input[str]] = None,
                 subnet_id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] cidr: CIDR block for IPv4 Allocation.
               May be a single IP address (such as 10.2.3.4),
               a prefix length (such as /24) or a CIDR-formatted string (such as 10.1.2.0/24).
               Random address (/32) from pool would be allocated if field is omitted.
        :param pulumi.Input[str] pool_id: Pool for the IPv4 private allocation.
               
               *Cannot be set alongside subnet_id.*
        :param pulumi.Input[str] subnet_id: Subnet ID.
               Required same subnet to use allocation in subnet-resources (e.g. Network Interface)
               
               *Cannot be set alongside pool_id.*
        """
        if cidr is not None:
            pulumi.set(__self__, "cidr", cidr)
        if pool_id is not None:
            pulumi.set(__self__, "pool_id", pool_id)
        if subnet_id is not None:
            pulumi.set(__self__, "subnet_id", subnet_id)

    @property
    @pulumi.getter
    def cidr(self) -> Optional[pulumi.Input[str]]:
        """
        CIDR block for IPv4 Allocation.
        May be a single IP address (such as 10.2.3.4),
        a prefix length (such as /24) or a CIDR-formatted string (such as 10.1.2.0/24).
        Random address (/32) from pool would be allocated if field is omitted.
        """
        return pulumi.get(self, "cidr")

    @cidr.setter
    def cidr(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "cidr", value)

    @property
    @pulumi.getter(name="poolId")
    def pool_id(self) -> Optional[pulumi.Input[str]]:
        """
        Pool for the IPv4 private allocation.

        *Cannot be set alongside subnet_id.*
        """
        return pulumi.get(self, "pool_id")

    @pool_id.setter
    def pool_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "pool_id", value)

    @property
    @pulumi.getter(name="subnetId")
    def subnet_id(self) -> Optional[pulumi.Input[str]]:
        """
        Subnet ID.
        Required same subnet to use allocation in subnet-resources (e.g. Network Interface)

        *Cannot be set alongside pool_id.*
        """
        return pulumi.get(self, "subnet_id")

    @subnet_id.setter
    def subnet_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "subnet_id", value)


if not MYPY:
    class VpcV1AllocationIpv4PublicArgsDict(TypedDict):
        cidr: NotRequired[pulumi.Input[str]]
        """
        CIDR block for IPv4 Allocation.
        May be a single IP address (such as 10.2.3.4),
        a prefix length (such as /32) or a CIDR-formatted string (such as 10.1.2.0/32).
        Random address (/32) from pool would be allocated if field is omitted.
        """
        pool_id: NotRequired[pulumi.Input[str]]
        """
        Pool for the IPv4 public allocation.

        *Cannot be set alongside subnet_id.*
        """
        subnet_id: NotRequired[pulumi.Input[str]]
        """
        Subnet ID.
        Required same subnet to use allocation in subnet-resources (e.g. Network Interface)

        *Cannot be set alongside pool_id.*
        """
elif False:
    VpcV1AllocationIpv4PublicArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VpcV1AllocationIpv4PublicArgs:
    def __init__(__self__, *,
                 cidr: Optional[pulumi.Input[str]] = None,
                 pool_id: Optional[pulumi.Input[str]] = None,
                 subnet_id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] cidr: CIDR block for IPv4 Allocation.
               May be a single IP address (such as 10.2.3.4),
               a prefix length (such as /32) or a CIDR-formatted string (such as 10.1.2.0/32).
               Random address (/32) from pool would be allocated if field is omitted.
        :param pulumi.Input[str] pool_id: Pool for the IPv4 public allocation.
               
               *Cannot be set alongside subnet_id.*
        :param pulumi.Input[str] subnet_id: Subnet ID.
               Required same subnet to use allocation in subnet-resources (e.g. Network Interface)
               
               *Cannot be set alongside pool_id.*
        """
        if cidr is not None:
            pulumi.set(__self__, "cidr", cidr)
        if pool_id is not None:
            pulumi.set(__self__, "pool_id", pool_id)
        if subnet_id is not None:
            pulumi.set(__self__, "subnet_id", subnet_id)

    @property
    @pulumi.getter
    def cidr(self) -> Optional[pulumi.Input[str]]:
        """
        CIDR block for IPv4 Allocation.
        May be a single IP address (such as 10.2.3.4),
        a prefix length (such as /32) or a CIDR-formatted string (such as 10.1.2.0/32).
        Random address (/32) from pool would be allocated if field is omitted.
        """
        return pulumi.get(self, "cidr")

    @cidr.setter
    def cidr(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "cidr", value)

    @property
    @pulumi.getter(name="poolId")
    def pool_id(self) -> Optional[pulumi.Input[str]]:
        """
        Pool for the IPv4 public allocation.

        *Cannot be set alongside subnet_id.*
        """
        return pulumi.get(self, "pool_id")

    @pool_id.setter
    def pool_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "pool_id", value)

    @property
    @pulumi.getter(name="subnetId")
    def subnet_id(self) -> Optional[pulumi.Input[str]]:
        """
        Subnet ID.
        Required same subnet to use allocation in subnet-resources (e.g. Network Interface)

        *Cannot be set alongside pool_id.*
        """
        return pulumi.get(self, "subnet_id")

    @subnet_id.setter
    def subnet_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "subnet_id", value)


if not MYPY:
    class VpcV1AllocationMetadataArgsDict(TypedDict):
        pass
elif False:
    VpcV1AllocationMetadataArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VpcV1AllocationMetadataArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class VpcV1AllocationStatusArgsDict(TypedDict):
        assignment: NotRequired[pulumi.Input['VpcV1AllocationStatusAssignmentArgsDict']]
        """
        Information about the assignment associated with the allocation,
        such as network interface or load balancer assignment.
        """
        details: NotRequired[pulumi.Input['VpcV1AllocationStatusDetailsArgsDict']]
        """
        Detailed information about the allocation status,
        including the allocated CIDR, pool ID and IP version.
        """
        state: NotRequired[pulumi.Input[str]]
        """
        This field represents the current state of the allocation.

        ### Supported values

        Enumeration of possible states of the Allocation.
        Possible values:

         - `STATE_UNSPECIFIED` - Default state, unspecified.
         - `CREATING` - Allocation is being created.
         - `ALLOCATED` - Allocation is ready for use.
         - `ASSIGNED` - Allocation is used.
         - `DELETING` - Allocation is being deleted.
        """
        static: NotRequired[pulumi.Input[bool]]
        """
        If false - Lifecycle of allocation depends on resource that using it.
        """
elif False:
    VpcV1AllocationStatusArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VpcV1AllocationStatusArgs:
    def __init__(__self__, *,
                 assignment: Optional[pulumi.Input['VpcV1AllocationStatusAssignmentArgs']] = None,
                 details: Optional[pulumi.Input['VpcV1AllocationStatusDetailsArgs']] = None,
                 state: Optional[pulumi.Input[str]] = None,
                 static: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input['VpcV1AllocationStatusAssignmentArgs'] assignment: Information about the assignment associated with the allocation,
               such as network interface or load balancer assignment.
        :param pulumi.Input['VpcV1AllocationStatusDetailsArgs'] details: Detailed information about the allocation status,
               including the allocated CIDR, pool ID and IP version.
        :param pulumi.Input[str] state: This field represents the current state of the allocation.
               
               ### Supported values
               
               Enumeration of possible states of the Allocation.
               Possible values:
               
                - `STATE_UNSPECIFIED` - Default state, unspecified.
                - `CREATING` - Allocation is being created.
                - `ALLOCATED` - Allocation is ready for use.
                - `ASSIGNED` - Allocation is used.
                - `DELETING` - Allocation is being deleted.
        :param pulumi.Input[bool] static: If false - Lifecycle of allocation depends on resource that using it.
        """
        if assignment is not None:
            pulumi.set(__self__, "assignment", assignment)
        if details is not None:
            pulumi.set(__self__, "details", details)
        if state is not None:
            pulumi.set(__self__, "state", state)
        if static is not None:
            pulumi.set(__self__, "static", static)

    @property
    @pulumi.getter
    def assignment(self) -> Optional[pulumi.Input['VpcV1AllocationStatusAssignmentArgs']]:
        """
        Information about the assignment associated with the allocation,
        such as network interface or load balancer assignment.
        """
        return pulumi.get(self, "assignment")

    @assignment.setter
    def assignment(self, value: Optional[pulumi.Input['VpcV1AllocationStatusAssignmentArgs']]):
        pulumi.set(self, "assignment", value)

    @property
    @pulumi.getter
    def details(self) -> Optional[pulumi.Input['VpcV1AllocationStatusDetailsArgs']]:
        """
        Detailed information about the allocation status,
        including the allocated CIDR, pool ID and IP version.
        """
        return pulumi.get(self, "details")

    @details.setter
    def details(self, value: Optional[pulumi.Input['VpcV1AllocationStatusDetailsArgs']]):
        pulumi.set(self, "details", value)

    @property
    @pulumi.getter
    def state(self) -> Optional[pulumi.Input[str]]:
        """
        This field represents the current state of the allocation.

        ### Supported values

        Enumeration of possible states of the Allocation.
        Possible values:

         - `STATE_UNSPECIFIED` - Default state, unspecified.
         - `CREATING` - Allocation is being created.
         - `ALLOCATED` - Allocation is ready for use.
         - `ASSIGNED` - Allocation is used.
         - `DELETING` - Allocation is being deleted.
        """
        return pulumi.get(self, "state")

    @state.setter
    def state(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "state", value)

    @property
    @pulumi.getter
    def static(self) -> Optional[pulumi.Input[bool]]:
        """
        If false - Lifecycle of allocation depends on resource that using it.
        """
        return pulumi.get(self, "static")

    @static.setter
    def static(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "static", value)


if not MYPY:
    class VpcV1AllocationStatusAssignmentArgsDict(TypedDict):
        load_balancer: NotRequired[pulumi.Input['VpcV1AllocationStatusAssignmentLoadBalancerArgsDict']]
        """
        *Cannot be set alongside network_interface.*
        """
        network_interface: NotRequired[pulumi.Input['VpcV1AllocationStatusAssignmentNetworkInterfaceArgsDict']]
        """
        *Cannot be set alongside load_balancer.*
        """
elif False:
    VpcV1AllocationStatusAssignmentArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VpcV1AllocationStatusAssignmentArgs:
    def __init__(__self__, *,
                 load_balancer: Optional[pulumi.Input['VpcV1AllocationStatusAssignmentLoadBalancerArgs']] = None,
                 network_interface: Optional[pulumi.Input['VpcV1AllocationStatusAssignmentNetworkInterfaceArgs']] = None):
        """
        :param pulumi.Input['VpcV1AllocationStatusAssignmentLoadBalancerArgs'] load_balancer: *Cannot be set alongside network_interface.*
        :param pulumi.Input['VpcV1AllocationStatusAssignmentNetworkInterfaceArgs'] network_interface: *Cannot be set alongside load_balancer.*
        """
        if load_balancer is not None:
            pulumi.set(__self__, "load_balancer", load_balancer)
        if network_interface is not None:
            pulumi.set(__self__, "network_interface", network_interface)

    @property
    @pulumi.getter(name="loadBalancer")
    def load_balancer(self) -> Optional[pulumi.Input['VpcV1AllocationStatusAssignmentLoadBalancerArgs']]:
        """
        *Cannot be set alongside network_interface.*
        """
        return pulumi.get(self, "load_balancer")

    @load_balancer.setter
    def load_balancer(self, value: Optional[pulumi.Input['VpcV1AllocationStatusAssignmentLoadBalancerArgs']]):
        pulumi.set(self, "load_balancer", value)

    @property
    @pulumi.getter(name="networkInterface")
    def network_interface(self) -> Optional[pulumi.Input['VpcV1AllocationStatusAssignmentNetworkInterfaceArgs']]:
        """
        *Cannot be set alongside load_balancer.*
        """
        return pulumi.get(self, "network_interface")

    @network_interface.setter
    def network_interface(self, value: Optional[pulumi.Input['VpcV1AllocationStatusAssignmentNetworkInterfaceArgs']]):
        pulumi.set(self, "network_interface", value)


if not MYPY:
    class VpcV1AllocationStatusAssignmentLoadBalancerArgsDict(TypedDict):
        id: NotRequired[pulumi.Input[str]]
        """
        ID of the Load Balancer.
        """
elif False:
    VpcV1AllocationStatusAssignmentLoadBalancerArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VpcV1AllocationStatusAssignmentLoadBalancerArgs:
    def __init__(__self__, *,
                 id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] id: ID of the Load Balancer.
        """
        if id is not None:
            pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[str]]:
        """
        ID of the Load Balancer.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "id", value)


if not MYPY:
    class VpcV1AllocationStatusAssignmentNetworkInterfaceArgsDict(TypedDict):
        instance_id: NotRequired[pulumi.Input[str]]
        """
        ID of the Compute instance network interface belongs to.
        """
        name: NotRequired[pulumi.Input[str]]
        """
        Network interface name
        """
elif False:
    VpcV1AllocationStatusAssignmentNetworkInterfaceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VpcV1AllocationStatusAssignmentNetworkInterfaceArgs:
    def __init__(__self__, *,
                 instance_id: Optional[pulumi.Input[str]] = None,
                 name: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] instance_id: ID of the Compute instance network interface belongs to.
        :param pulumi.Input[str] name: Network interface name
        """
        if instance_id is not None:
            pulumi.set(__self__, "instance_id", instance_id)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter(name="instanceId")
    def instance_id(self) -> Optional[pulumi.Input[str]]:
        """
        ID of the Compute instance network interface belongs to.
        """
        return pulumi.get(self, "instance_id")

    @instance_id.setter
    def instance_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "instance_id", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        Network interface name
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)


if not MYPY:
    class VpcV1AllocationStatusDetailsArgsDict(TypedDict):
        allocated_cidr: NotRequired[pulumi.Input[str]]
        pool_id: NotRequired[pulumi.Input[str]]
        version: NotRequired[pulumi.Input[str]]
        """
        ### Supported values

        Possible values:

         - `IP_VERSION_UNSPECIFIED` - Default, unspecified IP version.
         - `IPV4` - IPv4 address.
         - `IPV6` - IPv6 address.
        """
elif False:
    VpcV1AllocationStatusDetailsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VpcV1AllocationStatusDetailsArgs:
    def __init__(__self__, *,
                 allocated_cidr: Optional[pulumi.Input[str]] = None,
                 pool_id: Optional[pulumi.Input[str]] = None,
                 version: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] version: ### Supported values
               
               Possible values:
               
                - `IP_VERSION_UNSPECIFIED` - Default, unspecified IP version.
                - `IPV4` - IPv4 address.
                - `IPV6` - IPv6 address.
        """
        if allocated_cidr is not None:
            pulumi.set(__self__, "allocated_cidr", allocated_cidr)
        if pool_id is not None:
            pulumi.set(__self__, "pool_id", pool_id)
        if version is not None:
            pulumi.set(__self__, "version", version)

    @property
    @pulumi.getter(name="allocatedCidr")
    def allocated_cidr(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "allocated_cidr")

    @allocated_cidr.setter
    def allocated_cidr(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "allocated_cidr", value)

    @property
    @pulumi.getter(name="poolId")
    def pool_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "pool_id")

    @pool_id.setter
    def pool_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "pool_id", value)

    @property
    @pulumi.getter
    def version(self) -> Optional[pulumi.Input[str]]:
        """
        ### Supported values

        Possible values:

         - `IP_VERSION_UNSPECIFIED` - Default, unspecified IP version.
         - `IPV4` - IPv4 address.
         - `IPV6` - IPv6 address.
        """
        return pulumi.get(self, "version")

    @version.setter
    def version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "version", value)


if not MYPY:
    class VpcV1alpha1AllocationIpv4PrivateArgsDict(TypedDict):
        cidr: NotRequired[pulumi.Input[str]]
        """
        CIDR block for IPv4 Allocation.
        May be a single IP address (such as 10.2.3.4),
        a prefix length (such as /24) or a CIDR-formatted string (such as 10.1.2.0/24).
        Random address (/32) from pool would be allocated if field is omitted.
        """
        pool_id: NotRequired[pulumi.Input[str]]
        """
        Pool for the IPv4 private allocation.

        *Cannot be set alongside subnet_id.*
        """
        subnet_id: NotRequired[pulumi.Input[str]]
        """
        Subnet ID.
        Required same subnet to use allocation in subnet-resources (e.g. Network Interface)

        *Cannot be set alongside pool_id.*
        """
elif False:
    VpcV1alpha1AllocationIpv4PrivateArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VpcV1alpha1AllocationIpv4PrivateArgs:
    def __init__(__self__, *,
                 cidr: Optional[pulumi.Input[str]] = None,
                 pool_id: Optional[pulumi.Input[str]] = None,
                 subnet_id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] cidr: CIDR block for IPv4 Allocation.
               May be a single IP address (such as 10.2.3.4),
               a prefix length (such as /24) or a CIDR-formatted string (such as 10.1.2.0/24).
               Random address (/32) from pool would be allocated if field is omitted.
        :param pulumi.Input[str] pool_id: Pool for the IPv4 private allocation.
               
               *Cannot be set alongside subnet_id.*
        :param pulumi.Input[str] subnet_id: Subnet ID.
               Required same subnet to use allocation in subnet-resources (e.g. Network Interface)
               
               *Cannot be set alongside pool_id.*
        """
        if cidr is not None:
            pulumi.set(__self__, "cidr", cidr)
        if pool_id is not None:
            pulumi.set(__self__, "pool_id", pool_id)
        if subnet_id is not None:
            pulumi.set(__self__, "subnet_id", subnet_id)

    @property
    @pulumi.getter
    def cidr(self) -> Optional[pulumi.Input[str]]:
        """
        CIDR block for IPv4 Allocation.
        May be a single IP address (such as 10.2.3.4),
        a prefix length (such as /24) or a CIDR-formatted string (such as 10.1.2.0/24).
        Random address (/32) from pool would be allocated if field is omitted.
        """
        return pulumi.get(self, "cidr")

    @cidr.setter
    def cidr(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "cidr", value)

    @property
    @pulumi.getter(name="poolId")
    def pool_id(self) -> Optional[pulumi.Input[str]]:
        """
        Pool for the IPv4 private allocation.

        *Cannot be set alongside subnet_id.*
        """
        return pulumi.get(self, "pool_id")

    @pool_id.setter
    def pool_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "pool_id", value)

    @property
    @pulumi.getter(name="subnetId")
    def subnet_id(self) -> Optional[pulumi.Input[str]]:
        """
        Subnet ID.
        Required same subnet to use allocation in subnet-resources (e.g. Network Interface)

        *Cannot be set alongside pool_id.*
        """
        return pulumi.get(self, "subnet_id")

    @subnet_id.setter
    def subnet_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "subnet_id", value)


if not MYPY:
    class VpcV1alpha1AllocationIpv4PublicArgsDict(TypedDict):
        cidr: NotRequired[pulumi.Input[str]]
        """
        CIDR block for IPv4 Allocation.
        May be a single IP address (such as 10.2.3.4),
        a prefix length (such as /32) or a CIDR-formatted string (such as 10.1.2.0/32).
        Random address (/32) from pool would be allocated if field is omitted.
        """
        pool_id: NotRequired[pulumi.Input[str]]
        """
        Pool for the IPv4 public allocation.
        """
elif False:
    VpcV1alpha1AllocationIpv4PublicArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VpcV1alpha1AllocationIpv4PublicArgs:
    def __init__(__self__, *,
                 cidr: Optional[pulumi.Input[str]] = None,
                 pool_id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] cidr: CIDR block for IPv4 Allocation.
               May be a single IP address (such as 10.2.3.4),
               a prefix length (such as /32) or a CIDR-formatted string (such as 10.1.2.0/32).
               Random address (/32) from pool would be allocated if field is omitted.
        :param pulumi.Input[str] pool_id: Pool for the IPv4 public allocation.
        """
        if cidr is not None:
            pulumi.set(__self__, "cidr", cidr)
        if pool_id is not None:
            pulumi.set(__self__, "pool_id", pool_id)

    @property
    @pulumi.getter
    def cidr(self) -> Optional[pulumi.Input[str]]:
        """
        CIDR block for IPv4 Allocation.
        May be a single IP address (such as 10.2.3.4),
        a prefix length (such as /32) or a CIDR-formatted string (such as 10.1.2.0/32).
        Random address (/32) from pool would be allocated if field is omitted.
        """
        return pulumi.get(self, "cidr")

    @cidr.setter
    def cidr(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "cidr", value)

    @property
    @pulumi.getter(name="poolId")
    def pool_id(self) -> Optional[pulumi.Input[str]]:
        """
        Pool for the IPv4 public allocation.
        """
        return pulumi.get(self, "pool_id")

    @pool_id.setter
    def pool_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "pool_id", value)


if not MYPY:
    class VpcV1alpha1AllocationMetadataArgsDict(TypedDict):
        pass
elif False:
    VpcV1alpha1AllocationMetadataArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VpcV1alpha1AllocationMetadataArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class VpcV1alpha1AllocationStatusArgsDict(TypedDict):
        assignment: NotRequired[pulumi.Input['VpcV1alpha1AllocationStatusAssignmentArgsDict']]
        """
        Information about the assignment associated with the allocation,
        such as network interface or load balancer assignment.
        """
        details: NotRequired[pulumi.Input['VpcV1alpha1AllocationStatusDetailsArgsDict']]
        """
        Detailed information about the allocation status,
        including the allocated CIDR, pool ID, scope type, and IP version.
        """
        state: NotRequired[pulumi.Input[str]]
        """
        This field represents the current state of the allocation.

        ### Supported values

        Enumeration of possible states of the Allocation.
        Possible values:

         - `STATE_UNSPECIFIED` - Default state, unspecified.
         - `CREATING` - Allocation is being created.
         - `ALLOCATED` - Allocation is ready for use.
         - `ASSIGNED` - Allocation is used.
         - `DELETING` - Allocation is being deleted.
        """
        static: NotRequired[pulumi.Input[bool]]
        """
        If false - Lifecycle of allocation depends on resource that using it.
        """
elif False:
    VpcV1alpha1AllocationStatusArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VpcV1alpha1AllocationStatusArgs:
    def __init__(__self__, *,
                 assignment: Optional[pulumi.Input['VpcV1alpha1AllocationStatusAssignmentArgs']] = None,
                 details: Optional[pulumi.Input['VpcV1alpha1AllocationStatusDetailsArgs']] = None,
                 state: Optional[pulumi.Input[str]] = None,
                 static: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input['VpcV1alpha1AllocationStatusAssignmentArgs'] assignment: Information about the assignment associated with the allocation,
               such as network interface or load balancer assignment.
        :param pulumi.Input['VpcV1alpha1AllocationStatusDetailsArgs'] details: Detailed information about the allocation status,
               including the allocated CIDR, pool ID, scope type, and IP version.
        :param pulumi.Input[str] state: This field represents the current state of the allocation.
               
               ### Supported values
               
               Enumeration of possible states of the Allocation.
               Possible values:
               
                - `STATE_UNSPECIFIED` - Default state, unspecified.
                - `CREATING` - Allocation is being created.
                - `ALLOCATED` - Allocation is ready for use.
                - `ASSIGNED` - Allocation is used.
                - `DELETING` - Allocation is being deleted.
        :param pulumi.Input[bool] static: If false - Lifecycle of allocation depends on resource that using it.
        """
        if assignment is not None:
            pulumi.set(__self__, "assignment", assignment)
        if details is not None:
            pulumi.set(__self__, "details", details)
        if state is not None:
            pulumi.set(__self__, "state", state)
        if static is not None:
            pulumi.set(__self__, "static", static)

    @property
    @pulumi.getter
    def assignment(self) -> Optional[pulumi.Input['VpcV1alpha1AllocationStatusAssignmentArgs']]:
        """
        Information about the assignment associated with the allocation,
        such as network interface or load balancer assignment.
        """
        return pulumi.get(self, "assignment")

    @assignment.setter
    def assignment(self, value: Optional[pulumi.Input['VpcV1alpha1AllocationStatusAssignmentArgs']]):
        pulumi.set(self, "assignment", value)

    @property
    @pulumi.getter
    def details(self) -> Optional[pulumi.Input['VpcV1alpha1AllocationStatusDetailsArgs']]:
        """
        Detailed information about the allocation status,
        including the allocated CIDR, pool ID, scope type, and IP version.
        """
        return pulumi.get(self, "details")

    @details.setter
    def details(self, value: Optional[pulumi.Input['VpcV1alpha1AllocationStatusDetailsArgs']]):
        pulumi.set(self, "details", value)

    @property
    @pulumi.getter
    def state(self) -> Optional[pulumi.Input[str]]:
        """
        This field represents the current state of the allocation.

        ### Supported values

        Enumeration of possible states of the Allocation.
        Possible values:

         - `STATE_UNSPECIFIED` - Default state, unspecified.
         - `CREATING` - Allocation is being created.
         - `ALLOCATED` - Allocation is ready for use.
         - `ASSIGNED` - Allocation is used.
         - `DELETING` - Allocation is being deleted.
        """
        return pulumi.get(self, "state")

    @state.setter
    def state(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "state", value)

    @property
    @pulumi.getter
    def static(self) -> Optional[pulumi.Input[bool]]:
        """
        If false - Lifecycle of allocation depends on resource that using it.
        """
        return pulumi.get(self, "static")

    @static.setter
    def static(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "static", value)


if not MYPY:
    class VpcV1alpha1AllocationStatusAssignmentArgsDict(TypedDict):
        load_balancer: NotRequired[pulumi.Input['VpcV1alpha1AllocationStatusAssignmentLoadBalancerArgsDict']]
        """
        *Cannot be set alongside network_interface.*
        """
        network_interface: NotRequired[pulumi.Input['VpcV1alpha1AllocationStatusAssignmentNetworkInterfaceArgsDict']]
        """
        *Cannot be set alongside load_balancer.*
        """
elif False:
    VpcV1alpha1AllocationStatusAssignmentArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VpcV1alpha1AllocationStatusAssignmentArgs:
    def __init__(__self__, *,
                 load_balancer: Optional[pulumi.Input['VpcV1alpha1AllocationStatusAssignmentLoadBalancerArgs']] = None,
                 network_interface: Optional[pulumi.Input['VpcV1alpha1AllocationStatusAssignmentNetworkInterfaceArgs']] = None):
        """
        :param pulumi.Input['VpcV1alpha1AllocationStatusAssignmentLoadBalancerArgs'] load_balancer: *Cannot be set alongside network_interface.*
        :param pulumi.Input['VpcV1alpha1AllocationStatusAssignmentNetworkInterfaceArgs'] network_interface: *Cannot be set alongside load_balancer.*
        """
        if load_balancer is not None:
            pulumi.set(__self__, "load_balancer", load_balancer)
        if network_interface is not None:
            pulumi.set(__self__, "network_interface", network_interface)

    @property
    @pulumi.getter(name="loadBalancer")
    def load_balancer(self) -> Optional[pulumi.Input['VpcV1alpha1AllocationStatusAssignmentLoadBalancerArgs']]:
        """
        *Cannot be set alongside network_interface.*
        """
        return pulumi.get(self, "load_balancer")

    @load_balancer.setter
    def load_balancer(self, value: Optional[pulumi.Input['VpcV1alpha1AllocationStatusAssignmentLoadBalancerArgs']]):
        pulumi.set(self, "load_balancer", value)

    @property
    @pulumi.getter(name="networkInterface")
    def network_interface(self) -> Optional[pulumi.Input['VpcV1alpha1AllocationStatusAssignmentNetworkInterfaceArgs']]:
        """
        *Cannot be set alongside load_balancer.*
        """
        return pulumi.get(self, "network_interface")

    @network_interface.setter
    def network_interface(self, value: Optional[pulumi.Input['VpcV1alpha1AllocationStatusAssignmentNetworkInterfaceArgs']]):
        pulumi.set(self, "network_interface", value)


if not MYPY:
    class VpcV1alpha1AllocationStatusAssignmentLoadBalancerArgsDict(TypedDict):
        id: NotRequired[pulumi.Input[str]]
        """
        ID of the Load Balancer.
        """
elif False:
    VpcV1alpha1AllocationStatusAssignmentLoadBalancerArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VpcV1alpha1AllocationStatusAssignmentLoadBalancerArgs:
    def __init__(__self__, *,
                 id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] id: ID of the Load Balancer.
        """
        if id is not None:
            pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[str]]:
        """
        ID of the Load Balancer.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "id", value)


if not MYPY:
    class VpcV1alpha1AllocationStatusAssignmentNetworkInterfaceArgsDict(TypedDict):
        instance_id: NotRequired[pulumi.Input[str]]
        """
        ID of the Compute instance network interface belongs to.
        """
        name: NotRequired[pulumi.Input[str]]
        """
        Network interface name
        """
elif False:
    VpcV1alpha1AllocationStatusAssignmentNetworkInterfaceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VpcV1alpha1AllocationStatusAssignmentNetworkInterfaceArgs:
    def __init__(__self__, *,
                 instance_id: Optional[pulumi.Input[str]] = None,
                 name: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] instance_id: ID of the Compute instance network interface belongs to.
        :param pulumi.Input[str] name: Network interface name
        """
        if instance_id is not None:
            pulumi.set(__self__, "instance_id", instance_id)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter(name="instanceId")
    def instance_id(self) -> Optional[pulumi.Input[str]]:
        """
        ID of the Compute instance network interface belongs to.
        """
        return pulumi.get(self, "instance_id")

    @instance_id.setter
    def instance_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "instance_id", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        Network interface name
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)


if not MYPY:
    class VpcV1alpha1AllocationStatusDetailsArgsDict(TypedDict):
        allocated_cidr: NotRequired[pulumi.Input[str]]
        pool_id: NotRequired[pulumi.Input[str]]
        version: NotRequired[pulumi.Input[str]]
        """
        ### Supported values

        Possible values:

         - `IP_VERSION_UNSPECIFIED` - Default, unspecified IP version.
         - `IPV4` - IPv4 address.
         - `IPV6` - IPv6 address.
        """
elif False:
    VpcV1alpha1AllocationStatusDetailsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VpcV1alpha1AllocationStatusDetailsArgs:
    def __init__(__self__, *,
                 allocated_cidr: Optional[pulumi.Input[str]] = None,
                 pool_id: Optional[pulumi.Input[str]] = None,
                 version: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] version: ### Supported values
               
               Possible values:
               
                - `IP_VERSION_UNSPECIFIED` - Default, unspecified IP version.
                - `IPV4` - IPv4 address.
                - `IPV6` - IPv6 address.
        """
        if allocated_cidr is not None:
            pulumi.set(__self__, "allocated_cidr", allocated_cidr)
        if pool_id is not None:
            pulumi.set(__self__, "pool_id", pool_id)
        if version is not None:
            pulumi.set(__self__, "version", version)

    @property
    @pulumi.getter(name="allocatedCidr")
    def allocated_cidr(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "allocated_cidr")

    @allocated_cidr.setter
    def allocated_cidr(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "allocated_cidr", value)

    @property
    @pulumi.getter(name="poolId")
    def pool_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "pool_id")

    @pool_id.setter
    def pool_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "pool_id", value)

    @property
    @pulumi.getter
    def version(self) -> Optional[pulumi.Input[str]]:
        """
        ### Supported values

        Possible values:

         - `IP_VERSION_UNSPECIFIED` - Default, unspecified IP version.
         - `IPV4` - IPv4 address.
         - `IPV6` - IPv6 address.
        """
        return pulumi.get(self, "version")

    @version.setter
    def version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "version", value)


if not MYPY:
    class GetApplicationsV1alpha1K8sReleaseMetadataArgsDict(TypedDict):
        pass
elif False:
    GetApplicationsV1alpha1K8sReleaseMetadataArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetApplicationsV1alpha1K8sReleaseMetadataArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class GetIamV1AuthPublicKeyMetadataArgsDict(TypedDict):
        pass
elif False:
    GetIamV1AuthPublicKeyMetadataArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetIamV1AuthPublicKeyMetadataArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class GetIamV1FederationCertificateMetadataArgsDict(TypedDict):
        pass
elif False:
    GetIamV1FederationCertificateMetadataArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetIamV1FederationCertificateMetadataArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class GetIamV1FederationMetadataArgsDict(TypedDict):
        pass
elif False:
    GetIamV1FederationMetadataArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetIamV1FederationMetadataArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class GetIamV1GroupMembershipMetadataArgsDict(TypedDict):
        pass
elif False:
    GetIamV1GroupMembershipMetadataArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetIamV1GroupMembershipMetadataArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class GetIamV1InvitationMetadataArgsDict(TypedDict):
        pass
elif False:
    GetIamV1InvitationMetadataArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetIamV1InvitationMetadataArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class GetIamV1TenantMetadataArgsDict(TypedDict):
        pass
elif False:
    GetIamV1TenantMetadataArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetIamV1TenantMetadataArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class GetIamV1TenantUserAccountMetadataArgsDict(TypedDict):
        pass
elif False:
    GetIamV1TenantUserAccountMetadataArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetIamV1TenantUserAccountMetadataArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class GetRegistryV1RegistryMetadataArgsDict(TypedDict):
        pass
elif False:
    GetRegistryV1RegistryMetadataArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetRegistryV1RegistryMetadataArgs:
    def __init__(__self__):
        pass


