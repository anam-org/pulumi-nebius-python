# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import builtins
import copy
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from . import _utilities
from . import outputs

__all__ = [
    'ApplicationsV1alpha1K8sReleaseMetadata',
    'ApplicationsV1alpha1K8sReleaseStatus',
    'ComputeV1DiskMetadata',
    'ComputeV1DiskPlacementPolicy',
    'ComputeV1DiskSourceImageFamily',
    'ComputeV1DiskStatus',
    'ComputeV1FilesystemMetadata',
    'ComputeV1FilesystemStatus',
    'ComputeV1GpuClusterMetadata',
    'ComputeV1GpuClusterStatus',
    'ComputeV1GpuClusterStatusInfinibandTopologyPath',
    'ComputeV1GpuClusterStatusInfinibandTopologyPathInstance',
    'ComputeV1InstanceBootDisk',
    'ComputeV1InstanceBootDiskExistingDisk',
    'ComputeV1InstanceFilesystem',
    'ComputeV1InstanceFilesystemExistingFilesystem',
    'ComputeV1InstanceGpuCluster',
    'ComputeV1InstanceMetadata',
    'ComputeV1InstanceNetworkInterface',
    'ComputeV1InstanceNetworkInterfaceIpAddress',
    'ComputeV1InstanceNetworkInterfacePublicIpAddress',
    'ComputeV1InstanceResources',
    'ComputeV1InstanceSecondaryDisk',
    'ComputeV1InstanceSecondaryDiskExistingDisk',
    'ComputeV1InstanceStatus',
    'ComputeV1InstanceStatusInfinibandTopologyPath',
    'ComputeV1InstanceStatusNetworkInterface',
    'ComputeV1InstanceStatusNetworkInterfaceIpAddress',
    'ComputeV1InstanceStatusNetworkInterfacePublicIpAddress',
    'ComputeV1alpha1DiskMetadata',
    'ComputeV1alpha1DiskPlacementPolicy',
    'ComputeV1alpha1DiskStatus',
    'ComputeV1alpha1FilesystemMetadata',
    'ComputeV1alpha1FilesystemStatus',
    'ComputeV1alpha1GpuClusterMetadata',
    'ComputeV1alpha1GpuClusterStatus',
    'ComputeV1alpha1InstanceBootDisk',
    'ComputeV1alpha1InstanceBootDiskExistingDisk',
    'ComputeV1alpha1InstanceFilesystem',
    'ComputeV1alpha1InstanceFilesystemExistingFilesystem',
    'ComputeV1alpha1InstanceGpuCluster',
    'ComputeV1alpha1InstanceMetadata',
    'ComputeV1alpha1InstanceNetworkInterface',
    'ComputeV1alpha1InstanceNetworkInterfaceIpAddress',
    'ComputeV1alpha1InstanceNetworkInterfacePublicIpAddress',
    'ComputeV1alpha1InstanceResources',
    'ComputeV1alpha1InstanceSecondaryDisk',
    'ComputeV1alpha1InstanceSecondaryDiskExistingDisk',
    'ComputeV1alpha1InstanceStatus',
    'ComputeV1alpha1InstanceStatusNetworkInterface',
    'ComputeV1alpha1InstanceStatusNetworkInterfaceIpAddress',
    'ComputeV1alpha1InstanceStatusNetworkInterfacePublicIpAddress',
    'IamV1AccessPermitMetadata',
    'IamV1AccessPermitStatus',
    'IamV1AuthPublicKeyAccount',
    'IamV1AuthPublicKeyAccountAnonymousAccount',
    'IamV1AuthPublicKeyAccountServiceAccount',
    'IamV1AuthPublicKeyAccountUserAccount',
    'IamV1AuthPublicKeyMetadata',
    'IamV1AuthPublicKeyStatus',
    'IamV1FederatedCredentialsMetadata',
    'IamV1FederatedCredentialsOidcProvider',
    'IamV1FederatedCredentialsStatus',
    'IamV1FederationCertificateMetadata',
    'IamV1FederationCertificateStatus',
    'IamV1FederationMetadata',
    'IamV1FederationSamlSettings',
    'IamV1FederationStatus',
    'IamV1GroupMembershipMetadata',
    'IamV1GroupMembershipStatus',
    'IamV1GroupMetadata',
    'IamV1GroupStatus',
    'IamV1InvitationMetadata',
    'IamV1InvitationStatus',
    'IamV1ServiceAccountMetadata',
    'IamV1ServiceAccountStatus',
    'IamV2AccessKeyAccount',
    'IamV2AccessKeyAccountAnonymousAccount',
    'IamV2AccessKeyAccountServiceAccount',
    'IamV2AccessKeyAccountUserAccount',
    'IamV2AccessKeyMetadata',
    'IamV2AccessKeyStatus',
    'Mk8sV1ClusterControlPlane',
    'Mk8sV1ClusterControlPlaneEndpoints',
    'Mk8sV1ClusterControlPlaneEndpointsPublicEndpoint',
    'Mk8sV1ClusterKubeNetwork',
    'Mk8sV1ClusterMetadata',
    'Mk8sV1ClusterStatus',
    'Mk8sV1ClusterStatusControlPlane',
    'Mk8sV1ClusterStatusControlPlaneAuth',
    'Mk8sV1ClusterStatusControlPlaneEndpoints',
    'Mk8sV1NodeGroupAutoscaling',
    'Mk8sV1NodeGroupMetadata',
    'Mk8sV1NodeGroupStatus',
    'Mk8sV1NodeGroupStrategy',
    'Mk8sV1NodeGroupStrategyMaxSurge',
    'Mk8sV1NodeGroupStrategyMaxUnavailable',
    'Mk8sV1NodeGroupTemplate',
    'Mk8sV1NodeGroupTemplateBootDisk',
    'Mk8sV1NodeGroupTemplateFilesystem',
    'Mk8sV1NodeGroupTemplateFilesystemExistingFilesystem',
    'Mk8sV1NodeGroupTemplateGpuCluster',
    'Mk8sV1NodeGroupTemplateGpuSettings',
    'Mk8sV1NodeGroupTemplateMetadata',
    'Mk8sV1NodeGroupTemplateNetworkInterface',
    'Mk8sV1NodeGroupTemplateNetworkInterfacePublicIpAddress',
    'Mk8sV1NodeGroupTemplateResources',
    'Mk8sV1NodeGroupTemplateTaint',
    'Mk8sV1alpha1ClusterControlPlane',
    'Mk8sV1alpha1ClusterControlPlaneEndpoints',
    'Mk8sV1alpha1ClusterControlPlaneEndpointsPublicEndpoint',
    'Mk8sV1alpha1ClusterKubeNetwork',
    'Mk8sV1alpha1ClusterMetadata',
    'Mk8sV1alpha1ClusterStatus',
    'Mk8sV1alpha1ClusterStatusControlPlane',
    'Mk8sV1alpha1ClusterStatusControlPlaneAuth',
    'Mk8sV1alpha1ClusterStatusControlPlaneEndpoints',
    'Mk8sV1alpha1NodeGroupAutoscaling',
    'Mk8sV1alpha1NodeGroupMetadata',
    'Mk8sV1alpha1NodeGroupStatus',
    'Mk8sV1alpha1NodeGroupStrategy',
    'Mk8sV1alpha1NodeGroupStrategyMaxSurge',
    'Mk8sV1alpha1NodeGroupStrategyMaxUnavailable',
    'Mk8sV1alpha1NodeGroupTemplate',
    'Mk8sV1alpha1NodeGroupTemplateBootDisk',
    'Mk8sV1alpha1NodeGroupTemplateFilesystem',
    'Mk8sV1alpha1NodeGroupTemplateFilesystemExistingFilesystem',
    'Mk8sV1alpha1NodeGroupTemplateGpuCluster',
    'Mk8sV1alpha1NodeGroupTemplateGpuSettings',
    'Mk8sV1alpha1NodeGroupTemplateMetadata',
    'Mk8sV1alpha1NodeGroupTemplateNetworkInterface',
    'Mk8sV1alpha1NodeGroupTemplateNetworkInterfacePublicIpAddress',
    'Mk8sV1alpha1NodeGroupTemplateResources',
    'Mk8sV1alpha1NodeGroupTemplateTaint',
    'MspMlflowV1alpha1ClusterMetadata',
    'MspMlflowV1alpha1ClusterStatus',
    'MspMlflowV1alpha1ClusterStatusTrackingEndpoints',
    'MspPostgresqlV1alpha1ClusterBackup',
    'MspPostgresqlV1alpha1ClusterBootstrap',
    'MspPostgresqlV1alpha1ClusterConfig',
    'MspPostgresqlV1alpha1ClusterConfigPoolerConfig',
    'MspPostgresqlV1alpha1ClusterConfigPostgresqlConfig16',
    'MspPostgresqlV1alpha1ClusterConfigTemplate',
    'MspPostgresqlV1alpha1ClusterConfigTemplateDisk',
    'MspPostgresqlV1alpha1ClusterConfigTemplateHosts',
    'MspPostgresqlV1alpha1ClusterConfigTemplateResources',
    'MspPostgresqlV1alpha1ClusterMetadata',
    'MspPostgresqlV1alpha1ClusterStatus',
    'MspPostgresqlV1alpha1ClusterStatusConnectionEndpoints',
    'MspPostgresqlV1alpha1ClusterStatusPresetDetails',
    'MspSparkV1alpha1ClusterAuthorization',
    'MspSparkV1alpha1ClusterLimits',
    'MspSparkV1alpha1ClusterMetadata',
    'MspSparkV1alpha1ClusterStatus',
    'MspSparkV1alpha1SessionDriver',
    'MspSparkV1alpha1SessionDriverDisk',
    'MspSparkV1alpha1SessionDriverResources',
    'MspSparkV1alpha1SessionExecutor',
    'MspSparkV1alpha1SessionExecutorDisk',
    'MspSparkV1alpha1SessionExecutorHosts',
    'MspSparkV1alpha1SessionExecutorHostsDynamicAllocation',
    'MspSparkV1alpha1SessionExecutorResources',
    'MspSparkV1alpha1SessionMetadata',
    'MspSparkV1alpha1SessionPython',
    'MspSparkV1alpha1SessionStatus',
    'MspSparkV1alpha1SessionStatusDriverPresetDetails',
    'MspSparkV1alpha1SessionStatusExecutorPresetDetails',
    'RegistryV1RegistryMetadata',
    'RegistryV1RegistryStatus',
    'StorageV1BucketLifecycleConfiguration',
    'StorageV1BucketLifecycleConfigurationRule',
    'StorageV1BucketLifecycleConfigurationRuleAbortIncompleteMultipartUpload',
    'StorageV1BucketLifecycleConfigurationRuleExpiration',
    'StorageV1BucketLifecycleConfigurationRuleFilter',
    'StorageV1BucketLifecycleConfigurationRuleNoncurrentVersionExpiration',
    'StorageV1BucketMetadata',
    'StorageV1BucketStatus',
    'StorageV1BucketStatusCounter',
    'StorageV1BucketStatusCounterCounters',
    'StorageV1BucketStatusCounterNonCurrentCounters',
    'VpcV1AllocationIpv4Private',
    'VpcV1AllocationIpv4Public',
    'VpcV1AllocationMetadata',
    'VpcV1AllocationStatus',
    'VpcV1AllocationStatusAssignment',
    'VpcV1AllocationStatusAssignmentLoadBalancer',
    'VpcV1AllocationStatusAssignmentNetworkInterface',
    'VpcV1AllocationStatusDetails',
    'VpcV1NetworkIpv4PrivatePools',
    'VpcV1NetworkIpv4PrivatePoolsPool',
    'VpcV1NetworkIpv4PublicPools',
    'VpcV1NetworkIpv4PublicPoolsPool',
    'VpcV1NetworkMetadata',
    'VpcV1NetworkStatus',
    'VpcV1PoolCidr',
    'VpcV1PoolMetadata',
    'VpcV1PoolStatus',
    'VpcV1PoolStatusAssignment',
    'VpcV1SubnetIpv4PrivatePools',
    'VpcV1SubnetIpv4PrivatePoolsPool',
    'VpcV1SubnetIpv4PrivatePoolsPoolCidr',
    'VpcV1SubnetIpv4PublicPools',
    'VpcV1SubnetIpv4PublicPoolsPool',
    'VpcV1SubnetIpv4PublicPoolsPoolCidr',
    'VpcV1SubnetMetadata',
    'VpcV1SubnetStatus',
    'VpcV1alpha1AllocationIpv4Private',
    'VpcV1alpha1AllocationIpv4Public',
    'VpcV1alpha1AllocationMetadata',
    'VpcV1alpha1AllocationStatus',
    'VpcV1alpha1AllocationStatusAssignment',
    'VpcV1alpha1AllocationStatusAssignmentLoadBalancer',
    'VpcV1alpha1AllocationStatusAssignmentNetworkInterface',
    'VpcV1alpha1AllocationStatusDetails',
    'GetApplicationsV1alpha1K8sReleaseMetadataResult',
    'GetApplicationsV1alpha1K8sReleaseStatusResult',
    'GetComputeV1DiskMetadataResult',
    'GetComputeV1DiskPlacementPolicyResult',
    'GetComputeV1DiskSourceImageFamilyResult',
    'GetComputeV1DiskStatusResult',
    'GetComputeV1FilesystemMetadataResult',
    'GetComputeV1FilesystemStatusResult',
    'GetComputeV1GpuClusterMetadataResult',
    'GetComputeV1GpuClusterStatusResult',
    'GetComputeV1GpuClusterStatusInfinibandTopologyPathResult',
    'GetComputeV1GpuClusterStatusInfinibandTopologyPathInstanceResult',
    'GetComputeV1ImageMetadataResult',
    'GetComputeV1ImageStatusResult',
    'GetComputeV1InstanceBootDiskResult',
    'GetComputeV1InstanceBootDiskExistingDiskResult',
    'GetComputeV1InstanceFilesystemResult',
    'GetComputeV1InstanceFilesystemExistingFilesystemResult',
    'GetComputeV1InstanceGpuClusterResult',
    'GetComputeV1InstanceMetadataResult',
    'GetComputeV1InstanceNetworkInterfaceResult',
    'GetComputeV1InstanceNetworkInterfaceIpAddressResult',
    'GetComputeV1InstanceNetworkInterfacePublicIpAddressResult',
    'GetComputeV1InstanceResourcesResult',
    'GetComputeV1InstanceSecondaryDiskResult',
    'GetComputeV1InstanceSecondaryDiskExistingDiskResult',
    'GetComputeV1InstanceStatusResult',
    'GetComputeV1InstanceStatusInfinibandTopologyPathResult',
    'GetComputeV1InstanceStatusNetworkInterfaceResult',
    'GetComputeV1InstanceStatusNetworkInterfaceIpAddressResult',
    'GetComputeV1InstanceStatusNetworkInterfacePublicIpAddressResult',
    'GetComputeV1alpha1DiskMetadataResult',
    'GetComputeV1alpha1DiskPlacementPolicyResult',
    'GetComputeV1alpha1DiskStatusResult',
    'GetComputeV1alpha1FilesystemMetadataResult',
    'GetComputeV1alpha1FilesystemStatusResult',
    'GetComputeV1alpha1GpuClusterMetadataResult',
    'GetComputeV1alpha1GpuClusterStatusResult',
    'GetComputeV1alpha1ImageMetadataResult',
    'GetComputeV1alpha1ImageStatusResult',
    'GetComputeV1alpha1InstanceBootDiskResult',
    'GetComputeV1alpha1InstanceBootDiskExistingDiskResult',
    'GetComputeV1alpha1InstanceFilesystemResult',
    'GetComputeV1alpha1InstanceFilesystemExistingFilesystemResult',
    'GetComputeV1alpha1InstanceGpuClusterResult',
    'GetComputeV1alpha1InstanceMetadataResult',
    'GetComputeV1alpha1InstanceNetworkInterfaceResult',
    'GetComputeV1alpha1InstanceNetworkInterfaceIpAddressResult',
    'GetComputeV1alpha1InstanceNetworkInterfacePublicIpAddressResult',
    'GetComputeV1alpha1InstanceResourcesResult',
    'GetComputeV1alpha1InstanceSecondaryDiskResult',
    'GetComputeV1alpha1InstanceSecondaryDiskExistingDiskResult',
    'GetComputeV1alpha1InstanceStatusResult',
    'GetComputeV1alpha1InstanceStatusNetworkInterfaceResult',
    'GetComputeV1alpha1InstanceStatusNetworkInterfaceIpAddressResult',
    'GetComputeV1alpha1InstanceStatusNetworkInterfacePublicIpAddressResult',
    'GetIamV1AccessPermitMetadataResult',
    'GetIamV1AccessPermitStatusResult',
    'GetIamV1AuthPublicKeyAccountResult',
    'GetIamV1AuthPublicKeyAccountAnonymousAccountResult',
    'GetIamV1AuthPublicKeyAccountServiceAccountResult',
    'GetIamV1AuthPublicKeyAccountUserAccountResult',
    'GetIamV1AuthPublicKeyMetadataResult',
    'GetIamV1AuthPublicKeyStatusResult',
    'GetIamV1FederatedCredentialsMetadataResult',
    'GetIamV1FederatedCredentialsOidcProviderResult',
    'GetIamV1FederatedCredentialsStatusResult',
    'GetIamV1FederationCertificateMetadataResult',
    'GetIamV1FederationCertificateStatusResult',
    'GetIamV1FederationMetadataResult',
    'GetIamV1FederationSamlSettingsResult',
    'GetIamV1FederationStatusResult',
    'GetIamV1GroupMembershipMetadataResult',
    'GetIamV1GroupMembershipStatusResult',
    'GetIamV1GroupMetadataResult',
    'GetIamV1GroupStatusResult',
    'GetIamV1InvitationMetadataResult',
    'GetIamV1InvitationStatusResult',
    'GetIamV1ProjectMetadataResult',
    'GetIamV1ProjectStatusResult',
    'GetIamV1ServiceAccountMetadataResult',
    'GetIamV1ServiceAccountStatusResult',
    'GetIamV1TenantMetadataResult',
    'GetIamV1TenantStatusResult',
    'GetIamV1TenantUserAccountMetadataResult',
    'GetIamV1TenantUserAccountStatusResult',
    'GetIamV1TenantUserAccountVisibleAttributesResult',
    'GetIamV2AccessKeyAccountResult',
    'GetIamV2AccessKeyAccountAnonymousAccountResult',
    'GetIamV2AccessKeyAccountServiceAccountResult',
    'GetIamV2AccessKeyAccountUserAccountResult',
    'GetIamV2AccessKeyMetadataResult',
    'GetIamV2AccessKeyStatusResult',
    'GetMk8sV1ClusterControlPlaneResult',
    'GetMk8sV1ClusterControlPlaneEndpointsResult',
    'GetMk8sV1ClusterControlPlaneEndpointsPublicEndpointResult',
    'GetMk8sV1ClusterKubeNetworkResult',
    'GetMk8sV1ClusterMetadataResult',
    'GetMk8sV1ClusterStatusResult',
    'GetMk8sV1ClusterStatusControlPlaneResult',
    'GetMk8sV1ClusterStatusControlPlaneAuthResult',
    'GetMk8sV1ClusterStatusControlPlaneEndpointsResult',
    'GetMk8sV1NodeGroupAutoscalingResult',
    'GetMk8sV1NodeGroupMetadataResult',
    'GetMk8sV1NodeGroupStatusResult',
    'GetMk8sV1NodeGroupStrategyResult',
    'GetMk8sV1NodeGroupStrategyMaxSurgeResult',
    'GetMk8sV1NodeGroupStrategyMaxUnavailableResult',
    'GetMk8sV1NodeGroupTemplateResult',
    'GetMk8sV1NodeGroupTemplateBootDiskResult',
    'GetMk8sV1NodeGroupTemplateFilesystemResult',
    'GetMk8sV1NodeGroupTemplateFilesystemExistingFilesystemResult',
    'GetMk8sV1NodeGroupTemplateGpuClusterResult',
    'GetMk8sV1NodeGroupTemplateGpuSettingsResult',
    'GetMk8sV1NodeGroupTemplateMetadataResult',
    'GetMk8sV1NodeGroupTemplateNetworkInterfaceResult',
    'GetMk8sV1NodeGroupTemplateNetworkInterfacePublicIpAddressResult',
    'GetMk8sV1NodeGroupTemplateResourcesResult',
    'GetMk8sV1NodeGroupTemplateTaintResult',
    'GetMk8sV1alpha1ClusterControlPlaneResult',
    'GetMk8sV1alpha1ClusterControlPlaneEndpointsResult',
    'GetMk8sV1alpha1ClusterControlPlaneEndpointsPublicEndpointResult',
    'GetMk8sV1alpha1ClusterKubeNetworkResult',
    'GetMk8sV1alpha1ClusterMetadataResult',
    'GetMk8sV1alpha1ClusterStatusResult',
    'GetMk8sV1alpha1ClusterStatusControlPlaneResult',
    'GetMk8sV1alpha1ClusterStatusControlPlaneAuthResult',
    'GetMk8sV1alpha1ClusterStatusControlPlaneEndpointsResult',
    'GetMk8sV1alpha1NodeGroupAutoscalingResult',
    'GetMk8sV1alpha1NodeGroupMetadataResult',
    'GetMk8sV1alpha1NodeGroupStatusResult',
    'GetMk8sV1alpha1NodeGroupStrategyResult',
    'GetMk8sV1alpha1NodeGroupStrategyMaxSurgeResult',
    'GetMk8sV1alpha1NodeGroupStrategyMaxUnavailableResult',
    'GetMk8sV1alpha1NodeGroupTemplateResult',
    'GetMk8sV1alpha1NodeGroupTemplateBootDiskResult',
    'GetMk8sV1alpha1NodeGroupTemplateFilesystemResult',
    'GetMk8sV1alpha1NodeGroupTemplateFilesystemExistingFilesystemResult',
    'GetMk8sV1alpha1NodeGroupTemplateGpuClusterResult',
    'GetMk8sV1alpha1NodeGroupTemplateGpuSettingsResult',
    'GetMk8sV1alpha1NodeGroupTemplateMetadataResult',
    'GetMk8sV1alpha1NodeGroupTemplateNetworkInterfaceResult',
    'GetMk8sV1alpha1NodeGroupTemplateNetworkInterfacePublicIpAddressResult',
    'GetMk8sV1alpha1NodeGroupTemplateResourcesResult',
    'GetMk8sV1alpha1NodeGroupTemplateTaintResult',
    'GetMspMlflowV1alpha1ClusterMetadataResult',
    'GetMspMlflowV1alpha1ClusterStatusResult',
    'GetMspMlflowV1alpha1ClusterStatusTrackingEndpointsResult',
    'GetMspPostgresqlV1alpha1ClusterBackupResult',
    'GetMspPostgresqlV1alpha1ClusterBootstrapResult',
    'GetMspPostgresqlV1alpha1ClusterConfigResult',
    'GetMspPostgresqlV1alpha1ClusterConfigPoolerConfigResult',
    'GetMspPostgresqlV1alpha1ClusterConfigPostgresqlConfig16Result',
    'GetMspPostgresqlV1alpha1ClusterConfigTemplateResult',
    'GetMspPostgresqlV1alpha1ClusterConfigTemplateDiskResult',
    'GetMspPostgresqlV1alpha1ClusterConfigTemplateHostsResult',
    'GetMspPostgresqlV1alpha1ClusterConfigTemplateResourcesResult',
    'GetMspPostgresqlV1alpha1ClusterMetadataResult',
    'GetMspPostgresqlV1alpha1ClusterStatusResult',
    'GetMspPostgresqlV1alpha1ClusterStatusConnectionEndpointsResult',
    'GetMspPostgresqlV1alpha1ClusterStatusPresetDetailsResult',
    'GetMspSparkV1alpha1ClusterAuthorizationResult',
    'GetMspSparkV1alpha1ClusterLimitsResult',
    'GetMspSparkV1alpha1ClusterMetadataResult',
    'GetMspSparkV1alpha1ClusterStatusResult',
    'GetMspSparkV1alpha1SessionDriverResult',
    'GetMspSparkV1alpha1SessionDriverDiskResult',
    'GetMspSparkV1alpha1SessionDriverResourcesResult',
    'GetMspSparkV1alpha1SessionExecutorResult',
    'GetMspSparkV1alpha1SessionExecutorDiskResult',
    'GetMspSparkV1alpha1SessionExecutorHostsResult',
    'GetMspSparkV1alpha1SessionExecutorHostsDynamicAllocationResult',
    'GetMspSparkV1alpha1SessionExecutorResourcesResult',
    'GetMspSparkV1alpha1SessionMetadataResult',
    'GetMspSparkV1alpha1SessionPythonResult',
    'GetMspSparkV1alpha1SessionStatusResult',
    'GetMspSparkV1alpha1SessionStatusDriverPresetDetailsResult',
    'GetMspSparkV1alpha1SessionStatusExecutorPresetDetailsResult',
    'GetRegistryV1RegistryMetadataResult',
    'GetRegistryV1RegistryStatusResult',
    'GetStorageV1BucketLifecycleConfigurationResult',
    'GetStorageV1BucketLifecycleConfigurationRuleResult',
    'GetStorageV1BucketLifecycleConfigurationRuleAbortIncompleteMultipartUploadResult',
    'GetStorageV1BucketLifecycleConfigurationRuleExpirationResult',
    'GetStorageV1BucketLifecycleConfigurationRuleFilterResult',
    'GetStorageV1BucketLifecycleConfigurationRuleNoncurrentVersionExpirationResult',
    'GetStorageV1BucketMetadataResult',
    'GetStorageV1BucketStatusResult',
    'GetStorageV1BucketStatusCounterResult',
    'GetStorageV1BucketStatusCounterCountersResult',
    'GetStorageV1BucketStatusCounterNonCurrentCountersResult',
    'GetVpcV1AllocationIpv4PrivateResult',
    'GetVpcV1AllocationIpv4PublicResult',
    'GetVpcV1AllocationMetadataResult',
    'GetVpcV1AllocationStatusResult',
    'GetVpcV1AllocationStatusAssignmentResult',
    'GetVpcV1AllocationStatusAssignmentLoadBalancerResult',
    'GetVpcV1AllocationStatusAssignmentNetworkInterfaceResult',
    'GetVpcV1AllocationStatusDetailsResult',
    'GetVpcV1NetworkIpv4PrivatePoolsResult',
    'GetVpcV1NetworkIpv4PrivatePoolsPoolResult',
    'GetVpcV1NetworkIpv4PublicPoolsResult',
    'GetVpcV1NetworkIpv4PublicPoolsPoolResult',
    'GetVpcV1NetworkMetadataResult',
    'GetVpcV1NetworkStatusResult',
    'GetVpcV1PoolCidrResult',
    'GetVpcV1PoolMetadataResult',
    'GetVpcV1PoolStatusResult',
    'GetVpcV1PoolStatusAssignmentResult',
    'GetVpcV1SubnetIpv4PrivatePoolsResult',
    'GetVpcV1SubnetIpv4PrivatePoolsPoolResult',
    'GetVpcV1SubnetIpv4PrivatePoolsPoolCidrResult',
    'GetVpcV1SubnetIpv4PublicPoolsResult',
    'GetVpcV1SubnetIpv4PublicPoolsPoolResult',
    'GetVpcV1SubnetIpv4PublicPoolsPoolCidrResult',
    'GetVpcV1SubnetMetadataResult',
    'GetVpcV1SubnetStatusResult',
    'GetVpcV1alpha1AllocationIpv4PrivateResult',
    'GetVpcV1alpha1AllocationIpv4PublicResult',
    'GetVpcV1alpha1AllocationMetadataResult',
    'GetVpcV1alpha1AllocationStatusResult',
    'GetVpcV1alpha1AllocationStatusAssignmentResult',
    'GetVpcV1alpha1AllocationStatusAssignmentLoadBalancerResult',
    'GetVpcV1alpha1AllocationStatusAssignmentNetworkInterfaceResult',
    'GetVpcV1alpha1AllocationStatusDetailsResult',
    'GetVpcV1alpha1NetworkMetadataResult',
    'GetVpcV1alpha1NetworkPoolResult',
    'GetVpcV1alpha1NetworkStatusResult',
    'GetVpcV1alpha1PoolCidrResult',
    'GetVpcV1alpha1PoolMetadataResult',
    'GetVpcV1alpha1PoolStatusResult',
    'GetVpcV1alpha1ScopeMetadataResult',
    'GetVpcV1alpha1ScopeStatusResult',
    'GetVpcV1alpha1SubnetMetadataResult',
    'GetVpcV1alpha1SubnetPoolResult',
    'GetVpcV1alpha1SubnetPoolSpecResult',
    'GetVpcV1alpha1SubnetPoolSpecCidrResult',
    'GetVpcV1alpha1SubnetStatusResult',
]

@pulumi.output_type
class ApplicationsV1alpha1K8sReleaseMetadata(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class ApplicationsV1alpha1K8sReleaseStatus(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "errorMessage":
            suggest = "error_message"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ApplicationsV1alpha1K8sReleaseStatus. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ApplicationsV1alpha1K8sReleaseStatus.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ApplicationsV1alpha1K8sReleaseStatus.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 error_message: Optional[builtins.str] = None,
                 state: Optional[builtins.str] = None):
        """
        :param builtins.str state: ### Supported values
               
               Possible values:
               
                - `UNSPECIFIED`
                - `CREATED`
                - `RUNNING`
                - `DEPLOYED`
                - `FAILED`
                - `INSTALLING`
        """
        if error_message is not None:
            pulumi.set(__self__, "error_message", error_message)
        if state is not None:
            pulumi.set(__self__, "state", state)

    @property
    @pulumi.getter(name="errorMessage")
    def error_message(self) -> Optional[builtins.str]:
        return pulumi.get(self, "error_message")

    @property
    @pulumi.getter
    def state(self) -> Optional[builtins.str]:
        """
        ### Supported values

        Possible values:

         - `UNSPECIFIED`
         - `CREATED`
         - `RUNNING`
         - `DEPLOYED`
         - `FAILED`
         - `INSTALLING`
        """
        return pulumi.get(self, "state")


@pulumi.output_type
class ComputeV1DiskMetadata(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class ComputeV1DiskPlacementPolicy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "placementGroupId":
            suggest = "placement_group_id"
        elif key == "placementGroupPartition":
            suggest = "placement_group_partition"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ComputeV1DiskPlacementPolicy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ComputeV1DiskPlacementPolicy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ComputeV1DiskPlacementPolicy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 placement_group_id: Optional[builtins.str] = None,
                 placement_group_partition: Optional[builtins.float] = None):
        if placement_group_id is not None:
            pulumi.set(__self__, "placement_group_id", placement_group_id)
        if placement_group_partition is not None:
            pulumi.set(__self__, "placement_group_partition", placement_group_partition)

    @property
    @pulumi.getter(name="placementGroupId")
    def placement_group_id(self) -> Optional[builtins.str]:
        return pulumi.get(self, "placement_group_id")

    @property
    @pulumi.getter(name="placementGroupPartition")
    def placement_group_partition(self) -> Optional[builtins.float]:
        return pulumi.get(self, "placement_group_partition")


@pulumi.output_type
class ComputeV1DiskSourceImageFamily(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "imageFamily":
            suggest = "image_family"
        elif key == "parentId":
            suggest = "parent_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ComputeV1DiskSourceImageFamily. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ComputeV1DiskSourceImageFamily.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ComputeV1DiskSourceImageFamily.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 image_family: builtins.str,
                 parent_id: Optional[builtins.str] = None):
        pulumi.set(__self__, "image_family", image_family)
        if parent_id is not None:
            pulumi.set(__self__, "parent_id", parent_id)

    @property
    @pulumi.getter(name="imageFamily")
    def image_family(self) -> builtins.str:
        return pulumi.get(self, "image_family")

    @property
    @pulumi.getter(name="parentId")
    def parent_id(self) -> Optional[builtins.str]:
        return pulumi.get(self, "parent_id")


@pulumi.output_type
class ComputeV1DiskStatus(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "blockSizeBytes":
            suggest = "block_size_bytes"
        elif key == "readOnlyAttachments":
            suggest = "read_only_attachments"
        elif key == "readWriteAttachment":
            suggest = "read_write_attachment"
        elif key == "sizeBytes":
            suggest = "size_bytes"
        elif key == "sourceImageCpuArchitecture":
            suggest = "source_image_cpu_architecture"
        elif key == "sourceImageId":
            suggest = "source_image_id"
        elif key == "stateDescription":
            suggest = "state_description"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ComputeV1DiskStatus. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ComputeV1DiskStatus.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ComputeV1DiskStatus.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 block_size_bytes: Optional[builtins.float] = None,
                 read_only_attachments: Optional[Sequence[builtins.str]] = None,
                 read_write_attachment: Optional[builtins.str] = None,
                 reconciling: Optional[builtins.bool] = None,
                 size_bytes: Optional[builtins.float] = None,
                 source_image_cpu_architecture: Optional[builtins.str] = None,
                 source_image_id: Optional[builtins.str] = None,
                 state: Optional[builtins.str] = None,
                 state_description: Optional[builtins.str] = None):
        """
        :param builtins.bool reconciling: Indicates whether there is an ongoing operation
        :param builtins.str source_image_cpu_architecture: ### Supported values
               
               Possible values:
               
                - `SOURCE_IMAGE_CPU_UNSPECIFIED`
                - `AMD64`
                - `ARM64`
        :param builtins.str state: ### Supported values
               
               Possible values:
               
                - `UNSPECIFIED`
                - `CREATING`
                - `READY`
                - `UPDATING`
                - `DELETING`
                - `ERROR`
        """
        if block_size_bytes is not None:
            pulumi.set(__self__, "block_size_bytes", block_size_bytes)
        if read_only_attachments is not None:
            pulumi.set(__self__, "read_only_attachments", read_only_attachments)
        if read_write_attachment is not None:
            pulumi.set(__self__, "read_write_attachment", read_write_attachment)
        if reconciling is not None:
            pulumi.set(__self__, "reconciling", reconciling)
        if size_bytes is not None:
            pulumi.set(__self__, "size_bytes", size_bytes)
        if source_image_cpu_architecture is not None:
            pulumi.set(__self__, "source_image_cpu_architecture", source_image_cpu_architecture)
        if source_image_id is not None:
            pulumi.set(__self__, "source_image_id", source_image_id)
        if state is not None:
            pulumi.set(__self__, "state", state)
        if state_description is not None:
            pulumi.set(__self__, "state_description", state_description)

    @property
    @pulumi.getter(name="blockSizeBytes")
    def block_size_bytes(self) -> Optional[builtins.float]:
        return pulumi.get(self, "block_size_bytes")

    @property
    @pulumi.getter(name="readOnlyAttachments")
    def read_only_attachments(self) -> Optional[Sequence[builtins.str]]:
        return pulumi.get(self, "read_only_attachments")

    @property
    @pulumi.getter(name="readWriteAttachment")
    def read_write_attachment(self) -> Optional[builtins.str]:
        return pulumi.get(self, "read_write_attachment")

    @property
    @pulumi.getter
    def reconciling(self) -> Optional[builtins.bool]:
        """
        Indicates whether there is an ongoing operation
        """
        return pulumi.get(self, "reconciling")

    @property
    @pulumi.getter(name="sizeBytes")
    def size_bytes(self) -> Optional[builtins.float]:
        return pulumi.get(self, "size_bytes")

    @property
    @pulumi.getter(name="sourceImageCpuArchitecture")
    def source_image_cpu_architecture(self) -> Optional[builtins.str]:
        """
        ### Supported values

        Possible values:

         - `SOURCE_IMAGE_CPU_UNSPECIFIED`
         - `AMD64`
         - `ARM64`
        """
        return pulumi.get(self, "source_image_cpu_architecture")

    @property
    @pulumi.getter(name="sourceImageId")
    def source_image_id(self) -> Optional[builtins.str]:
        return pulumi.get(self, "source_image_id")

    @property
    @pulumi.getter
    def state(self) -> Optional[builtins.str]:
        """
        ### Supported values

        Possible values:

         - `UNSPECIFIED`
         - `CREATING`
         - `READY`
         - `UPDATING`
         - `DELETING`
         - `ERROR`
        """
        return pulumi.get(self, "state")

    @property
    @pulumi.getter(name="stateDescription")
    def state_description(self) -> Optional[builtins.str]:
        return pulumi.get(self, "state_description")


@pulumi.output_type
class ComputeV1FilesystemMetadata(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class ComputeV1FilesystemStatus(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "blockSizeBytes":
            suggest = "block_size_bytes"
        elif key == "readOnlyAttachments":
            suggest = "read_only_attachments"
        elif key == "readWriteAttachments":
            suggest = "read_write_attachments"
        elif key == "sizeBytes":
            suggest = "size_bytes"
        elif key == "stateDescription":
            suggest = "state_description"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ComputeV1FilesystemStatus. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ComputeV1FilesystemStatus.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ComputeV1FilesystemStatus.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 block_size_bytes: Optional[builtins.float] = None,
                 read_only_attachments: Optional[Sequence[builtins.str]] = None,
                 read_write_attachments: Optional[Sequence[builtins.str]] = None,
                 reconciling: Optional[builtins.bool] = None,
                 size_bytes: Optional[builtins.float] = None,
                 state: Optional[builtins.str] = None,
                 state_description: Optional[builtins.str] = None):
        """
        :param builtins.bool reconciling: Indicates whether there is an ongoing operation
        :param builtins.str state: ### Supported values
               
               Possible values:
               
                - `UNSPECIFIED`
                - `CREATING`
                - `READY`
                - `UPDATING`
                - `DELETING`
                - `ERROR`
        """
        if block_size_bytes is not None:
            pulumi.set(__self__, "block_size_bytes", block_size_bytes)
        if read_only_attachments is not None:
            pulumi.set(__self__, "read_only_attachments", read_only_attachments)
        if read_write_attachments is not None:
            pulumi.set(__self__, "read_write_attachments", read_write_attachments)
        if reconciling is not None:
            pulumi.set(__self__, "reconciling", reconciling)
        if size_bytes is not None:
            pulumi.set(__self__, "size_bytes", size_bytes)
        if state is not None:
            pulumi.set(__self__, "state", state)
        if state_description is not None:
            pulumi.set(__self__, "state_description", state_description)

    @property
    @pulumi.getter(name="blockSizeBytes")
    def block_size_bytes(self) -> Optional[builtins.float]:
        return pulumi.get(self, "block_size_bytes")

    @property
    @pulumi.getter(name="readOnlyAttachments")
    def read_only_attachments(self) -> Optional[Sequence[builtins.str]]:
        return pulumi.get(self, "read_only_attachments")

    @property
    @pulumi.getter(name="readWriteAttachments")
    def read_write_attachments(self) -> Optional[Sequence[builtins.str]]:
        return pulumi.get(self, "read_write_attachments")

    @property
    @pulumi.getter
    def reconciling(self) -> Optional[builtins.bool]:
        """
        Indicates whether there is an ongoing operation
        """
        return pulumi.get(self, "reconciling")

    @property
    @pulumi.getter(name="sizeBytes")
    def size_bytes(self) -> Optional[builtins.float]:
        return pulumi.get(self, "size_bytes")

    @property
    @pulumi.getter
    def state(self) -> Optional[builtins.str]:
        """
        ### Supported values

        Possible values:

         - `UNSPECIFIED`
         - `CREATING`
         - `READY`
         - `UPDATING`
         - `DELETING`
         - `ERROR`
        """
        return pulumi.get(self, "state")

    @property
    @pulumi.getter(name="stateDescription")
    def state_description(self) -> Optional[builtins.str]:
        return pulumi.get(self, "state_description")


@pulumi.output_type
class ComputeV1GpuClusterMetadata(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class ComputeV1GpuClusterStatus(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "infinibandTopologyPath":
            suggest = "infiniband_topology_path"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ComputeV1GpuClusterStatus. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ComputeV1GpuClusterStatus.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ComputeV1GpuClusterStatus.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 infiniband_topology_path: Optional['outputs.ComputeV1GpuClusterStatusInfinibandTopologyPath'] = None,
                 instances: Optional[Sequence[builtins.str]] = None,
                 reconciling: Optional[builtins.bool] = None):
        """
        :param builtins.bool reconciling: Indicates whether there is an ongoing operation
        """
        if infiniband_topology_path is not None:
            pulumi.set(__self__, "infiniband_topology_path", infiniband_topology_path)
        if instances is not None:
            pulumi.set(__self__, "instances", instances)
        if reconciling is not None:
            pulumi.set(__self__, "reconciling", reconciling)

    @property
    @pulumi.getter(name="infinibandTopologyPath")
    def infiniband_topology_path(self) -> Optional['outputs.ComputeV1GpuClusterStatusInfinibandTopologyPath']:
        return pulumi.get(self, "infiniband_topology_path")

    @property
    @pulumi.getter
    def instances(self) -> Optional[Sequence[builtins.str]]:
        return pulumi.get(self, "instances")

    @property
    @pulumi.getter
    def reconciling(self) -> Optional[builtins.bool]:
        """
        Indicates whether there is an ongoing operation
        """
        return pulumi.get(self, "reconciling")


@pulumi.output_type
class ComputeV1GpuClusterStatusInfinibandTopologyPath(dict):
    def __init__(__self__, *,
                 instances: Optional[Sequence['outputs.ComputeV1GpuClusterStatusInfinibandTopologyPathInstance']] = None):
        if instances is not None:
            pulumi.set(__self__, "instances", instances)

    @property
    @pulumi.getter
    def instances(self) -> Optional[Sequence['outputs.ComputeV1GpuClusterStatusInfinibandTopologyPathInstance']]:
        return pulumi.get(self, "instances")


@pulumi.output_type
class ComputeV1GpuClusterStatusInfinibandTopologyPathInstance(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "instanceId":
            suggest = "instance_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ComputeV1GpuClusterStatusInfinibandTopologyPathInstance. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ComputeV1GpuClusterStatusInfinibandTopologyPathInstance.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ComputeV1GpuClusterStatusInfinibandTopologyPathInstance.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 instance_id: Optional[builtins.str] = None,
                 paths: Optional[Sequence[builtins.str]] = None):
        if instance_id is not None:
            pulumi.set(__self__, "instance_id", instance_id)
        if paths is not None:
            pulumi.set(__self__, "paths", paths)

    @property
    @pulumi.getter(name="instanceId")
    def instance_id(self) -> Optional[builtins.str]:
        return pulumi.get(self, "instance_id")

    @property
    @pulumi.getter
    def paths(self) -> Optional[Sequence[builtins.str]]:
        return pulumi.get(self, "paths")


@pulumi.output_type
class ComputeV1InstanceBootDisk(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "attachMode":
            suggest = "attach_mode"
        elif key == "deviceId":
            suggest = "device_id"
        elif key == "existingDisk":
            suggest = "existing_disk"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ComputeV1InstanceBootDisk. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ComputeV1InstanceBootDisk.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ComputeV1InstanceBootDisk.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 attach_mode: builtins.str,
                 device_id: Optional[builtins.str] = None,
                 existing_disk: Optional['outputs.ComputeV1InstanceBootDiskExistingDisk'] = None):
        """
        :param builtins.str attach_mode: ### Supported values
               
               Possible values:
               
                - `UNSPECIFIED`
                - `READ_ONLY`
                - `READ_WRITE`
        :param builtins.str device_id: Specifies the user-defined identifier, allowing to use '/dev/disk/by-id/virtio-{device_id}' as a device path in mount command.
        """
        pulumi.set(__self__, "attach_mode", attach_mode)
        if device_id is not None:
            pulumi.set(__self__, "device_id", device_id)
        if existing_disk is not None:
            pulumi.set(__self__, "existing_disk", existing_disk)

    @property
    @pulumi.getter(name="attachMode")
    def attach_mode(self) -> builtins.str:
        """
        ### Supported values

        Possible values:

         - `UNSPECIFIED`
         - `READ_ONLY`
         - `READ_WRITE`
        """
        return pulumi.get(self, "attach_mode")

    @property
    @pulumi.getter(name="deviceId")
    def device_id(self) -> Optional[builtins.str]:
        """
        Specifies the user-defined identifier, allowing to use '/dev/disk/by-id/virtio-{device_id}' as a device path in mount command.
        """
        return pulumi.get(self, "device_id")

    @property
    @pulumi.getter(name="existingDisk")
    def existing_disk(self) -> Optional['outputs.ComputeV1InstanceBootDiskExistingDisk']:
        return pulumi.get(self, "existing_disk")


@pulumi.output_type
class ComputeV1InstanceBootDiskExistingDisk(dict):
    def __init__(__self__, *,
                 id: builtins.str):
        pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> builtins.str:
        return pulumi.get(self, "id")


@pulumi.output_type
class ComputeV1InstanceFilesystem(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "attachMode":
            suggest = "attach_mode"
        elif key == "mountTag":
            suggest = "mount_tag"
        elif key == "existingFilesystem":
            suggest = "existing_filesystem"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ComputeV1InstanceFilesystem. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ComputeV1InstanceFilesystem.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ComputeV1InstanceFilesystem.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 attach_mode: builtins.str,
                 mount_tag: builtins.str,
                 existing_filesystem: Optional['outputs.ComputeV1InstanceFilesystemExistingFilesystem'] = None):
        """
        :param builtins.str attach_mode: ### Supported values
               
               Possible values:
               
                - `UNSPECIFIED`
                - `READ_ONLY`
                - `READ_WRITE`
        :param builtins.str mount_tag: Specifies the user-defined identifier, allowing to use it as a device in mount command.
        """
        pulumi.set(__self__, "attach_mode", attach_mode)
        pulumi.set(__self__, "mount_tag", mount_tag)
        if existing_filesystem is not None:
            pulumi.set(__self__, "existing_filesystem", existing_filesystem)

    @property
    @pulumi.getter(name="attachMode")
    def attach_mode(self) -> builtins.str:
        """
        ### Supported values

        Possible values:

         - `UNSPECIFIED`
         - `READ_ONLY`
         - `READ_WRITE`
        """
        return pulumi.get(self, "attach_mode")

    @property
    @pulumi.getter(name="mountTag")
    def mount_tag(self) -> builtins.str:
        """
        Specifies the user-defined identifier, allowing to use it as a device in mount command.
        """
        return pulumi.get(self, "mount_tag")

    @property
    @pulumi.getter(name="existingFilesystem")
    def existing_filesystem(self) -> Optional['outputs.ComputeV1InstanceFilesystemExistingFilesystem']:
        return pulumi.get(self, "existing_filesystem")


@pulumi.output_type
class ComputeV1InstanceFilesystemExistingFilesystem(dict):
    def __init__(__self__, *,
                 id: builtins.str):
        pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> builtins.str:
        return pulumi.get(self, "id")


@pulumi.output_type
class ComputeV1InstanceGpuCluster(dict):
    def __init__(__self__, *,
                 id: Optional[builtins.str] = None):
        if id is not None:
            pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> Optional[builtins.str]:
        return pulumi.get(self, "id")


@pulumi.output_type
class ComputeV1InstanceMetadata(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class ComputeV1InstanceNetworkInterface(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "ipAddress":
            suggest = "ip_address"
        elif key == "subnetId":
            suggest = "subnet_id"
        elif key == "publicIpAddress":
            suggest = "public_ip_address"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ComputeV1InstanceNetworkInterface. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ComputeV1InstanceNetworkInterface.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ComputeV1InstanceNetworkInterface.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ip_address: 'outputs.ComputeV1InstanceNetworkInterfaceIpAddress',
                 name: builtins.str,
                 subnet_id: builtins.str,
                 public_ip_address: Optional['outputs.ComputeV1InstanceNetworkInterfacePublicIpAddress'] = None):
        """
        :param 'ComputeV1InstanceNetworkInterfaceIpAddressArgs' ip_address: Private IPv4 address associated with the interface.
               
               ### Inner value description
               
               Describes an IPv4 address.
        :param builtins.str name: Interface name
               Value of this field configures the name of the network interface inside VM's OS.
               Longer values will persist in the specification but will be truncated to 15 symbols before being passed to VM configuration.
        :param builtins.str subnet_id: Subnet ID
        :param 'ComputeV1InstanceNetworkInterfacePublicIpAddressArgs' public_ip_address: Public IPv4 address associated with the interface.
               
               ### Inner value description
               
               Describes a public IP address.
        """
        pulumi.set(__self__, "ip_address", ip_address)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "subnet_id", subnet_id)
        if public_ip_address is not None:
            pulumi.set(__self__, "public_ip_address", public_ip_address)

    @property
    @pulumi.getter(name="ipAddress")
    def ip_address(self) -> 'outputs.ComputeV1InstanceNetworkInterfaceIpAddress':
        """
        Private IPv4 address associated with the interface.

        ### Inner value description

        Describes an IPv4 address.
        """
        return pulumi.get(self, "ip_address")

    @property
    @pulumi.getter
    def name(self) -> builtins.str:
        """
        Interface name
        Value of this field configures the name of the network interface inside VM's OS.
        Longer values will persist in the specification but will be truncated to 15 symbols before being passed to VM configuration.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="subnetId")
    def subnet_id(self) -> builtins.str:
        """
        Subnet ID
        """
        return pulumi.get(self, "subnet_id")

    @property
    @pulumi.getter(name="publicIpAddress")
    def public_ip_address(self) -> Optional['outputs.ComputeV1InstanceNetworkInterfacePublicIpAddress']:
        """
        Public IPv4 address associated with the interface.

        ### Inner value description

        Describes a public IP address.
        """
        return pulumi.get(self, "public_ip_address")


@pulumi.output_type
class ComputeV1InstanceNetworkInterfaceIpAddress(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "allocationId":
            suggest = "allocation_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ComputeV1InstanceNetworkInterfaceIpAddress. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ComputeV1InstanceNetworkInterfaceIpAddress.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ComputeV1InstanceNetworkInterfaceIpAddress.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 allocation_id: Optional[builtins.str] = None):
        """
        :param builtins.str allocation_id: Allocation identifier if it was created before.
        """
        if allocation_id is not None:
            pulumi.set(__self__, "allocation_id", allocation_id)

    @property
    @pulumi.getter(name="allocationId")
    def allocation_id(self) -> Optional[builtins.str]:
        """
        Allocation identifier if it was created before.
        """
        return pulumi.get(self, "allocation_id")


@pulumi.output_type
class ComputeV1InstanceNetworkInterfacePublicIpAddress(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "allocationId":
            suggest = "allocation_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ComputeV1InstanceNetworkInterfacePublicIpAddress. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ComputeV1InstanceNetworkInterfacePublicIpAddress.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ComputeV1InstanceNetworkInterfacePublicIpAddress.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 allocation_id: Optional[builtins.str] = None,
                 static: Optional[builtins.bool] = None):
        """
        :param builtins.str allocation_id: Allocation identifier if it was created before.
        :param builtins.bool static: If false - Allocation will be created/deleted during NetworkInterface.Allocate/NetworkInterface.Deallocate
               If true  - Allocation will be created/deleted during NetworkInterface.Create/NetworkInterface.Delete
               False by default
        """
        if allocation_id is not None:
            pulumi.set(__self__, "allocation_id", allocation_id)
        if static is not None:
            pulumi.set(__self__, "static", static)

    @property
    @pulumi.getter(name="allocationId")
    def allocation_id(self) -> Optional[builtins.str]:
        """
        Allocation identifier if it was created before.
        """
        return pulumi.get(self, "allocation_id")

    @property
    @pulumi.getter
    def static(self) -> Optional[builtins.bool]:
        """
        If false - Allocation will be created/deleted during NetworkInterface.Allocate/NetworkInterface.Deallocate
        If true  - Allocation will be created/deleted during NetworkInterface.Create/NetworkInterface.Delete
        False by default
        """
        return pulumi.get(self, "static")


@pulumi.output_type
class ComputeV1InstanceResources(dict):
    def __init__(__self__, *,
                 platform: builtins.str,
                 preset: Optional[builtins.str] = None):
        pulumi.set(__self__, "platform", platform)
        if preset is not None:
            pulumi.set(__self__, "preset", preset)

    @property
    @pulumi.getter
    def platform(self) -> builtins.str:
        return pulumi.get(self, "platform")

    @property
    @pulumi.getter
    def preset(self) -> Optional[builtins.str]:
        return pulumi.get(self, "preset")


@pulumi.output_type
class ComputeV1InstanceSecondaryDisk(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "attachMode":
            suggest = "attach_mode"
        elif key == "deviceId":
            suggest = "device_id"
        elif key == "existingDisk":
            suggest = "existing_disk"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ComputeV1InstanceSecondaryDisk. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ComputeV1InstanceSecondaryDisk.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ComputeV1InstanceSecondaryDisk.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 attach_mode: builtins.str,
                 device_id: Optional[builtins.str] = None,
                 existing_disk: Optional['outputs.ComputeV1InstanceSecondaryDiskExistingDisk'] = None):
        """
        :param builtins.str attach_mode: ### Supported values
               
               Possible values:
               
                - `UNSPECIFIED`
                - `READ_ONLY`
                - `READ_WRITE`
        :param builtins.str device_id: Specifies the user-defined identifier, allowing to use '/dev/disk/by-id/virtio-{device_id}' as a device path in mount command.
        """
        pulumi.set(__self__, "attach_mode", attach_mode)
        if device_id is not None:
            pulumi.set(__self__, "device_id", device_id)
        if existing_disk is not None:
            pulumi.set(__self__, "existing_disk", existing_disk)

    @property
    @pulumi.getter(name="attachMode")
    def attach_mode(self) -> builtins.str:
        """
        ### Supported values

        Possible values:

         - `UNSPECIFIED`
         - `READ_ONLY`
         - `READ_WRITE`
        """
        return pulumi.get(self, "attach_mode")

    @property
    @pulumi.getter(name="deviceId")
    def device_id(self) -> Optional[builtins.str]:
        """
        Specifies the user-defined identifier, allowing to use '/dev/disk/by-id/virtio-{device_id}' as a device path in mount command.
        """
        return pulumi.get(self, "device_id")

    @property
    @pulumi.getter(name="existingDisk")
    def existing_disk(self) -> Optional['outputs.ComputeV1InstanceSecondaryDiskExistingDisk']:
        return pulumi.get(self, "existing_disk")


@pulumi.output_type
class ComputeV1InstanceSecondaryDiskExistingDisk(dict):
    def __init__(__self__, *,
                 id: builtins.str):
        pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> builtins.str:
        return pulumi.get(self, "id")


@pulumi.output_type
class ComputeV1InstanceStatus(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "infinibandTopologyPath":
            suggest = "infiniband_topology_path"
        elif key == "maintenanceEventId":
            suggest = "maintenance_event_id"
        elif key == "networkInterfaces":
            suggest = "network_interfaces"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ComputeV1InstanceStatus. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ComputeV1InstanceStatus.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ComputeV1InstanceStatus.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 infiniband_topology_path: Optional['outputs.ComputeV1InstanceStatusInfinibandTopologyPath'] = None,
                 maintenance_event_id: Optional[builtins.str] = None,
                 network_interfaces: Optional[Sequence['outputs.ComputeV1InstanceStatusNetworkInterface']] = None,
                 reconciling: Optional[builtins.bool] = None,
                 state: Optional[builtins.str] = None):
        """
        :param Sequence['ComputeV1InstanceStatusNetworkInterfaceArgs'] network_interfaces: ### Inner value description
               
               Describes the status of a network interface.
        :param builtins.bool reconciling: Indicates whether there is an ongoing operation
        :param builtins.str state: ### Supported values
               
               Possible values:
               
                - `UNSPECIFIED`
                - `CREATING`
                - `UPDATING`
                - `STARTING`
                - `RUNNING`
                - `STOPPING`
                - `STOPPED`
                - `DELETING`
                - `ERROR`
        """
        if infiniband_topology_path is not None:
            pulumi.set(__self__, "infiniband_topology_path", infiniband_topology_path)
        if maintenance_event_id is not None:
            pulumi.set(__self__, "maintenance_event_id", maintenance_event_id)
        if network_interfaces is not None:
            pulumi.set(__self__, "network_interfaces", network_interfaces)
        if reconciling is not None:
            pulumi.set(__self__, "reconciling", reconciling)
        if state is not None:
            pulumi.set(__self__, "state", state)

    @property
    @pulumi.getter(name="infinibandTopologyPath")
    def infiniband_topology_path(self) -> Optional['outputs.ComputeV1InstanceStatusInfinibandTopologyPath']:
        return pulumi.get(self, "infiniband_topology_path")

    @property
    @pulumi.getter(name="maintenanceEventId")
    def maintenance_event_id(self) -> Optional[builtins.str]:
        return pulumi.get(self, "maintenance_event_id")

    @property
    @pulumi.getter(name="networkInterfaces")
    def network_interfaces(self) -> Optional[Sequence['outputs.ComputeV1InstanceStatusNetworkInterface']]:
        """
        ### Inner value description

        Describes the status of a network interface.
        """
        return pulumi.get(self, "network_interfaces")

    @property
    @pulumi.getter
    def reconciling(self) -> Optional[builtins.bool]:
        """
        Indicates whether there is an ongoing operation
        """
        return pulumi.get(self, "reconciling")

    @property
    @pulumi.getter
    def state(self) -> Optional[builtins.str]:
        """
        ### Supported values

        Possible values:

         - `UNSPECIFIED`
         - `CREATING`
         - `UPDATING`
         - `STARTING`
         - `RUNNING`
         - `STOPPING`
         - `STOPPED`
         - `DELETING`
         - `ERROR`
        """
        return pulumi.get(self, "state")


@pulumi.output_type
class ComputeV1InstanceStatusInfinibandTopologyPath(dict):
    def __init__(__self__, *,
                 paths: Optional[Sequence[builtins.str]] = None):
        if paths is not None:
            pulumi.set(__self__, "paths", paths)

    @property
    @pulumi.getter
    def paths(self) -> Optional[Sequence[builtins.str]]:
        return pulumi.get(self, "paths")


@pulumi.output_type
class ComputeV1InstanceStatusNetworkInterface(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "ipAddress":
            suggest = "ip_address"
        elif key == "macAddress":
            suggest = "mac_address"
        elif key == "publicIpAddress":
            suggest = "public_ip_address"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ComputeV1InstanceStatusNetworkInterface. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ComputeV1InstanceStatusNetworkInterface.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ComputeV1InstanceStatusNetworkInterface.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 index: Optional[builtins.float] = None,
                 ip_address: Optional['outputs.ComputeV1InstanceStatusNetworkInterfaceIpAddress'] = None,
                 mac_address: Optional[builtins.str] = None,
                 name: Optional[builtins.str] = None,
                 public_ip_address: Optional['outputs.ComputeV1InstanceStatusNetworkInterfacePublicIpAddress'] = None):
        """
        :param builtins.float index: The index of the network interface
        :param 'ComputeV1InstanceStatusNetworkInterfaceIpAddressArgs' ip_address: Effective Private IPv4 address
        :param builtins.str mac_address: MAC address
        :param builtins.str name: Name for interface.
               Unique within instance's network interfaces
        :param 'ComputeV1InstanceStatusNetworkInterfacePublicIpAddressArgs' public_ip_address: Effective Public IPv4 address
        """
        if index is not None:
            pulumi.set(__self__, "index", index)
        if ip_address is not None:
            pulumi.set(__self__, "ip_address", ip_address)
        if mac_address is not None:
            pulumi.set(__self__, "mac_address", mac_address)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if public_ip_address is not None:
            pulumi.set(__self__, "public_ip_address", public_ip_address)

    @property
    @pulumi.getter
    def index(self) -> Optional[builtins.float]:
        """
        The index of the network interface
        """
        return pulumi.get(self, "index")

    @property
    @pulumi.getter(name="ipAddress")
    def ip_address(self) -> Optional['outputs.ComputeV1InstanceStatusNetworkInterfaceIpAddress']:
        """
        Effective Private IPv4 address
        """
        return pulumi.get(self, "ip_address")

    @property
    @pulumi.getter(name="macAddress")
    def mac_address(self) -> Optional[builtins.str]:
        """
        MAC address
        """
        return pulumi.get(self, "mac_address")

    @property
    @pulumi.getter
    def name(self) -> Optional[builtins.str]:
        """
        Name for interface.
        Unique within instance's network interfaces
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="publicIpAddress")
    def public_ip_address(self) -> Optional['outputs.ComputeV1InstanceStatusNetworkInterfacePublicIpAddress']:
        """
        Effective Public IPv4 address
        """
        return pulumi.get(self, "public_ip_address")


@pulumi.output_type
class ComputeV1InstanceStatusNetworkInterfaceIpAddress(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "allocationId":
            suggest = "allocation_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ComputeV1InstanceStatusNetworkInterfaceIpAddress. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ComputeV1InstanceStatusNetworkInterfaceIpAddress.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ComputeV1InstanceStatusNetworkInterfaceIpAddress.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 address: Optional[builtins.str] = None,
                 allocation_id: Optional[builtins.str] = None):
        """
        :param builtins.str address: Effective private IPv4 address assigned to the interface.
        :param builtins.str allocation_id: Allocation identifier.
        """
        if address is not None:
            pulumi.set(__self__, "address", address)
        if allocation_id is not None:
            pulumi.set(__self__, "allocation_id", allocation_id)

    @property
    @pulumi.getter
    def address(self) -> Optional[builtins.str]:
        """
        Effective private IPv4 address assigned to the interface.
        """
        return pulumi.get(self, "address")

    @property
    @pulumi.getter(name="allocationId")
    def allocation_id(self) -> Optional[builtins.str]:
        """
        Allocation identifier.
        """
        return pulumi.get(self, "allocation_id")


@pulumi.output_type
class ComputeV1InstanceStatusNetworkInterfacePublicIpAddress(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "allocationId":
            suggest = "allocation_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ComputeV1InstanceStatusNetworkInterfacePublicIpAddress. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ComputeV1InstanceStatusNetworkInterfacePublicIpAddress.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ComputeV1InstanceStatusNetworkInterfacePublicIpAddress.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 address: Optional[builtins.str] = None,
                 allocation_id: Optional[builtins.str] = None,
                 static: Optional[builtins.bool] = None):
        """
        :param builtins.str address: Effective public IPv4 address assigned to the interface.
        :param builtins.str allocation_id: Allocation identifier.
        :param builtins.bool static: If false - Allocation will be created/deleted during NetworkInterface.Allocate/NetworkInterface.Deallocate
               If true  - Allocation will be created/deleted during NetworkInterface.Create/NetworkInterface.Delete
               False by default
        """
        if address is not None:
            pulumi.set(__self__, "address", address)
        if allocation_id is not None:
            pulumi.set(__self__, "allocation_id", allocation_id)
        if static is not None:
            pulumi.set(__self__, "static", static)

    @property
    @pulumi.getter
    def address(self) -> Optional[builtins.str]:
        """
        Effective public IPv4 address assigned to the interface.
        """
        return pulumi.get(self, "address")

    @property
    @pulumi.getter(name="allocationId")
    def allocation_id(self) -> Optional[builtins.str]:
        """
        Allocation identifier.
        """
        return pulumi.get(self, "allocation_id")

    @property
    @pulumi.getter
    def static(self) -> Optional[builtins.bool]:
        """
        If false - Allocation will be created/deleted during NetworkInterface.Allocate/NetworkInterface.Deallocate
        If true  - Allocation will be created/deleted during NetworkInterface.Create/NetworkInterface.Delete
        False by default
        """
        return pulumi.get(self, "static")


@pulumi.output_type
class ComputeV1alpha1DiskMetadata(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class ComputeV1alpha1DiskPlacementPolicy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "placementGroupId":
            suggest = "placement_group_id"
        elif key == "placementGroupPartition":
            suggest = "placement_group_partition"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ComputeV1alpha1DiskPlacementPolicy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ComputeV1alpha1DiskPlacementPolicy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ComputeV1alpha1DiskPlacementPolicy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 placement_group_id: Optional[builtins.str] = None,
                 placement_group_partition: Optional[builtins.float] = None):
        if placement_group_id is not None:
            pulumi.set(__self__, "placement_group_id", placement_group_id)
        if placement_group_partition is not None:
            pulumi.set(__self__, "placement_group_partition", placement_group_partition)

    @property
    @pulumi.getter(name="placementGroupId")
    def placement_group_id(self) -> Optional[builtins.str]:
        return pulumi.get(self, "placement_group_id")

    @property
    @pulumi.getter(name="placementGroupPartition")
    def placement_group_partition(self) -> Optional[builtins.float]:
        return pulumi.get(self, "placement_group_partition")


@pulumi.output_type
class ComputeV1alpha1DiskStatus(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "readOnlyAttachments":
            suggest = "read_only_attachments"
        elif key == "readWriteAttachment":
            suggest = "read_write_attachment"
        elif key == "sizeBytes":
            suggest = "size_bytes"
        elif key == "sourceImageId":
            suggest = "source_image_id"
        elif key == "stateDescription":
            suggest = "state_description"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ComputeV1alpha1DiskStatus. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ComputeV1alpha1DiskStatus.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ComputeV1alpha1DiskStatus.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 read_only_attachments: Optional[Sequence[builtins.str]] = None,
                 read_write_attachment: Optional[builtins.str] = None,
                 reconciling: Optional[builtins.bool] = None,
                 size_bytes: Optional[builtins.float] = None,
                 source_image_id: Optional[builtins.str] = None,
                 state: Optional[builtins.str] = None,
                 state_description: Optional[builtins.str] = None):
        """
        :param builtins.bool reconciling: Indicates whether there is an ongoing operation
        :param builtins.str state: ### Supported values
               
               Possible values:
               
                - `UNSPECIFIED`
                - `CREATING`
                - `READY`
                - `UPDATING`
                - `DELETING`
                - `ERROR`
        """
        if read_only_attachments is not None:
            pulumi.set(__self__, "read_only_attachments", read_only_attachments)
        if read_write_attachment is not None:
            pulumi.set(__self__, "read_write_attachment", read_write_attachment)
        if reconciling is not None:
            pulumi.set(__self__, "reconciling", reconciling)
        if size_bytes is not None:
            pulumi.set(__self__, "size_bytes", size_bytes)
        if source_image_id is not None:
            pulumi.set(__self__, "source_image_id", source_image_id)
        if state is not None:
            pulumi.set(__self__, "state", state)
        if state_description is not None:
            pulumi.set(__self__, "state_description", state_description)

    @property
    @pulumi.getter(name="readOnlyAttachments")
    def read_only_attachments(self) -> Optional[Sequence[builtins.str]]:
        return pulumi.get(self, "read_only_attachments")

    @property
    @pulumi.getter(name="readWriteAttachment")
    def read_write_attachment(self) -> Optional[builtins.str]:
        return pulumi.get(self, "read_write_attachment")

    @property
    @pulumi.getter
    def reconciling(self) -> Optional[builtins.bool]:
        """
        Indicates whether there is an ongoing operation
        """
        return pulumi.get(self, "reconciling")

    @property
    @pulumi.getter(name="sizeBytes")
    def size_bytes(self) -> Optional[builtins.float]:
        return pulumi.get(self, "size_bytes")

    @property
    @pulumi.getter(name="sourceImageId")
    def source_image_id(self) -> Optional[builtins.str]:
        return pulumi.get(self, "source_image_id")

    @property
    @pulumi.getter
    def state(self) -> Optional[builtins.str]:
        """
        ### Supported values

        Possible values:

         - `UNSPECIFIED`
         - `CREATING`
         - `READY`
         - `UPDATING`
         - `DELETING`
         - `ERROR`
        """
        return pulumi.get(self, "state")

    @property
    @pulumi.getter(name="stateDescription")
    def state_description(self) -> Optional[builtins.str]:
        return pulumi.get(self, "state_description")


@pulumi.output_type
class ComputeV1alpha1FilesystemMetadata(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class ComputeV1alpha1FilesystemStatus(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "readOnlyAttachments":
            suggest = "read_only_attachments"
        elif key == "readWriteAttachments":
            suggest = "read_write_attachments"
        elif key == "sizeBytes":
            suggest = "size_bytes"
        elif key == "stateDescription":
            suggest = "state_description"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ComputeV1alpha1FilesystemStatus. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ComputeV1alpha1FilesystemStatus.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ComputeV1alpha1FilesystemStatus.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 read_only_attachments: Optional[Sequence[builtins.str]] = None,
                 read_write_attachments: Optional[Sequence[builtins.str]] = None,
                 reconciling: Optional[builtins.bool] = None,
                 size_bytes: Optional[builtins.float] = None,
                 state: Optional[builtins.str] = None,
                 state_description: Optional[builtins.str] = None):
        """
        :param builtins.bool reconciling: Indicates whether there is an ongoing operation
        :param builtins.str state: ### Supported values
               
               Possible values:
               
                - `UNSPECIFIED`
                - `CREATING`
                - `READY`
                - `UPDATING`
                - `DELETING`
                - `ERROR`
        """
        if read_only_attachments is not None:
            pulumi.set(__self__, "read_only_attachments", read_only_attachments)
        if read_write_attachments is not None:
            pulumi.set(__self__, "read_write_attachments", read_write_attachments)
        if reconciling is not None:
            pulumi.set(__self__, "reconciling", reconciling)
        if size_bytes is not None:
            pulumi.set(__self__, "size_bytes", size_bytes)
        if state is not None:
            pulumi.set(__self__, "state", state)
        if state_description is not None:
            pulumi.set(__self__, "state_description", state_description)

    @property
    @pulumi.getter(name="readOnlyAttachments")
    def read_only_attachments(self) -> Optional[Sequence[builtins.str]]:
        return pulumi.get(self, "read_only_attachments")

    @property
    @pulumi.getter(name="readWriteAttachments")
    def read_write_attachments(self) -> Optional[Sequence[builtins.str]]:
        return pulumi.get(self, "read_write_attachments")

    @property
    @pulumi.getter
    def reconciling(self) -> Optional[builtins.bool]:
        """
        Indicates whether there is an ongoing operation
        """
        return pulumi.get(self, "reconciling")

    @property
    @pulumi.getter(name="sizeBytes")
    def size_bytes(self) -> Optional[builtins.float]:
        return pulumi.get(self, "size_bytes")

    @property
    @pulumi.getter
    def state(self) -> Optional[builtins.str]:
        """
        ### Supported values

        Possible values:

         - `UNSPECIFIED`
         - `CREATING`
         - `READY`
         - `UPDATING`
         - `DELETING`
         - `ERROR`
        """
        return pulumi.get(self, "state")

    @property
    @pulumi.getter(name="stateDescription")
    def state_description(self) -> Optional[builtins.str]:
        return pulumi.get(self, "state_description")


@pulumi.output_type
class ComputeV1alpha1GpuClusterMetadata(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class ComputeV1alpha1GpuClusterStatus(dict):
    def __init__(__self__, *,
                 instances: Optional[Sequence[builtins.str]] = None,
                 reconciling: Optional[builtins.bool] = None):
        """
        :param builtins.bool reconciling: Indicates whether there is an ongoing operation
        """
        if instances is not None:
            pulumi.set(__self__, "instances", instances)
        if reconciling is not None:
            pulumi.set(__self__, "reconciling", reconciling)

    @property
    @pulumi.getter
    def instances(self) -> Optional[Sequence[builtins.str]]:
        return pulumi.get(self, "instances")

    @property
    @pulumi.getter
    def reconciling(self) -> Optional[builtins.bool]:
        """
        Indicates whether there is an ongoing operation
        """
        return pulumi.get(self, "reconciling")


@pulumi.output_type
class ComputeV1alpha1InstanceBootDisk(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "attachMode":
            suggest = "attach_mode"
        elif key == "deviceName":
            suggest = "device_name"
        elif key == "existingDisk":
            suggest = "existing_disk"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ComputeV1alpha1InstanceBootDisk. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ComputeV1alpha1InstanceBootDisk.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ComputeV1alpha1InstanceBootDisk.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 attach_mode: builtins.str,
                 device_name: Optional[builtins.str] = None,
                 existing_disk: Optional['outputs.ComputeV1alpha1InstanceBootDiskExistingDisk'] = None):
        """
        :param builtins.str attach_mode: ### Supported values
               
               Possible values:
               
                - `UNSPECIFIED`
                - `READ_ONLY`
                - `READ_WRITE`
        :param builtins.str device_name: Specifies the user-defined identifier, allowing to use '/dev/disk/by-id/virtio-{device_name}' as a device path in mount command.
        """
        pulumi.set(__self__, "attach_mode", attach_mode)
        if device_name is not None:
            pulumi.set(__self__, "device_name", device_name)
        if existing_disk is not None:
            pulumi.set(__self__, "existing_disk", existing_disk)

    @property
    @pulumi.getter(name="attachMode")
    def attach_mode(self) -> builtins.str:
        """
        ### Supported values

        Possible values:

         - `UNSPECIFIED`
         - `READ_ONLY`
         - `READ_WRITE`
        """
        return pulumi.get(self, "attach_mode")

    @property
    @pulumi.getter(name="deviceName")
    def device_name(self) -> Optional[builtins.str]:
        """
        Specifies the user-defined identifier, allowing to use '/dev/disk/by-id/virtio-{device_name}' as a device path in mount command.
        """
        return pulumi.get(self, "device_name")

    @property
    @pulumi.getter(name="existingDisk")
    def existing_disk(self) -> Optional['outputs.ComputeV1alpha1InstanceBootDiskExistingDisk']:
        return pulumi.get(self, "existing_disk")


@pulumi.output_type
class ComputeV1alpha1InstanceBootDiskExistingDisk(dict):
    def __init__(__self__, *,
                 id: builtins.str):
        pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> builtins.str:
        return pulumi.get(self, "id")


@pulumi.output_type
class ComputeV1alpha1InstanceFilesystem(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "attachMode":
            suggest = "attach_mode"
        elif key == "deviceName":
            suggest = "device_name"
        elif key == "existingFilesystem":
            suggest = "existing_filesystem"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ComputeV1alpha1InstanceFilesystem. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ComputeV1alpha1InstanceFilesystem.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ComputeV1alpha1InstanceFilesystem.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 attach_mode: builtins.str,
                 device_name: builtins.str,
                 existing_filesystem: Optional['outputs.ComputeV1alpha1InstanceFilesystemExistingFilesystem'] = None):
        """
        :param builtins.str attach_mode: ### Supported values
               
               Possible values:
               
                - `UNSPECIFIED`
                - `READ_ONLY`
                - `READ_WRITE`
        :param builtins.str device_name: Specifies the user-defined identifier, allowing to use it as a device in mount command.
        """
        pulumi.set(__self__, "attach_mode", attach_mode)
        pulumi.set(__self__, "device_name", device_name)
        if existing_filesystem is not None:
            pulumi.set(__self__, "existing_filesystem", existing_filesystem)

    @property
    @pulumi.getter(name="attachMode")
    def attach_mode(self) -> builtins.str:
        """
        ### Supported values

        Possible values:

         - `UNSPECIFIED`
         - `READ_ONLY`
         - `READ_WRITE`
        """
        return pulumi.get(self, "attach_mode")

    @property
    @pulumi.getter(name="deviceName")
    def device_name(self) -> builtins.str:
        """
        Specifies the user-defined identifier, allowing to use it as a device in mount command.
        """
        return pulumi.get(self, "device_name")

    @property
    @pulumi.getter(name="existingFilesystem")
    def existing_filesystem(self) -> Optional['outputs.ComputeV1alpha1InstanceFilesystemExistingFilesystem']:
        return pulumi.get(self, "existing_filesystem")


@pulumi.output_type
class ComputeV1alpha1InstanceFilesystemExistingFilesystem(dict):
    def __init__(__self__, *,
                 id: builtins.str):
        pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> builtins.str:
        return pulumi.get(self, "id")


@pulumi.output_type
class ComputeV1alpha1InstanceGpuCluster(dict):
    def __init__(__self__, *,
                 id: Optional[builtins.str] = None):
        if id is not None:
            pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> Optional[builtins.str]:
        return pulumi.get(self, "id")


@pulumi.output_type
class ComputeV1alpha1InstanceMetadata(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class ComputeV1alpha1InstanceNetworkInterface(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "subnetId":
            suggest = "subnet_id"
        elif key == "ipAddress":
            suggest = "ip_address"
        elif key == "publicIpAddress":
            suggest = "public_ip_address"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ComputeV1alpha1InstanceNetworkInterface. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ComputeV1alpha1InstanceNetworkInterface.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ComputeV1alpha1InstanceNetworkInterface.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: builtins.str,
                 subnet_id: builtins.str,
                 ip_address: Optional['outputs.ComputeV1alpha1InstanceNetworkInterfaceIpAddress'] = None,
                 public_ip_address: Optional['outputs.ComputeV1alpha1InstanceNetworkInterfacePublicIpAddress'] = None):
        """
        :param builtins.str name: Interface name
               Value of this field configures the name of the network interface inside VM's OS.
               Longer values will persist in the specification but will be truncated to 15 symbols before being passed to VM configuration.
        :param builtins.str subnet_id: Subnet ID
        :param 'ComputeV1alpha1InstanceNetworkInterfaceIpAddressArgs' ip_address: Private IPv4 address associated with the interface.
               
               ### Inner value description
               
               Describes an IPv4 address.
        :param 'ComputeV1alpha1InstanceNetworkInterfacePublicIpAddressArgs' public_ip_address: Public IPv4 address associated with the interface.
               
               ### Inner value description
               
               Describes a public IP address.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "subnet_id", subnet_id)
        if ip_address is not None:
            pulumi.set(__self__, "ip_address", ip_address)
        if public_ip_address is not None:
            pulumi.set(__self__, "public_ip_address", public_ip_address)

    @property
    @pulumi.getter
    def name(self) -> builtins.str:
        """
        Interface name
        Value of this field configures the name of the network interface inside VM's OS.
        Longer values will persist in the specification but will be truncated to 15 symbols before being passed to VM configuration.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="subnetId")
    def subnet_id(self) -> builtins.str:
        """
        Subnet ID
        """
        return pulumi.get(self, "subnet_id")

    @property
    @pulumi.getter(name="ipAddress")
    def ip_address(self) -> Optional['outputs.ComputeV1alpha1InstanceNetworkInterfaceIpAddress']:
        """
        Private IPv4 address associated with the interface.

        ### Inner value description

        Describes an IPv4 address.
        """
        return pulumi.get(self, "ip_address")

    @property
    @pulumi.getter(name="publicIpAddress")
    def public_ip_address(self) -> Optional['outputs.ComputeV1alpha1InstanceNetworkInterfacePublicIpAddress']:
        """
        Public IPv4 address associated with the interface.

        ### Inner value description

        Describes a public IP address.
        """
        return pulumi.get(self, "public_ip_address")


@pulumi.output_type
class ComputeV1alpha1InstanceNetworkInterfaceIpAddress(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "allocationId":
            suggest = "allocation_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ComputeV1alpha1InstanceNetworkInterfaceIpAddress. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ComputeV1alpha1InstanceNetworkInterfaceIpAddress.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ComputeV1alpha1InstanceNetworkInterfaceIpAddress.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 allocation_id: Optional[builtins.str] = None):
        """
        :param builtins.str allocation_id: Allocation identifier if it was created before.
        """
        if allocation_id is not None:
            pulumi.set(__self__, "allocation_id", allocation_id)

    @property
    @pulumi.getter(name="allocationId")
    def allocation_id(self) -> Optional[builtins.str]:
        """
        Allocation identifier if it was created before.
        """
        return pulumi.get(self, "allocation_id")


@pulumi.output_type
class ComputeV1alpha1InstanceNetworkInterfacePublicIpAddress(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "allocationId":
            suggest = "allocation_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ComputeV1alpha1InstanceNetworkInterfacePublicIpAddress. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ComputeV1alpha1InstanceNetworkInterfacePublicIpAddress.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ComputeV1alpha1InstanceNetworkInterfacePublicIpAddress.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 allocation_id: Optional[builtins.str] = None,
                 static: Optional[builtins.bool] = None):
        """
        :param builtins.str allocation_id: Allocation identifier if it was created before.
        :param builtins.bool static: If false - Lifecycle of allocation depends on NetworkInterface.Allocate/NetworkInterface.Deallocate
               If true  - Lifecycle of allocation depends on NetworkInterface.Create/NetworkInterface.Delete
               False by default
        """
        if allocation_id is not None:
            pulumi.set(__self__, "allocation_id", allocation_id)
        if static is not None:
            pulumi.set(__self__, "static", static)

    @property
    @pulumi.getter(name="allocationId")
    def allocation_id(self) -> Optional[builtins.str]:
        """
        Allocation identifier if it was created before.
        """
        return pulumi.get(self, "allocation_id")

    @property
    @pulumi.getter
    def static(self) -> Optional[builtins.bool]:
        """
        If false - Lifecycle of allocation depends on NetworkInterface.Allocate/NetworkInterface.Deallocate
        If true  - Lifecycle of allocation depends on NetworkInterface.Create/NetworkInterface.Delete
        False by default
        """
        return pulumi.get(self, "static")


@pulumi.output_type
class ComputeV1alpha1InstanceResources(dict):
    def __init__(__self__, *,
                 platform: builtins.str,
                 preset: Optional[builtins.str] = None):
        pulumi.set(__self__, "platform", platform)
        if preset is not None:
            pulumi.set(__self__, "preset", preset)

    @property
    @pulumi.getter
    def platform(self) -> builtins.str:
        return pulumi.get(self, "platform")

    @property
    @pulumi.getter
    def preset(self) -> Optional[builtins.str]:
        return pulumi.get(self, "preset")


@pulumi.output_type
class ComputeV1alpha1InstanceSecondaryDisk(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "attachMode":
            suggest = "attach_mode"
        elif key == "deviceName":
            suggest = "device_name"
        elif key == "existingDisk":
            suggest = "existing_disk"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ComputeV1alpha1InstanceSecondaryDisk. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ComputeV1alpha1InstanceSecondaryDisk.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ComputeV1alpha1InstanceSecondaryDisk.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 attach_mode: builtins.str,
                 device_name: Optional[builtins.str] = None,
                 existing_disk: Optional['outputs.ComputeV1alpha1InstanceSecondaryDiskExistingDisk'] = None):
        """
        :param builtins.str attach_mode: ### Supported values
               
               Possible values:
               
                - `UNSPECIFIED`
                - `READ_ONLY`
                - `READ_WRITE`
        :param builtins.str device_name: Specifies the user-defined identifier, allowing to use '/dev/disk/by-id/virtio-{device_name}' as a device path in mount command.
        """
        pulumi.set(__self__, "attach_mode", attach_mode)
        if device_name is not None:
            pulumi.set(__self__, "device_name", device_name)
        if existing_disk is not None:
            pulumi.set(__self__, "existing_disk", existing_disk)

    @property
    @pulumi.getter(name="attachMode")
    def attach_mode(self) -> builtins.str:
        """
        ### Supported values

        Possible values:

         - `UNSPECIFIED`
         - `READ_ONLY`
         - `READ_WRITE`
        """
        return pulumi.get(self, "attach_mode")

    @property
    @pulumi.getter(name="deviceName")
    def device_name(self) -> Optional[builtins.str]:
        """
        Specifies the user-defined identifier, allowing to use '/dev/disk/by-id/virtio-{device_name}' as a device path in mount command.
        """
        return pulumi.get(self, "device_name")

    @property
    @pulumi.getter(name="existingDisk")
    def existing_disk(self) -> Optional['outputs.ComputeV1alpha1InstanceSecondaryDiskExistingDisk']:
        return pulumi.get(self, "existing_disk")


@pulumi.output_type
class ComputeV1alpha1InstanceSecondaryDiskExistingDisk(dict):
    def __init__(__self__, *,
                 id: builtins.str):
        pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> builtins.str:
        return pulumi.get(self, "id")


@pulumi.output_type
class ComputeV1alpha1InstanceStatus(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "networkInterfaces":
            suggest = "network_interfaces"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ComputeV1alpha1InstanceStatus. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ComputeV1alpha1InstanceStatus.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ComputeV1alpha1InstanceStatus.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 network_interfaces: Optional[Sequence['outputs.ComputeV1alpha1InstanceStatusNetworkInterface']] = None,
                 reconciling: Optional[builtins.bool] = None,
                 state: Optional[builtins.str] = None):
        """
        :param Sequence['ComputeV1alpha1InstanceStatusNetworkInterfaceArgs'] network_interfaces: ### Inner value description
               
               Describes the status of a network interface.
        :param builtins.bool reconciling: Indicates whether there is an ongoing operation
        :param builtins.str state: ### Supported values
               
               Possible values:
               
                - `UNSPECIFIED`
                - `CREATING`
                - `UPDATING`
                - `STARTING`
                - `RUNNING`
                - `STOPPING`
                - `STOPPED`
                - `DELETING`
                - `ERROR`
        """
        if network_interfaces is not None:
            pulumi.set(__self__, "network_interfaces", network_interfaces)
        if reconciling is not None:
            pulumi.set(__self__, "reconciling", reconciling)
        if state is not None:
            pulumi.set(__self__, "state", state)

    @property
    @pulumi.getter(name="networkInterfaces")
    def network_interfaces(self) -> Optional[Sequence['outputs.ComputeV1alpha1InstanceStatusNetworkInterface']]:
        """
        ### Inner value description

        Describes the status of a network interface.
        """
        return pulumi.get(self, "network_interfaces")

    @property
    @pulumi.getter
    def reconciling(self) -> Optional[builtins.bool]:
        """
        Indicates whether there is an ongoing operation
        """
        return pulumi.get(self, "reconciling")

    @property
    @pulumi.getter
    def state(self) -> Optional[builtins.str]:
        """
        ### Supported values

        Possible values:

         - `UNSPECIFIED`
         - `CREATING`
         - `UPDATING`
         - `STARTING`
         - `RUNNING`
         - `STOPPING`
         - `STOPPED`
         - `DELETING`
         - `ERROR`
        """
        return pulumi.get(self, "state")


@pulumi.output_type
class ComputeV1alpha1InstanceStatusNetworkInterface(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "ipAddress":
            suggest = "ip_address"
        elif key == "macAddress":
            suggest = "mac_address"
        elif key == "publicIpAddress":
            suggest = "public_ip_address"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ComputeV1alpha1InstanceStatusNetworkInterface. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ComputeV1alpha1InstanceStatusNetworkInterface.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ComputeV1alpha1InstanceStatusNetworkInterface.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 index: Optional[builtins.float] = None,
                 ip_address: Optional['outputs.ComputeV1alpha1InstanceStatusNetworkInterfaceIpAddress'] = None,
                 mac_address: Optional[builtins.str] = None,
                 name: Optional[builtins.str] = None,
                 public_ip_address: Optional['outputs.ComputeV1alpha1InstanceStatusNetworkInterfacePublicIpAddress'] = None):
        """
        :param builtins.float index: The index of the network interface
        :param 'ComputeV1alpha1InstanceStatusNetworkInterfaceIpAddressArgs' ip_address: Effective Private IPv4 address
        :param builtins.str mac_address: MAC address
        :param builtins.str name: Name for interface.
               Unique within instance's network interfaces
        :param 'ComputeV1alpha1InstanceStatusNetworkInterfacePublicIpAddressArgs' public_ip_address: Effective Public IPv4 address
        """
        if index is not None:
            pulumi.set(__self__, "index", index)
        if ip_address is not None:
            pulumi.set(__self__, "ip_address", ip_address)
        if mac_address is not None:
            pulumi.set(__self__, "mac_address", mac_address)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if public_ip_address is not None:
            pulumi.set(__self__, "public_ip_address", public_ip_address)

    @property
    @pulumi.getter
    def index(self) -> Optional[builtins.float]:
        """
        The index of the network interface
        """
        return pulumi.get(self, "index")

    @property
    @pulumi.getter(name="ipAddress")
    def ip_address(self) -> Optional['outputs.ComputeV1alpha1InstanceStatusNetworkInterfaceIpAddress']:
        """
        Effective Private IPv4 address
        """
        return pulumi.get(self, "ip_address")

    @property
    @pulumi.getter(name="macAddress")
    def mac_address(self) -> Optional[builtins.str]:
        """
        MAC address
        """
        return pulumi.get(self, "mac_address")

    @property
    @pulumi.getter
    def name(self) -> Optional[builtins.str]:
        """
        Name for interface.
        Unique within instance's network interfaces
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="publicIpAddress")
    def public_ip_address(self) -> Optional['outputs.ComputeV1alpha1InstanceStatusNetworkInterfacePublicIpAddress']:
        """
        Effective Public IPv4 address
        """
        return pulumi.get(self, "public_ip_address")


@pulumi.output_type
class ComputeV1alpha1InstanceStatusNetworkInterfaceIpAddress(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "allocationId":
            suggest = "allocation_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ComputeV1alpha1InstanceStatusNetworkInterfaceIpAddress. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ComputeV1alpha1InstanceStatusNetworkInterfaceIpAddress.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ComputeV1alpha1InstanceStatusNetworkInterfaceIpAddress.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 address: Optional[builtins.str] = None,
                 allocation_id: Optional[builtins.str] = None):
        """
        :param builtins.str address: Effective private IPv4 address assigned to the interface.
        :param builtins.str allocation_id: Allocation identifier.
        """
        if address is not None:
            pulumi.set(__self__, "address", address)
        if allocation_id is not None:
            pulumi.set(__self__, "allocation_id", allocation_id)

    @property
    @pulumi.getter
    def address(self) -> Optional[builtins.str]:
        """
        Effective private IPv4 address assigned to the interface.
        """
        return pulumi.get(self, "address")

    @property
    @pulumi.getter(name="allocationId")
    def allocation_id(self) -> Optional[builtins.str]:
        """
        Allocation identifier.
        """
        return pulumi.get(self, "allocation_id")


@pulumi.output_type
class ComputeV1alpha1InstanceStatusNetworkInterfacePublicIpAddress(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "allocationId":
            suggest = "allocation_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ComputeV1alpha1InstanceStatusNetworkInterfacePublicIpAddress. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ComputeV1alpha1InstanceStatusNetworkInterfacePublicIpAddress.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ComputeV1alpha1InstanceStatusNetworkInterfacePublicIpAddress.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 address: Optional[builtins.str] = None,
                 allocation_id: Optional[builtins.str] = None):
        """
        :param builtins.str address: Effective public IPv4 address assigned to the interface.
        :param builtins.str allocation_id: Allocation identifier.
        """
        if address is not None:
            pulumi.set(__self__, "address", address)
        if allocation_id is not None:
            pulumi.set(__self__, "allocation_id", allocation_id)

    @property
    @pulumi.getter
    def address(self) -> Optional[builtins.str]:
        """
        Effective public IPv4 address assigned to the interface.
        """
        return pulumi.get(self, "address")

    @property
    @pulumi.getter(name="allocationId")
    def allocation_id(self) -> Optional[builtins.str]:
        """
        Allocation identifier.
        """
        return pulumi.get(self, "allocation_id")


@pulumi.output_type
class IamV1AccessPermitMetadata(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class IamV1AccessPermitStatus(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class IamV1AuthPublicKeyAccount(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "anonymousAccount":
            suggest = "anonymous_account"
        elif key == "serviceAccount":
            suggest = "service_account"
        elif key == "userAccount":
            suggest = "user_account"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in IamV1AuthPublicKeyAccount. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        IamV1AuthPublicKeyAccount.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        IamV1AuthPublicKeyAccount.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 anonymous_account: Optional['outputs.IamV1AuthPublicKeyAccountAnonymousAccount'] = None,
                 service_account: Optional['outputs.IamV1AuthPublicKeyAccountServiceAccount'] = None,
                 user_account: Optional['outputs.IamV1AuthPublicKeyAccountUserAccount'] = None):
        """
        :param 'IamV1AuthPublicKeyAccountAnonymousAccountArgs' anonymous_account: *Cannot be set alongside  or service_account.*
        :param 'IamV1AuthPublicKeyAccountServiceAccountArgs' service_account: *Cannot be set alongside  or anonymous_account.*
        :param 'IamV1AuthPublicKeyAccountUserAccountArgs' user_account: *Cannot be set alongside  or anonymous_account.*
        """
        if anonymous_account is not None:
            pulumi.set(__self__, "anonymous_account", anonymous_account)
        if service_account is not None:
            pulumi.set(__self__, "service_account", service_account)
        if user_account is not None:
            pulumi.set(__self__, "user_account", user_account)

    @property
    @pulumi.getter(name="anonymousAccount")
    def anonymous_account(self) -> Optional['outputs.IamV1AuthPublicKeyAccountAnonymousAccount']:
        """
        *Cannot be set alongside  or service_account.*
        """
        return pulumi.get(self, "anonymous_account")

    @property
    @pulumi.getter(name="serviceAccount")
    def service_account(self) -> Optional['outputs.IamV1AuthPublicKeyAccountServiceAccount']:
        """
        *Cannot be set alongside  or anonymous_account.*
        """
        return pulumi.get(self, "service_account")

    @property
    @pulumi.getter(name="userAccount")
    def user_account(self) -> Optional['outputs.IamV1AuthPublicKeyAccountUserAccount']:
        """
        *Cannot be set alongside  or anonymous_account.*
        """
        return pulumi.get(self, "user_account")


@pulumi.output_type
class IamV1AuthPublicKeyAccountAnonymousAccount(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class IamV1AuthPublicKeyAccountServiceAccount(dict):
    def __init__(__self__, *,
                 id: Optional[builtins.str] = None):
        if id is not None:
            pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> Optional[builtins.str]:
        return pulumi.get(self, "id")


@pulumi.output_type
class IamV1AuthPublicKeyAccountUserAccount(dict):
    def __init__(__self__, *,
                 id: Optional[builtins.str] = None):
        if id is not None:
            pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> Optional[builtins.str]:
        return pulumi.get(self, "id")


@pulumi.output_type
class IamV1AuthPublicKeyMetadata(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class IamV1AuthPublicKeyStatus(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "keySize":
            suggest = "key_size"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in IamV1AuthPublicKeyStatus. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        IamV1AuthPublicKeyStatus.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        IamV1AuthPublicKeyStatus.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 algorithm: Optional[builtins.str] = None,
                 fingerprint: Optional[builtins.str] = None,
                 key_size: Optional[builtins.float] = None,
                 state: Optional[builtins.str] = None):
        """
        :param builtins.str state: ### Supported values
               
               Possible values:
               
                - `STATE_UNSPECIFIED`
                - `ACTIVE`
                - `INACTIVE`
                - `EXPIRED`
                - `DELETING`
                - `DELETED`
        """
        if algorithm is not None:
            pulumi.set(__self__, "algorithm", algorithm)
        if fingerprint is not None:
            pulumi.set(__self__, "fingerprint", fingerprint)
        if key_size is not None:
            pulumi.set(__self__, "key_size", key_size)
        if state is not None:
            pulumi.set(__self__, "state", state)

    @property
    @pulumi.getter
    def algorithm(self) -> Optional[builtins.str]:
        return pulumi.get(self, "algorithm")

    @property
    @pulumi.getter
    def fingerprint(self) -> Optional[builtins.str]:
        return pulumi.get(self, "fingerprint")

    @property
    @pulumi.getter(name="keySize")
    def key_size(self) -> Optional[builtins.float]:
        return pulumi.get(self, "key_size")

    @property
    @pulumi.getter
    def state(self) -> Optional[builtins.str]:
        """
        ### Supported values

        Possible values:

         - `STATE_UNSPECIFIED`
         - `ACTIVE`
         - `INACTIVE`
         - `EXPIRED`
         - `DELETING`
         - `DELETED`
        """
        return pulumi.get(self, "state")


@pulumi.output_type
class IamV1FederatedCredentialsMetadata(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class IamV1FederatedCredentialsOidcProvider(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "issuerUrl":
            suggest = "issuer_url"
        elif key == "jwkSetJson":
            suggest = "jwk_set_json"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in IamV1FederatedCredentialsOidcProvider. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        IamV1FederatedCredentialsOidcProvider.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        IamV1FederatedCredentialsOidcProvider.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 issuer_url: builtins.str,
                 jwk_set_json: Optional[builtins.str] = None):
        """
        :param builtins.str issuer_url: *
               It's not required provider OIDC issuer should be real OIDC provider, but should expose OIDC configuration
               with "/.well-known/openid-configuration" endpoint. Configuration should contains the "jwks_uri" endpoint
               where the JSON Web Key Set (JWKS) can be found; this set contains public keys used to verify
               JSON Web Tokens (JWTs) issued by an identity provider.
        :param builtins.str jwk_set_json: *
               Literally json, which represents JWKS with public keys for JWT verification
        """
        pulumi.set(__self__, "issuer_url", issuer_url)
        if jwk_set_json is not None:
            pulumi.set(__self__, "jwk_set_json", jwk_set_json)

    @property
    @pulumi.getter(name="issuerUrl")
    def issuer_url(self) -> builtins.str:
        """
        *
        It's not required provider OIDC issuer should be real OIDC provider, but should expose OIDC configuration
        with "/.well-known/openid-configuration" endpoint. Configuration should contains the "jwks_uri" endpoint
        where the JSON Web Key Set (JWKS) can be found; this set contains public keys used to verify
        JSON Web Tokens (JWTs) issued by an identity provider.
        """
        return pulumi.get(self, "issuer_url")

    @property
    @pulumi.getter(name="jwkSetJson")
    def jwk_set_json(self) -> Optional[builtins.str]:
        """
        *
        Literally json, which represents JWKS with public keys for JWT verification
        """
        return pulumi.get(self, "jwk_set_json")


@pulumi.output_type
class IamV1FederatedCredentialsStatus(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class IamV1FederationCertificateMetadata(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class IamV1FederationCertificateStatus(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "keySize":
            suggest = "key_size"
        elif key == "notAfter":
            suggest = "not_after"
        elif key == "notBefore":
            suggest = "not_before"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in IamV1FederationCertificateStatus. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        IamV1FederationCertificateStatus.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        IamV1FederationCertificateStatus.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 algorithm: Optional[builtins.str] = None,
                 key_size: Optional[builtins.float] = None,
                 not_after: Optional[builtins.str] = None,
                 not_before: Optional[builtins.str] = None,
                 state: Optional[builtins.str] = None):
        """
        :param builtins.str not_after: A string representing a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ` or `YYYY-MM-DDTHH:MM:SS.SSS±HH:MM`
        :param builtins.str not_before: A string representing a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ` or `YYYY-MM-DDTHH:MM:SS.SSS±HH:MM`
        :param builtins.str state: ### Supported values
               
               Possible values:
               
                - `STATE_UNSPECIFIED`
                - `ACTIVE`
                - `EXPIRED`
        """
        if algorithm is not None:
            pulumi.set(__self__, "algorithm", algorithm)
        if key_size is not None:
            pulumi.set(__self__, "key_size", key_size)
        if not_after is not None:
            pulumi.set(__self__, "not_after", not_after)
        if not_before is not None:
            pulumi.set(__self__, "not_before", not_before)
        if state is not None:
            pulumi.set(__self__, "state", state)

    @property
    @pulumi.getter
    def algorithm(self) -> Optional[builtins.str]:
        return pulumi.get(self, "algorithm")

    @property
    @pulumi.getter(name="keySize")
    def key_size(self) -> Optional[builtins.float]:
        return pulumi.get(self, "key_size")

    @property
    @pulumi.getter(name="notAfter")
    def not_after(self) -> Optional[builtins.str]:
        """
        A string representing a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ` or `YYYY-MM-DDTHH:MM:SS.SSS±HH:MM`
        """
        return pulumi.get(self, "not_after")

    @property
    @pulumi.getter(name="notBefore")
    def not_before(self) -> Optional[builtins.str]:
        """
        A string representing a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ` or `YYYY-MM-DDTHH:MM:SS.SSS±HH:MM`
        """
        return pulumi.get(self, "not_before")

    @property
    @pulumi.getter
    def state(self) -> Optional[builtins.str]:
        """
        ### Supported values

        Possible values:

         - `STATE_UNSPECIFIED`
         - `ACTIVE`
         - `EXPIRED`
        """
        return pulumi.get(self, "state")


@pulumi.output_type
class IamV1FederationMetadata(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class IamV1FederationSamlSettings(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "forceAuthn":
            suggest = "force_authn"
        elif key == "idpIssuer":
            suggest = "idp_issuer"
        elif key == "ssoUrl":
            suggest = "sso_url"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in IamV1FederationSamlSettings. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        IamV1FederationSamlSettings.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        IamV1FederationSamlSettings.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 force_authn: Optional[builtins.bool] = None,
                 idp_issuer: Optional[builtins.str] = None,
                 sso_url: Optional[builtins.str] = None):
        """
        :param builtins.bool force_authn: if "true", the identity provider MUST authenticate the presenter directly rather than rely on a previous security context.
        """
        if force_authn is not None:
            pulumi.set(__self__, "force_authn", force_authn)
        if idp_issuer is not None:
            pulumi.set(__self__, "idp_issuer", idp_issuer)
        if sso_url is not None:
            pulumi.set(__self__, "sso_url", sso_url)

    @property
    @pulumi.getter(name="forceAuthn")
    def force_authn(self) -> Optional[builtins.bool]:
        """
        if "true", the identity provider MUST authenticate the presenter directly rather than rely on a previous security context.
        """
        return pulumi.get(self, "force_authn")

    @property
    @pulumi.getter(name="idpIssuer")
    def idp_issuer(self) -> Optional[builtins.str]:
        return pulumi.get(self, "idp_issuer")

    @property
    @pulumi.getter(name="ssoUrl")
    def sso_url(self) -> Optional[builtins.str]:
        return pulumi.get(self, "sso_url")


@pulumi.output_type
class IamV1FederationStatus(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class IamV1GroupMembershipMetadata(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class IamV1GroupMembershipStatus(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class IamV1GroupMetadata(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class IamV1GroupStatus(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "membersCount":
            suggest = "members_count"
        elif key == "serviceAccountsCount":
            suggest = "service_accounts_count"
        elif key == "tenantUserAccountsCount":
            suggest = "tenant_user_accounts_count"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in IamV1GroupStatus. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        IamV1GroupStatus.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        IamV1GroupStatus.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 members_count: Optional[builtins.float] = None,
                 service_accounts_count: Optional[builtins.float] = None,
                 state: Optional[builtins.str] = None,
                 tenant_user_accounts_count: Optional[builtins.float] = None):
        """
        :param builtins.str state: ### Supported values
               
               Possible values:
               
                - `UNSPECIFIED`
                - `ACTIVE`
        """
        if members_count is not None:
            pulumi.set(__self__, "members_count", members_count)
        if service_accounts_count is not None:
            pulumi.set(__self__, "service_accounts_count", service_accounts_count)
        if state is not None:
            pulumi.set(__self__, "state", state)
        if tenant_user_accounts_count is not None:
            pulumi.set(__self__, "tenant_user_accounts_count", tenant_user_accounts_count)

    @property
    @pulumi.getter(name="membersCount")
    def members_count(self) -> Optional[builtins.float]:
        return pulumi.get(self, "members_count")

    @property
    @pulumi.getter(name="serviceAccountsCount")
    def service_accounts_count(self) -> Optional[builtins.float]:
        return pulumi.get(self, "service_accounts_count")

    @property
    @pulumi.getter
    def state(self) -> Optional[builtins.str]:
        """
        ### Supported values

        Possible values:

         - `UNSPECIFIED`
         - `ACTIVE`
        """
        return pulumi.get(self, "state")

    @property
    @pulumi.getter(name="tenantUserAccountsCount")
    def tenant_user_accounts_count(self) -> Optional[builtins.float]:
        return pulumi.get(self, "tenant_user_accounts_count")


@pulumi.output_type
class IamV1InvitationMetadata(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class IamV1InvitationStatus(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "expiresAt":
            suggest = "expires_at"
        elif key == "tenantUserAccountId":
            suggest = "tenant_user_account_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in IamV1InvitationStatus. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        IamV1InvitationStatus.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        IamV1InvitationStatus.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 expires_at: Optional[builtins.str] = None,
                 state: Optional[builtins.str] = None,
                 tenant_user_account_id: Optional[builtins.str] = None):
        """
        :param builtins.str expires_at: A string representing a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ` or `YYYY-MM-DDTHH:MM:SS.SSS±HH:MM`
        :param builtins.str state: ### Supported values
               
               Possible values:
               
                - `UNSPECIFIED`
                - `CREATING` - contacts data is not stored in pds yet. probably will GC it later
                - `CREATED` - notification is not sent yet
                - `PENDING` - notification is sent, we are waiting for the user to approve the notification
                - `EXPIRED` - notification is expired, accept is no longer possible
                - `ACCEPTED` - notification is accepted
        """
        if expires_at is not None:
            pulumi.set(__self__, "expires_at", expires_at)
        if state is not None:
            pulumi.set(__self__, "state", state)
        if tenant_user_account_id is not None:
            pulumi.set(__self__, "tenant_user_account_id", tenant_user_account_id)

    @property
    @pulumi.getter(name="expiresAt")
    def expires_at(self) -> Optional[builtins.str]:
        """
        A string representing a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ` or `YYYY-MM-DDTHH:MM:SS.SSS±HH:MM`
        """
        return pulumi.get(self, "expires_at")

    @property
    @pulumi.getter
    def state(self) -> Optional[builtins.str]:
        """
        ### Supported values

        Possible values:

         - `UNSPECIFIED`
         - `CREATING` - contacts data is not stored in pds yet. probably will GC it later
         - `CREATED` - notification is not sent yet
         - `PENDING` - notification is sent, we are waiting for the user to approve the notification
         - `EXPIRED` - notification is expired, accept is no longer possible
         - `ACCEPTED` - notification is accepted
        """
        return pulumi.get(self, "state")

    @property
    @pulumi.getter(name="tenantUserAccountId")
    def tenant_user_account_id(self) -> Optional[builtins.str]:
        return pulumi.get(self, "tenant_user_account_id")


@pulumi.output_type
class IamV1ServiceAccountMetadata(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class IamV1ServiceAccountStatus(dict):
    def __init__(__self__, *,
                 active: Optional[builtins.bool] = None):
        if active is not None:
            pulumi.set(__self__, "active", active)

    @property
    @pulumi.getter
    def active(self) -> Optional[builtins.bool]:
        return pulumi.get(self, "active")


@pulumi.output_type
class IamV2AccessKeyAccount(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "anonymousAccount":
            suggest = "anonymous_account"
        elif key == "serviceAccount":
            suggest = "service_account"
        elif key == "userAccount":
            suggest = "user_account"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in IamV2AccessKeyAccount. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        IamV2AccessKeyAccount.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        IamV2AccessKeyAccount.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 anonymous_account: Optional['outputs.IamV2AccessKeyAccountAnonymousAccount'] = None,
                 service_account: Optional['outputs.IamV2AccessKeyAccountServiceAccount'] = None,
                 user_account: Optional['outputs.IamV2AccessKeyAccountUserAccount'] = None):
        """
        :param 'IamV2AccessKeyAccountAnonymousAccountArgs' anonymous_account: *Cannot be set alongside  or service_account.*
        :param 'IamV2AccessKeyAccountServiceAccountArgs' service_account: *Cannot be set alongside  or anonymous_account.*
        :param 'IamV2AccessKeyAccountUserAccountArgs' user_account: *Cannot be set alongside  or anonymous_account.*
        """
        if anonymous_account is not None:
            pulumi.set(__self__, "anonymous_account", anonymous_account)
        if service_account is not None:
            pulumi.set(__self__, "service_account", service_account)
        if user_account is not None:
            pulumi.set(__self__, "user_account", user_account)

    @property
    @pulumi.getter(name="anonymousAccount")
    def anonymous_account(self) -> Optional['outputs.IamV2AccessKeyAccountAnonymousAccount']:
        """
        *Cannot be set alongside  or service_account.*
        """
        return pulumi.get(self, "anonymous_account")

    @property
    @pulumi.getter(name="serviceAccount")
    def service_account(self) -> Optional['outputs.IamV2AccessKeyAccountServiceAccount']:
        """
        *Cannot be set alongside  or anonymous_account.*
        """
        return pulumi.get(self, "service_account")

    @property
    @pulumi.getter(name="userAccount")
    def user_account(self) -> Optional['outputs.IamV2AccessKeyAccountUserAccount']:
        """
        *Cannot be set alongside  or anonymous_account.*
        """
        return pulumi.get(self, "user_account")


@pulumi.output_type
class IamV2AccessKeyAccountAnonymousAccount(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class IamV2AccessKeyAccountServiceAccount(dict):
    def __init__(__self__, *,
                 id: Optional[builtins.str] = None):
        if id is not None:
            pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> Optional[builtins.str]:
        return pulumi.get(self, "id")


@pulumi.output_type
class IamV2AccessKeyAccountUserAccount(dict):
    def __init__(__self__, *,
                 id: Optional[builtins.str] = None):
        if id is not None:
            pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> Optional[builtins.str]:
        return pulumi.get(self, "id")


@pulumi.output_type
class IamV2AccessKeyMetadata(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class IamV2AccessKeyStatus(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "awsAccessKeyId":
            suggest = "aws_access_key_id"
        elif key == "keySize":
            suggest = "key_size"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in IamV2AccessKeyStatus. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        IamV2AccessKeyStatus.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        IamV2AccessKeyStatus.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 algorithm: Optional[builtins.str] = None,
                 aws_access_key_id: Optional[builtins.str] = None,
                 fingerprint: Optional[builtins.str] = None,
                 key_size: Optional[builtins.float] = None,
                 secret: Optional[builtins.str] = None,
                 state: Optional[builtins.str] = None):
        """
        :param builtins.str state: ### Supported values
               
               Possible values:
               
                - `STATE_UNSPECIFIED`
                - `ACTIVE`
                - `INACTIVE`
                - `EXPIRED`
                - `DELETING`
                - `DELETED`
        """
        if algorithm is not None:
            pulumi.set(__self__, "algorithm", algorithm)
        if aws_access_key_id is not None:
            pulumi.set(__self__, "aws_access_key_id", aws_access_key_id)
        if fingerprint is not None:
            pulumi.set(__self__, "fingerprint", fingerprint)
        if key_size is not None:
            pulumi.set(__self__, "key_size", key_size)
        if secret is not None:
            pulumi.set(__self__, "secret", secret)
        if state is not None:
            pulumi.set(__self__, "state", state)

    @property
    @pulumi.getter
    def algorithm(self) -> Optional[builtins.str]:
        return pulumi.get(self, "algorithm")

    @property
    @pulumi.getter(name="awsAccessKeyId")
    def aws_access_key_id(self) -> Optional[builtins.str]:
        return pulumi.get(self, "aws_access_key_id")

    @property
    @pulumi.getter
    def fingerprint(self) -> Optional[builtins.str]:
        return pulumi.get(self, "fingerprint")

    @property
    @pulumi.getter(name="keySize")
    def key_size(self) -> Optional[builtins.float]:
        return pulumi.get(self, "key_size")

    @property
    @pulumi.getter
    def secret(self) -> Optional[builtins.str]:
        return pulumi.get(self, "secret")

    @property
    @pulumi.getter
    def state(self) -> Optional[builtins.str]:
        """
        ### Supported values

        Possible values:

         - `STATE_UNSPECIFIED`
         - `ACTIVE`
         - `INACTIVE`
         - `EXPIRED`
         - `DELETING`
         - `DELETED`
        """
        return pulumi.get(self, "state")


@pulumi.output_type
class Mk8sV1ClusterControlPlane(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "subnetId":
            suggest = "subnet_id"
        elif key == "etcdClusterSize":
            suggest = "etcd_cluster_size"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in Mk8sV1ClusterControlPlane. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        Mk8sV1ClusterControlPlane.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        Mk8sV1ClusterControlPlane.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 subnet_id: builtins.str,
                 endpoints: Optional['outputs.Mk8sV1ClusterControlPlaneEndpoints'] = None,
                 etcd_cluster_size: Optional[builtins.float] = None,
                 version: Optional[builtins.str] = None):
        """
        :param builtins.str subnet_id: Nebius VPC Subnet ID where control plane instances will be located.
               Also will be default NodeGroup subnet.
        :param builtins.float etcd_cluster_size: Number of instances in etcd cluster.
               3 by default.
               Control plane with `etcd_cluster_size: 3` called "Highly Available" ("HA"), because it's Kubernetes API
               will be available despite a failure of one control plane instance.
        :param builtins.str version: Desired Kubernetes version of the cluster. For now only acceptable format is
               `<major>.<minor>` like "1.30". Option for patch version update will be added later.
        """
        pulumi.set(__self__, "subnet_id", subnet_id)
        if endpoints is not None:
            pulumi.set(__self__, "endpoints", endpoints)
        if etcd_cluster_size is not None:
            pulumi.set(__self__, "etcd_cluster_size", etcd_cluster_size)
        if version is not None:
            pulumi.set(__self__, "version", version)

    @property
    @pulumi.getter(name="subnetId")
    def subnet_id(self) -> builtins.str:
        """
        Nebius VPC Subnet ID where control plane instances will be located.
        Also will be default NodeGroup subnet.
        """
        return pulumi.get(self, "subnet_id")

    @property
    @pulumi.getter
    def endpoints(self) -> Optional['outputs.Mk8sV1ClusterControlPlaneEndpoints']:
        return pulumi.get(self, "endpoints")

    @property
    @pulumi.getter(name="etcdClusterSize")
    def etcd_cluster_size(self) -> Optional[builtins.float]:
        """
        Number of instances in etcd cluster.
        3 by default.
        Control plane with `etcd_cluster_size: 3` called "Highly Available" ("HA"), because it's Kubernetes API
        will be available despite a failure of one control plane instance.
        """
        return pulumi.get(self, "etcd_cluster_size")

    @property
    @pulumi.getter
    def version(self) -> Optional[builtins.str]:
        """
        Desired Kubernetes version of the cluster. For now only acceptable format is
        `<major>.<minor>` like "1.30". Option for patch version update will be added later.
        """
        return pulumi.get(self, "version")


@pulumi.output_type
class Mk8sV1ClusterControlPlaneEndpoints(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "publicEndpoint":
            suggest = "public_endpoint"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in Mk8sV1ClusterControlPlaneEndpoints. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        Mk8sV1ClusterControlPlaneEndpoints.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        Mk8sV1ClusterControlPlaneEndpoints.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 public_endpoint: Optional['outputs.Mk8sV1ClusterControlPlaneEndpointsPublicEndpoint'] = None):
        """
        :param 'Mk8sV1ClusterControlPlaneEndpointsPublicEndpointArgs' public_endpoint: Specification of public endpoint for control plane.
               Set value to empty, to enable it.
        """
        if public_endpoint is not None:
            pulumi.set(__self__, "public_endpoint", public_endpoint)

    @property
    @pulumi.getter(name="publicEndpoint")
    def public_endpoint(self) -> Optional['outputs.Mk8sV1ClusterControlPlaneEndpointsPublicEndpoint']:
        """
        Specification of public endpoint for control plane.
        Set value to empty, to enable it.
        """
        return pulumi.get(self, "public_endpoint")


@pulumi.output_type
class Mk8sV1ClusterControlPlaneEndpointsPublicEndpoint(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class Mk8sV1ClusterKubeNetwork(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "serviceCidrs":
            suggest = "service_cidrs"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in Mk8sV1ClusterKubeNetwork. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        Mk8sV1ClusterKubeNetwork.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        Mk8sV1ClusterKubeNetwork.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 service_cidrs: Optional[Sequence[builtins.str]] = None):
        """
        :param Sequence[builtins.str] service_cidrs: CIDR blocks for Service ClusterIP allocation.
               For now, only one value is supported.
               Must be a valid CIDR block or prefix length.
               In case of prefix length, certain CIDR is auto allocated.
               Specified CIDR blocks will be reserved in Cluster.spec.control_plane.subnet_id to prevent address duplication.
               Allowed prefix length is from "/12" to "/28".
               Empty value treated as ["/16"].
        """
        if service_cidrs is not None:
            pulumi.set(__self__, "service_cidrs", service_cidrs)

    @property
    @pulumi.getter(name="serviceCidrs")
    def service_cidrs(self) -> Optional[Sequence[builtins.str]]:
        """
        CIDR blocks for Service ClusterIP allocation.
        For now, only one value is supported.
        Must be a valid CIDR block or prefix length.
        In case of prefix length, certain CIDR is auto allocated.
        Specified CIDR blocks will be reserved in Cluster.spec.control_plane.subnet_id to prevent address duplication.
        Allowed prefix length is from "/12" to "/28".
        Empty value treated as ["/16"].
        """
        return pulumi.get(self, "service_cidrs")


@pulumi.output_type
class Mk8sV1ClusterMetadata(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class Mk8sV1ClusterStatus(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "controlPlane":
            suggest = "control_plane"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in Mk8sV1ClusterStatus. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        Mk8sV1ClusterStatus.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        Mk8sV1ClusterStatus.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 control_plane: Optional['outputs.Mk8sV1ClusterStatusControlPlane'] = None,
                 reconciling: Optional[builtins.bool] = None,
                 state: Optional[builtins.str] = None):
        """
        :param builtins.bool reconciling: Show that changes are in flight
        :param builtins.str state: ### Supported values
               
               Possible values:
               
                - `STATE_UNSPECIFIED`
                - `PROVISIONING`
                - `RUNNING`
                - `DELETING`
        """
        if control_plane is not None:
            pulumi.set(__self__, "control_plane", control_plane)
        if reconciling is not None:
            pulumi.set(__self__, "reconciling", reconciling)
        if state is not None:
            pulumi.set(__self__, "state", state)

    @property
    @pulumi.getter(name="controlPlane")
    def control_plane(self) -> Optional['outputs.Mk8sV1ClusterStatusControlPlane']:
        return pulumi.get(self, "control_plane")

    @property
    @pulumi.getter
    def reconciling(self) -> Optional[builtins.bool]:
        """
        Show that changes are in flight
        """
        return pulumi.get(self, "reconciling")

    @property
    @pulumi.getter
    def state(self) -> Optional[builtins.str]:
        """
        ### Supported values

        Possible values:

         - `STATE_UNSPECIFIED`
         - `PROVISIONING`
         - `RUNNING`
         - `DELETING`
        """
        return pulumi.get(self, "state")


@pulumi.output_type
class Mk8sV1ClusterStatusControlPlane(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "etcdClusterSize":
            suggest = "etcd_cluster_size"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in Mk8sV1ClusterStatusControlPlane. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        Mk8sV1ClusterStatusControlPlane.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        Mk8sV1ClusterStatusControlPlane.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 auth: Optional['outputs.Mk8sV1ClusterStatusControlPlaneAuth'] = None,
                 endpoints: Optional['outputs.Mk8sV1ClusterStatusControlPlaneEndpoints'] = None,
                 etcd_cluster_size: Optional[builtins.float] = None,
                 version: Optional[builtins.str] = None):
        """
        :param 'Mk8sV1ClusterStatusControlPlaneEndpointsArgs' endpoints: ### Inner value description
               
               Endpoints of Kubernetes control plane. Kubernetes API can be accessed at `https://endpoint/`.
        :param builtins.float etcd_cluster_size: Number of instances in etcd cluster.
        :param builtins.str version: Actual Kubernetes and configuration version.
               Version have format `<major>.<minor>.<patch>-nebius-cp.<infra_version>` like "1.30.0-nebius-cp.3".
               Where <major>.<minor>.<patch> is Kubernetes version and <infra_version> is version of control plane infrastructure and configuration,
               which update may include bug fixes, security updates and new features of components running on control plane, like CCM or Cluster Autoscaler.
        """
        if auth is not None:
            pulumi.set(__self__, "auth", auth)
        if endpoints is not None:
            pulumi.set(__self__, "endpoints", endpoints)
        if etcd_cluster_size is not None:
            pulumi.set(__self__, "etcd_cluster_size", etcd_cluster_size)
        if version is not None:
            pulumi.set(__self__, "version", version)

    @property
    @pulumi.getter
    def auth(self) -> Optional['outputs.Mk8sV1ClusterStatusControlPlaneAuth']:
        return pulumi.get(self, "auth")

    @property
    @pulumi.getter
    def endpoints(self) -> Optional['outputs.Mk8sV1ClusterStatusControlPlaneEndpoints']:
        """
        ### Inner value description

        Endpoints of Kubernetes control plane. Kubernetes API can be accessed at `https://endpoint/`.
        """
        return pulumi.get(self, "endpoints")

    @property
    @pulumi.getter(name="etcdClusterSize")
    def etcd_cluster_size(self) -> Optional[builtins.float]:
        """
        Number of instances in etcd cluster.
        """
        return pulumi.get(self, "etcd_cluster_size")

    @property
    @pulumi.getter
    def version(self) -> Optional[builtins.str]:
        """
        Actual Kubernetes and configuration version.
        Version have format `<major>.<minor>.<patch>-nebius-cp.<infra_version>` like "1.30.0-nebius-cp.3".
        Where <major>.<minor>.<patch> is Kubernetes version and <infra_version> is version of control plane infrastructure and configuration,
        which update may include bug fixes, security updates and new features of components running on control plane, like CCM or Cluster Autoscaler.
        """
        return pulumi.get(self, "version")


@pulumi.output_type
class Mk8sV1ClusterStatusControlPlaneAuth(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clusterCaCertificate":
            suggest = "cluster_ca_certificate"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in Mk8sV1ClusterStatusControlPlaneAuth. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        Mk8sV1ClusterStatusControlPlaneAuth.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        Mk8sV1ClusterStatusControlPlaneAuth.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cluster_ca_certificate: Optional[builtins.str] = None):
        """
        :param builtins.str cluster_ca_certificate: PEM with the Cluster Certificate Authority, that must be used for TLS connection to Kubernetes API.
        """
        if cluster_ca_certificate is not None:
            pulumi.set(__self__, "cluster_ca_certificate", cluster_ca_certificate)

    @property
    @pulumi.getter(name="clusterCaCertificate")
    def cluster_ca_certificate(self) -> Optional[builtins.str]:
        """
        PEM with the Cluster Certificate Authority, that must be used for TLS connection to Kubernetes API.
        """
        return pulumi.get(self, "cluster_ca_certificate")


@pulumi.output_type
class Mk8sV1ClusterStatusControlPlaneEndpoints(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "privateEndpoint":
            suggest = "private_endpoint"
        elif key == "publicEndpoint":
            suggest = "public_endpoint"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in Mk8sV1ClusterStatusControlPlaneEndpoints. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        Mk8sV1ClusterStatusControlPlaneEndpoints.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        Mk8sV1ClusterStatusControlPlaneEndpoints.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 private_endpoint: Optional[builtins.str] = None,
                 public_endpoint: Optional[builtins.str] = None):
        """
        :param builtins.str private_endpoint: DNS name or IP address accessible from the user VPC.
        :param builtins.str public_endpoint: DNS name or IP address accessible from the Internet.
        """
        if private_endpoint is not None:
            pulumi.set(__self__, "private_endpoint", private_endpoint)
        if public_endpoint is not None:
            pulumi.set(__self__, "public_endpoint", public_endpoint)

    @property
    @pulumi.getter(name="privateEndpoint")
    def private_endpoint(self) -> Optional[builtins.str]:
        """
        DNS name or IP address accessible from the user VPC.
        """
        return pulumi.get(self, "private_endpoint")

    @property
    @pulumi.getter(name="publicEndpoint")
    def public_endpoint(self) -> Optional[builtins.str]:
        """
        DNS name or IP address accessible from the Internet.
        """
        return pulumi.get(self, "public_endpoint")


@pulumi.output_type
class Mk8sV1NodeGroupAutoscaling(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "maxNodeCount":
            suggest = "max_node_count"
        elif key == "minNodeCount":
            suggest = "min_node_count"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in Mk8sV1NodeGroupAutoscaling. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        Mk8sV1NodeGroupAutoscaling.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        Mk8sV1NodeGroupAutoscaling.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 max_node_count: Optional[builtins.float] = None,
                 min_node_count: Optional[builtins.float] = None):
        if max_node_count is not None:
            pulumi.set(__self__, "max_node_count", max_node_count)
        if min_node_count is not None:
            pulumi.set(__self__, "min_node_count", min_node_count)

    @property
    @pulumi.getter(name="maxNodeCount")
    def max_node_count(self) -> Optional[builtins.float]:
        return pulumi.get(self, "max_node_count")

    @property
    @pulumi.getter(name="minNodeCount")
    def min_node_count(self) -> Optional[builtins.float]:
        return pulumi.get(self, "min_node_count")


@pulumi.output_type
class Mk8sV1NodeGroupMetadata(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class Mk8sV1NodeGroupStatus(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "nodeCount":
            suggest = "node_count"
        elif key == "outdatedNodeCount":
            suggest = "outdated_node_count"
        elif key == "readyNodeCount":
            suggest = "ready_node_count"
        elif key == "targetNodeCount":
            suggest = "target_node_count"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in Mk8sV1NodeGroupStatus. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        Mk8sV1NodeGroupStatus.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        Mk8sV1NodeGroupStatus.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 node_count: Optional[builtins.float] = None,
                 outdated_node_count: Optional[builtins.float] = None,
                 ready_node_count: Optional[builtins.float] = None,
                 reconciling: Optional[builtins.bool] = None,
                 state: Optional[builtins.str] = None,
                 target_node_count: Optional[builtins.float] = None,
                 version: Optional[builtins.str] = None):
        """
        :param builtins.float node_count: Total number of nodes that are currently in the node group.
               Both ready and not ready nodes are counted.
        :param builtins.float outdated_node_count: Total number of nodes that has outdated node configuration.
               These nodes will be replaced by new nodes with up-to-date configuration.
        :param builtins.float ready_node_count: Total number of nodes that successfully joined the cluster and are ready to serve workloads.
               Both outdated and up-to-date nodes are counted.
        :param builtins.bool reconciling: Show that there are changes are in flight.
        :param builtins.str state: ### Supported values
               
               Possible values:
               
                - `STATE_UNSPECIFIED`
                - `PROVISIONING`
                - `RUNNING`
                - `DELETING`
        :param builtins.float target_node_count: Desired total number of nodes that should be in the node group.
               It is either `NodeGroupSpec.fixed_node_count` or arbitrary number between
               `NodeGroupAutoscalingSpec.min_node_count` and `NodeGroupAutoscalingSpec.max_node_count` decided by autoscaler.
        :param builtins.str version: Actual version of NodeGroup. Have format `<major>.<minor>.<patch>-nebius-node.<infra_version>` like "1.30.0-nebius-node.10".
               Where <major>.<minor>.<patch> is Kubernetes version and <infra_version> is version of Node infrastructure and configuration,
               which update may include bug fixes, security updates and new features depending on worker node configuration.
        """
        if node_count is not None:
            pulumi.set(__self__, "node_count", node_count)
        if outdated_node_count is not None:
            pulumi.set(__self__, "outdated_node_count", outdated_node_count)
        if ready_node_count is not None:
            pulumi.set(__self__, "ready_node_count", ready_node_count)
        if reconciling is not None:
            pulumi.set(__self__, "reconciling", reconciling)
        if state is not None:
            pulumi.set(__self__, "state", state)
        if target_node_count is not None:
            pulumi.set(__self__, "target_node_count", target_node_count)
        if version is not None:
            pulumi.set(__self__, "version", version)

    @property
    @pulumi.getter(name="nodeCount")
    def node_count(self) -> Optional[builtins.float]:
        """
        Total number of nodes that are currently in the node group.
        Both ready and not ready nodes are counted.
        """
        return pulumi.get(self, "node_count")

    @property
    @pulumi.getter(name="outdatedNodeCount")
    def outdated_node_count(self) -> Optional[builtins.float]:
        """
        Total number of nodes that has outdated node configuration.
        These nodes will be replaced by new nodes with up-to-date configuration.
        """
        return pulumi.get(self, "outdated_node_count")

    @property
    @pulumi.getter(name="readyNodeCount")
    def ready_node_count(self) -> Optional[builtins.float]:
        """
        Total number of nodes that successfully joined the cluster and are ready to serve workloads.
        Both outdated and up-to-date nodes are counted.
        """
        return pulumi.get(self, "ready_node_count")

    @property
    @pulumi.getter
    def reconciling(self) -> Optional[builtins.bool]:
        """
        Show that there are changes are in flight.
        """
        return pulumi.get(self, "reconciling")

    @property
    @pulumi.getter
    def state(self) -> Optional[builtins.str]:
        """
        ### Supported values

        Possible values:

         - `STATE_UNSPECIFIED`
         - `PROVISIONING`
         - `RUNNING`
         - `DELETING`
        """
        return pulumi.get(self, "state")

    @property
    @pulumi.getter(name="targetNodeCount")
    def target_node_count(self) -> Optional[builtins.float]:
        """
        Desired total number of nodes that should be in the node group.
        It is either `NodeGroupSpec.fixed_node_count` or arbitrary number between
        `NodeGroupAutoscalingSpec.min_node_count` and `NodeGroupAutoscalingSpec.max_node_count` decided by autoscaler.
        """
        return pulumi.get(self, "target_node_count")

    @property
    @pulumi.getter
    def version(self) -> Optional[builtins.str]:
        """
        Actual version of NodeGroup. Have format `<major>.<minor>.<patch>-nebius-node.<infra_version>` like "1.30.0-nebius-node.10".
        Where <major>.<minor>.<patch> is Kubernetes version and <infra_version> is version of Node infrastructure and configuration,
        which update may include bug fixes, security updates and new features depending on worker node configuration.
        """
        return pulumi.get(self, "version")


@pulumi.output_type
class Mk8sV1NodeGroupStrategy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "drainTimeout":
            suggest = "drain_timeout"
        elif key == "maxSurge":
            suggest = "max_surge"
        elif key == "maxUnavailable":
            suggest = "max_unavailable"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in Mk8sV1NodeGroupStrategy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        Mk8sV1NodeGroupStrategy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        Mk8sV1NodeGroupStrategy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 drain_timeout: Optional[builtins.str] = None,
                 max_surge: Optional['outputs.Mk8sV1NodeGroupStrategyMaxSurge'] = None,
                 max_unavailable: Optional['outputs.Mk8sV1NodeGroupStrategyMaxUnavailable'] = None):
        """
        :param builtins.str drain_timeout: Maximum amount of time that the service will spend on attempting gracefully draining a node (evicting it's pods), before
               falling back to pod deletion.
               By default, node can be drained unlimited time.
               Important consequence of that is if PodDisruptionBudget doesn't allow to evict a pod,
               then NodeGroup update with node re-creation will hung on that pod eviction.
               Note, that it is different from `kubectl drain --timeout`
               
               Duration as a string: possibly signed sequence of decimal numbers, each with optional fraction and a unit suffix, such as `300ms`, `-1.5h` or `2h45m`. Valid time units are `ns`, `us` (or `µs`), `ms`, `s`, `m`, `h`, `d`.
        :param 'Mk8sV1NodeGroupStrategyMaxSurgeArgs' max_surge: The maximum number of additional nodes that can be provisioned above the desired number of nodes during the update process.
               This value can be specified either as an absolute number (for example 3) or as a percentage of the desired number of nodes (for example 5%).
               When specified as a percentage, the actual number is calculated by rounding up to the nearest whole number.
               This value cannot be 0 if `max_unavailable` is also set to 0.
               Defaults to 1.
               Example: If set to 25%, the node group can scale up by an additional 25% during the update,
               allowing new nodes to be added before old nodes are removed, which helps minimize workload disruption.
               NOTE: it is user responsibility to ensure that there are enough quota for provision nodes above the desired number.
                 Available quota effectively limits `max_surge`.
                 In case of not enough quota even for one extra node, update operation will hung because of quota exhausted error.
                 Such error will be visible in Operation.progress_data.
        :param 'Mk8sV1NodeGroupStrategyMaxUnavailableArgs' max_unavailable: The maximum number of nodes that can be simultaneously unavailable during the update process.
               This value can be specified either as an absolute number (for example 3) or as a percentage of the desired number of nodes (for example 5%).
               When specified as a percentage, the actual number is calculated by rounding down to the nearest whole number.
               This value cannot be 0 if `max_surge` is also set to 0.
               Defaults to 0.
               Example: If set to 20%, up to 20% of the nodes can be taken offline at once during the update,
               ensuring that at least 80% of the desired nodes remain operational.
        """
        if drain_timeout is not None:
            pulumi.set(__self__, "drain_timeout", drain_timeout)
        if max_surge is not None:
            pulumi.set(__self__, "max_surge", max_surge)
        if max_unavailable is not None:
            pulumi.set(__self__, "max_unavailable", max_unavailable)

    @property
    @pulumi.getter(name="drainTimeout")
    def drain_timeout(self) -> Optional[builtins.str]:
        """
        Maximum amount of time that the service will spend on attempting gracefully draining a node (evicting it's pods), before
        falling back to pod deletion.
        By default, node can be drained unlimited time.
        Important consequence of that is if PodDisruptionBudget doesn't allow to evict a pod,
        then NodeGroup update with node re-creation will hung on that pod eviction.
        Note, that it is different from `kubectl drain --timeout`

        Duration as a string: possibly signed sequence of decimal numbers, each with optional fraction and a unit suffix, such as `300ms`, `-1.5h` or `2h45m`. Valid time units are `ns`, `us` (or `µs`), `ms`, `s`, `m`, `h`, `d`.
        """
        return pulumi.get(self, "drain_timeout")

    @property
    @pulumi.getter(name="maxSurge")
    def max_surge(self) -> Optional['outputs.Mk8sV1NodeGroupStrategyMaxSurge']:
        """
        The maximum number of additional nodes that can be provisioned above the desired number of nodes during the update process.
        This value can be specified either as an absolute number (for example 3) or as a percentage of the desired number of nodes (for example 5%).
        When specified as a percentage, the actual number is calculated by rounding up to the nearest whole number.
        This value cannot be 0 if `max_unavailable` is also set to 0.
        Defaults to 1.
        Example: If set to 25%, the node group can scale up by an additional 25% during the update,
        allowing new nodes to be added before old nodes are removed, which helps minimize workload disruption.
        NOTE: it is user responsibility to ensure that there are enough quota for provision nodes above the desired number.
          Available quota effectively limits `max_surge`.
          In case of not enough quota even for one extra node, update operation will hung because of quota exhausted error.
          Such error will be visible in Operation.progress_data.
        """
        return pulumi.get(self, "max_surge")

    @property
    @pulumi.getter(name="maxUnavailable")
    def max_unavailable(self) -> Optional['outputs.Mk8sV1NodeGroupStrategyMaxUnavailable']:
        """
        The maximum number of nodes that can be simultaneously unavailable during the update process.
        This value can be specified either as an absolute number (for example 3) or as a percentage of the desired number of nodes (for example 5%).
        When specified as a percentage, the actual number is calculated by rounding down to the nearest whole number.
        This value cannot be 0 if `max_surge` is also set to 0.
        Defaults to 0.
        Example: If set to 20%, up to 20% of the nodes can be taken offline at once during the update,
        ensuring that at least 80% of the desired nodes remain operational.
        """
        return pulumi.get(self, "max_unavailable")


@pulumi.output_type
class Mk8sV1NodeGroupStrategyMaxSurge(dict):
    def __init__(__self__, *,
                 count: Optional[builtins.float] = None,
                 percent: Optional[builtins.float] = None):
        """
        :param builtins.float count: *Cannot be set alongside percent.*
        :param builtins.float percent: *Cannot be set alongside count.*
        """
        if count is not None:
            pulumi.set(__self__, "count", count)
        if percent is not None:
            pulumi.set(__self__, "percent", percent)

    @property
    @pulumi.getter
    def count(self) -> Optional[builtins.float]:
        """
        *Cannot be set alongside percent.*
        """
        return pulumi.get(self, "count")

    @property
    @pulumi.getter
    def percent(self) -> Optional[builtins.float]:
        """
        *Cannot be set alongside count.*
        """
        return pulumi.get(self, "percent")


@pulumi.output_type
class Mk8sV1NodeGroupStrategyMaxUnavailable(dict):
    def __init__(__self__, *,
                 count: Optional[builtins.float] = None,
                 percent: Optional[builtins.float] = None):
        """
        :param builtins.float count: *Cannot be set alongside percent.*
        :param builtins.float percent: *Cannot be set alongside count.*
        """
        if count is not None:
            pulumi.set(__self__, "count", count)
        if percent is not None:
            pulumi.set(__self__, "percent", percent)

    @property
    @pulumi.getter
    def count(self) -> Optional[builtins.float]:
        """
        *Cannot be set alongside percent.*
        """
        return pulumi.get(self, "count")

    @property
    @pulumi.getter
    def percent(self) -> Optional[builtins.float]:
        """
        *Cannot be set alongside count.*
        """
        return pulumi.get(self, "percent")


@pulumi.output_type
class Mk8sV1NodeGroupTemplate(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "bootDisk":
            suggest = "boot_disk"
        elif key == "cloudInitUserData":
            suggest = "cloud_init_user_data"
        elif key == "gpuCluster":
            suggest = "gpu_cluster"
        elif key == "gpuSettings":
            suggest = "gpu_settings"
        elif key == "networkInterfaces":
            suggest = "network_interfaces"
        elif key == "serviceAccountId":
            suggest = "service_account_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in Mk8sV1NodeGroupTemplate. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        Mk8sV1NodeGroupTemplate.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        Mk8sV1NodeGroupTemplate.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 resources: 'outputs.Mk8sV1NodeGroupTemplateResources',
                 boot_disk: Optional['outputs.Mk8sV1NodeGroupTemplateBootDisk'] = None,
                 cloud_init_user_data: Optional[builtins.str] = None,
                 filesystems: Optional[Sequence['outputs.Mk8sV1NodeGroupTemplateFilesystem']] = None,
                 gpu_cluster: Optional['outputs.Mk8sV1NodeGroupTemplateGpuCluster'] = None,
                 gpu_settings: Optional['outputs.Mk8sV1NodeGroupTemplateGpuSettings'] = None,
                 metadata: Optional['outputs.Mk8sV1NodeGroupTemplateMetadata'] = None,
                 network_interfaces: Optional[Sequence['outputs.Mk8sV1NodeGroupTemplateNetworkInterface']] = None,
                 service_account_id: Optional[builtins.str] = None,
                 taints: Optional[Sequence['outputs.Mk8sV1NodeGroupTemplateTaint']] = None):
        """
        :param 'Mk8sV1NodeGroupTemplateResourcesArgs' resources: Resources that will have Nebius Compute Instance where Node kubelet will run.
        :param 'Mk8sV1NodeGroupTemplateBootDiskArgs' boot_disk: Parameters of a Node Nebius Compute Instance boot disk.
        :param builtins.str cloud_init_user_data: cloud-init user-data
               Should contain at least one SSH key.
        :param Sequence['Mk8sV1NodeGroupTemplateFilesystemArgs'] filesystems: Static attachments of Compute Filesystem.
               Can be used as a workaround, until CSI for Compute Disk and Filesystem will be available.
        :param 'Mk8sV1NodeGroupTemplateGpuClusterArgs' gpu_cluster: Nebius Compute GPUCluster ID that will be attached to node.
        :param 'Mk8sV1NodeGroupTemplateGpuSettingsArgs' gpu_settings: GPU-related settings.
               
               ### Inner value description
               
               GPU-related settings.
        :param builtins.str service_account_id: the Nebius service account whose credentials will be available on the nodes of the group.
               With these credentials, it is possible to make `npc` or public API requests from the nodes without the need for extra authentication.
               This service account is also used to make requests to container registry.
               
               `resource.serviceaccount.issueAccessToken` permission is required to use this field.
        :param Sequence['Mk8sV1NodeGroupTemplateTaintArgs'] taints: Kubernetes Node taints.
               For now change will not be propagated to existing nodes, so will be applied only to Kubernetes Nodes created after the field change.
               That behaviour may change later.
               So, for now you will need to manually set them to existing nodes, if that is needed.
               Field change will NOT trigger NodeGroup roll out.
               
               ### Inner value description
               
               See https://kubernetes.io/docs/concepts/scheduling-eviction/taint-and-toleration/
        """
        pulumi.set(__self__, "resources", resources)
        if boot_disk is not None:
            pulumi.set(__self__, "boot_disk", boot_disk)
        if cloud_init_user_data is not None:
            pulumi.set(__self__, "cloud_init_user_data", cloud_init_user_data)
        if filesystems is not None:
            pulumi.set(__self__, "filesystems", filesystems)
        if gpu_cluster is not None:
            pulumi.set(__self__, "gpu_cluster", gpu_cluster)
        if gpu_settings is not None:
            pulumi.set(__self__, "gpu_settings", gpu_settings)
        if metadata is not None:
            pulumi.set(__self__, "metadata", metadata)
        if network_interfaces is not None:
            pulumi.set(__self__, "network_interfaces", network_interfaces)
        if service_account_id is not None:
            pulumi.set(__self__, "service_account_id", service_account_id)
        if taints is not None:
            pulumi.set(__self__, "taints", taints)

    @property
    @pulumi.getter
    def resources(self) -> 'outputs.Mk8sV1NodeGroupTemplateResources':
        """
        Resources that will have Nebius Compute Instance where Node kubelet will run.
        """
        return pulumi.get(self, "resources")

    @property
    @pulumi.getter(name="bootDisk")
    def boot_disk(self) -> Optional['outputs.Mk8sV1NodeGroupTemplateBootDisk']:
        """
        Parameters of a Node Nebius Compute Instance boot disk.
        """
        return pulumi.get(self, "boot_disk")

    @property
    @pulumi.getter(name="cloudInitUserData")
    def cloud_init_user_data(self) -> Optional[builtins.str]:
        """
        cloud-init user-data
        Should contain at least one SSH key.
        """
        return pulumi.get(self, "cloud_init_user_data")

    @property
    @pulumi.getter
    def filesystems(self) -> Optional[Sequence['outputs.Mk8sV1NodeGroupTemplateFilesystem']]:
        """
        Static attachments of Compute Filesystem.
        Can be used as a workaround, until CSI for Compute Disk and Filesystem will be available.
        """
        return pulumi.get(self, "filesystems")

    @property
    @pulumi.getter(name="gpuCluster")
    def gpu_cluster(self) -> Optional['outputs.Mk8sV1NodeGroupTemplateGpuCluster']:
        """
        Nebius Compute GPUCluster ID that will be attached to node.
        """
        return pulumi.get(self, "gpu_cluster")

    @property
    @pulumi.getter(name="gpuSettings")
    def gpu_settings(self) -> Optional['outputs.Mk8sV1NodeGroupTemplateGpuSettings']:
        """
        GPU-related settings.

        ### Inner value description

        GPU-related settings.
        """
        return pulumi.get(self, "gpu_settings")

    @property
    @pulumi.getter
    def metadata(self) -> Optional['outputs.Mk8sV1NodeGroupTemplateMetadata']:
        return pulumi.get(self, "metadata")

    @property
    @pulumi.getter(name="networkInterfaces")
    def network_interfaces(self) -> Optional[Sequence['outputs.Mk8sV1NodeGroupTemplateNetworkInterface']]:
        return pulumi.get(self, "network_interfaces")

    @property
    @pulumi.getter(name="serviceAccountId")
    def service_account_id(self) -> Optional[builtins.str]:
        """
        the Nebius service account whose credentials will be available on the nodes of the group.
        With these credentials, it is possible to make `npc` or public API requests from the nodes without the need for extra authentication.
        This service account is also used to make requests to container registry.

        `resource.serviceaccount.issueAccessToken` permission is required to use this field.
        """
        return pulumi.get(self, "service_account_id")

    @property
    @pulumi.getter
    def taints(self) -> Optional[Sequence['outputs.Mk8sV1NodeGroupTemplateTaint']]:
        """
        Kubernetes Node taints.
        For now change will not be propagated to existing nodes, so will be applied only to Kubernetes Nodes created after the field change.
        That behaviour may change later.
        So, for now you will need to manually set them to existing nodes, if that is needed.
        Field change will NOT trigger NodeGroup roll out.

        ### Inner value description

        See https://kubernetes.io/docs/concepts/scheduling-eviction/taint-and-toleration/
        """
        return pulumi.get(self, "taints")


@pulumi.output_type
class Mk8sV1NodeGroupTemplateBootDisk(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "blockSizeBytes":
            suggest = "block_size_bytes"
        elif key == "sizeBytes":
            suggest = "size_bytes"
        elif key == "sizeGibibytes":
            suggest = "size_gibibytes"
        elif key == "sizeKibibytes":
            suggest = "size_kibibytes"
        elif key == "sizeMebibytes":
            suggest = "size_mebibytes"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in Mk8sV1NodeGroupTemplateBootDisk. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        Mk8sV1NodeGroupTemplateBootDisk.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        Mk8sV1NodeGroupTemplateBootDisk.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 block_size_bytes: Optional[builtins.float] = None,
                 size_bytes: Optional[builtins.float] = None,
                 size_gibibytes: Optional[builtins.float] = None,
                 size_kibibytes: Optional[builtins.float] = None,
                 size_mebibytes: Optional[builtins.float] = None,
                 type: Optional[builtins.str] = None):
        """
        :param builtins.float size_bytes: *Cannot be set alongside size_kibibytes or size_gibibytes.*
        :param builtins.float size_gibibytes: *Cannot be set alongside size_bytes or size_mebibytes.*
        :param builtins.float size_kibibytes: *Cannot be set alongside size_bytes or size_gibibytes.*
        :param builtins.float size_mebibytes: *Cannot be set alongside size_bytes or size_gibibytes.*
        :param builtins.str type: ### Supported values
               
               Possible values:
               
                - `UNSPECIFIED`
                - `NETWORK_SSD`
                - `NETWORK_HDD`
                - `NETWORK_SSD_IO_M3`
                - `NETWORK_SSD_NON_REPLICATED`
        """
        if block_size_bytes is not None:
            pulumi.set(__self__, "block_size_bytes", block_size_bytes)
        if size_bytes is not None:
            pulumi.set(__self__, "size_bytes", size_bytes)
        if size_gibibytes is not None:
            pulumi.set(__self__, "size_gibibytes", size_gibibytes)
        if size_kibibytes is not None:
            pulumi.set(__self__, "size_kibibytes", size_kibibytes)
        if size_mebibytes is not None:
            pulumi.set(__self__, "size_mebibytes", size_mebibytes)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter(name="blockSizeBytes")
    def block_size_bytes(self) -> Optional[builtins.float]:
        return pulumi.get(self, "block_size_bytes")

    @property
    @pulumi.getter(name="sizeBytes")
    def size_bytes(self) -> Optional[builtins.float]:
        """
        *Cannot be set alongside size_kibibytes or size_gibibytes.*
        """
        return pulumi.get(self, "size_bytes")

    @property
    @pulumi.getter(name="sizeGibibytes")
    def size_gibibytes(self) -> Optional[builtins.float]:
        """
        *Cannot be set alongside size_bytes or size_mebibytes.*
        """
        return pulumi.get(self, "size_gibibytes")

    @property
    @pulumi.getter(name="sizeKibibytes")
    def size_kibibytes(self) -> Optional[builtins.float]:
        """
        *Cannot be set alongside size_bytes or size_gibibytes.*
        """
        return pulumi.get(self, "size_kibibytes")

    @property
    @pulumi.getter(name="sizeMebibytes")
    def size_mebibytes(self) -> Optional[builtins.float]:
        """
        *Cannot be set alongside size_bytes or size_gibibytes.*
        """
        return pulumi.get(self, "size_mebibytes")

    @property
    @pulumi.getter
    def type(self) -> Optional[builtins.str]:
        """
        ### Supported values

        Possible values:

         - `UNSPECIFIED`
         - `NETWORK_SSD`
         - `NETWORK_HDD`
         - `NETWORK_SSD_IO_M3`
         - `NETWORK_SSD_NON_REPLICATED`
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class Mk8sV1NodeGroupTemplateFilesystem(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "attachMode":
            suggest = "attach_mode"
        elif key == "mountTag":
            suggest = "mount_tag"
        elif key == "existingFilesystem":
            suggest = "existing_filesystem"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in Mk8sV1NodeGroupTemplateFilesystem. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        Mk8sV1NodeGroupTemplateFilesystem.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        Mk8sV1NodeGroupTemplateFilesystem.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 attach_mode: builtins.str,
                 mount_tag: builtins.str,
                 existing_filesystem: Optional['outputs.Mk8sV1NodeGroupTemplateFilesystemExistingFilesystem'] = None):
        """
        :param builtins.str attach_mode: ### Supported values
               
               Possible values:
               
                - `UNSPECIFIED`
                - `READ_ONLY`
                - `READ_WRITE`
        :param builtins.str mount_tag: Specifies the user-defined identifier, allowing to use it as a device in mount command.
        """
        pulumi.set(__self__, "attach_mode", attach_mode)
        pulumi.set(__self__, "mount_tag", mount_tag)
        if existing_filesystem is not None:
            pulumi.set(__self__, "existing_filesystem", existing_filesystem)

    @property
    @pulumi.getter(name="attachMode")
    def attach_mode(self) -> builtins.str:
        """
        ### Supported values

        Possible values:

         - `UNSPECIFIED`
         - `READ_ONLY`
         - `READ_WRITE`
        """
        return pulumi.get(self, "attach_mode")

    @property
    @pulumi.getter(name="mountTag")
    def mount_tag(self) -> builtins.str:
        """
        Specifies the user-defined identifier, allowing to use it as a device in mount command.
        """
        return pulumi.get(self, "mount_tag")

    @property
    @pulumi.getter(name="existingFilesystem")
    def existing_filesystem(self) -> Optional['outputs.Mk8sV1NodeGroupTemplateFilesystemExistingFilesystem']:
        return pulumi.get(self, "existing_filesystem")


@pulumi.output_type
class Mk8sV1NodeGroupTemplateFilesystemExistingFilesystem(dict):
    def __init__(__self__, *,
                 id: builtins.str):
        pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> builtins.str:
        return pulumi.get(self, "id")


@pulumi.output_type
class Mk8sV1NodeGroupTemplateGpuCluster(dict):
    def __init__(__self__, *,
                 id: Optional[builtins.str] = None):
        if id is not None:
            pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> Optional[builtins.str]:
        return pulumi.get(self, "id")


@pulumi.output_type
class Mk8sV1NodeGroupTemplateGpuSettings(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "driversPreset":
            suggest = "drivers_preset"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in Mk8sV1NodeGroupTemplateGpuSettings. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        Mk8sV1NodeGroupTemplateGpuSettings.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        Mk8sV1NodeGroupTemplateGpuSettings.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 drivers_preset: builtins.str):
        """
        :param builtins.str drivers_preset: Identifier of the predefined set of drivers included in the ComputeImage deployed on ComputeInstances that are part of the NodeGroup.
               Supported presets: cuda12
        """
        pulumi.set(__self__, "drivers_preset", drivers_preset)

    @property
    @pulumi.getter(name="driversPreset")
    def drivers_preset(self) -> builtins.str:
        """
        Identifier of the predefined set of drivers included in the ComputeImage deployed on ComputeInstances that are part of the NodeGroup.
        Supported presets: cuda12
        """
        return pulumi.get(self, "drivers_preset")


@pulumi.output_type
class Mk8sV1NodeGroupTemplateMetadata(dict):
    def __init__(__self__, *,
                 labels: Optional[Mapping[str, builtins.str]] = None):
        """
        :param Mapping[str, builtins.str] labels: Kubernetes Node labels.
               For now change will not be propagated to existing nodes, so will be applied only to Kubernetes Nodes created after the field change.
               That behaviour may change later.
               So, for now you will need to manually set them to existing nodes, if that is needed.
               
               System labels containing "kubernetes.io" and "k8s.io" will be ignored.
               Field change will NOT trigger NodeGroup roll out.
        """
        if labels is not None:
            pulumi.set(__self__, "labels", labels)

    @property
    @pulumi.getter
    def labels(self) -> Optional[Mapping[str, builtins.str]]:
        """
        Kubernetes Node labels.
        For now change will not be propagated to existing nodes, so will be applied only to Kubernetes Nodes created after the field change.
        That behaviour may change later.
        So, for now you will need to manually set them to existing nodes, if that is needed.

        System labels containing "kubernetes.io" and "k8s.io" will be ignored.
        Field change will NOT trigger NodeGroup roll out.
        """
        return pulumi.get(self, "labels")


@pulumi.output_type
class Mk8sV1NodeGroupTemplateNetworkInterface(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "publicIpAddress":
            suggest = "public_ip_address"
        elif key == "subnetId":
            suggest = "subnet_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in Mk8sV1NodeGroupTemplateNetworkInterface. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        Mk8sV1NodeGroupTemplateNetworkInterface.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        Mk8sV1NodeGroupTemplateNetworkInterface.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 public_ip_address: Optional['outputs.Mk8sV1NodeGroupTemplateNetworkInterfacePublicIpAddress'] = None,
                 subnet_id: Optional[builtins.str] = None):
        """
        :param 'Mk8sV1NodeGroupTemplateNetworkInterfacePublicIpAddressArgs' public_ip_address: Parameters for Public IPv4 address associated with the interface.
               Set to empty value, to enable it.
               
               ### Inner value description
               
               Describes a public IP address.
        :param builtins.str subnet_id: Nebius VPC Subnet ID that will be attached to a node cloud instance network interface.
               By default Cluster control plane subnet_id used.
               Subnet should be located in the same network with control plane.
        """
        if public_ip_address is not None:
            pulumi.set(__self__, "public_ip_address", public_ip_address)
        if subnet_id is not None:
            pulumi.set(__self__, "subnet_id", subnet_id)

    @property
    @pulumi.getter(name="publicIpAddress")
    def public_ip_address(self) -> Optional['outputs.Mk8sV1NodeGroupTemplateNetworkInterfacePublicIpAddress']:
        """
        Parameters for Public IPv4 address associated with the interface.
        Set to empty value, to enable it.

        ### Inner value description

        Describes a public IP address.
        """
        return pulumi.get(self, "public_ip_address")

    @property
    @pulumi.getter(name="subnetId")
    def subnet_id(self) -> Optional[builtins.str]:
        """
        Nebius VPC Subnet ID that will be attached to a node cloud instance network interface.
        By default Cluster control plane subnet_id used.
        Subnet should be located in the same network with control plane.
        """
        return pulumi.get(self, "subnet_id")


@pulumi.output_type
class Mk8sV1NodeGroupTemplateNetworkInterfacePublicIpAddress(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class Mk8sV1NodeGroupTemplateResources(dict):
    def __init__(__self__, *,
                 platform: builtins.str,
                 preset: Optional[builtins.str] = None):
        pulumi.set(__self__, "platform", platform)
        if preset is not None:
            pulumi.set(__self__, "preset", preset)

    @property
    @pulumi.getter
    def platform(self) -> builtins.str:
        return pulumi.get(self, "platform")

    @property
    @pulumi.getter
    def preset(self) -> Optional[builtins.str]:
        return pulumi.get(self, "preset")


@pulumi.output_type
class Mk8sV1NodeGroupTemplateTaint(dict):
    def __init__(__self__, *,
                 effect: builtins.str,
                 key: builtins.str,
                 value: builtins.str):
        """
        :param builtins.str effect: ### Supported values
               
               Possible values:
               
                - `EFFECT_UNSPECIFIED`
                - `NO_EXECUTE`
                - `NO_SCHEDULE`
                - `PREFER_NO_SCHEDULE`
        """
        pulumi.set(__self__, "effect", effect)
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def effect(self) -> builtins.str:
        """
        ### Supported values

        Possible values:

         - `EFFECT_UNSPECIFIED`
         - `NO_EXECUTE`
         - `NO_SCHEDULE`
         - `PREFER_NO_SCHEDULE`
        """
        return pulumi.get(self, "effect")

    @property
    @pulumi.getter
    def key(self) -> builtins.str:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def value(self) -> builtins.str:
        return pulumi.get(self, "value")


@pulumi.output_type
class Mk8sV1alpha1ClusterControlPlane(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "subnetId":
            suggest = "subnet_id"
        elif key == "etcdClusterSize":
            suggest = "etcd_cluster_size"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in Mk8sV1alpha1ClusterControlPlane. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        Mk8sV1alpha1ClusterControlPlane.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        Mk8sV1alpha1ClusterControlPlane.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 subnet_id: builtins.str,
                 endpoints: Optional['outputs.Mk8sV1alpha1ClusterControlPlaneEndpoints'] = None,
                 etcd_cluster_size: Optional[builtins.float] = None,
                 version: Optional[builtins.str] = None):
        """
        :param builtins.str subnet_id: Subnet ID where control plane instances will be located.
        :param builtins.float etcd_cluster_size: Number of instances in etcd cluster.
               3 by default.
               Control plane with `etcd_cluster_size: 3` called "Highly Available" ("HA"), because it's Kubernetes API
               will be available despite a failure of one control plane instance.
        :param builtins.str version: Version is desired Kubernetes version of the cluster. For now only acceptable format is
               `MAJOR.MINOR` like "1.30". Option for patch version update will be added later.
        """
        pulumi.set(__self__, "subnet_id", subnet_id)
        if endpoints is not None:
            pulumi.set(__self__, "endpoints", endpoints)
        if etcd_cluster_size is not None:
            pulumi.set(__self__, "etcd_cluster_size", etcd_cluster_size)
        if version is not None:
            pulumi.set(__self__, "version", version)

    @property
    @pulumi.getter(name="subnetId")
    def subnet_id(self) -> builtins.str:
        """
        Subnet ID where control plane instances will be located.
        """
        return pulumi.get(self, "subnet_id")

    @property
    @pulumi.getter
    def endpoints(self) -> Optional['outputs.Mk8sV1alpha1ClusterControlPlaneEndpoints']:
        return pulumi.get(self, "endpoints")

    @property
    @pulumi.getter(name="etcdClusterSize")
    def etcd_cluster_size(self) -> Optional[builtins.float]:
        """
        Number of instances in etcd cluster.
        3 by default.
        Control plane with `etcd_cluster_size: 3` called "Highly Available" ("HA"), because it's Kubernetes API
        will be available despite a failure of one control plane instance.
        """
        return pulumi.get(self, "etcd_cluster_size")

    @property
    @pulumi.getter
    def version(self) -> Optional[builtins.str]:
        """
        Version is desired Kubernetes version of the cluster. For now only acceptable format is
        `MAJOR.MINOR` like "1.30". Option for patch version update will be added later.
        """
        return pulumi.get(self, "version")


@pulumi.output_type
class Mk8sV1alpha1ClusterControlPlaneEndpoints(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "publicEndpoint":
            suggest = "public_endpoint"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in Mk8sV1alpha1ClusterControlPlaneEndpoints. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        Mk8sV1alpha1ClusterControlPlaneEndpoints.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        Mk8sV1alpha1ClusterControlPlaneEndpoints.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 public_endpoint: Optional['outputs.Mk8sV1alpha1ClusterControlPlaneEndpointsPublicEndpoint'] = None):
        """
        :param 'Mk8sV1alpha1ClusterControlPlaneEndpointsPublicEndpointArgs' public_endpoint: PublicEndpointSpec is a specification of public endpoint for control plane.
        """
        if public_endpoint is not None:
            pulumi.set(__self__, "public_endpoint", public_endpoint)

    @property
    @pulumi.getter(name="publicEndpoint")
    def public_endpoint(self) -> Optional['outputs.Mk8sV1alpha1ClusterControlPlaneEndpointsPublicEndpoint']:
        """
        PublicEndpointSpec is a specification of public endpoint for control plane.
        """
        return pulumi.get(self, "public_endpoint")


@pulumi.output_type
class Mk8sV1alpha1ClusterControlPlaneEndpointsPublicEndpoint(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class Mk8sV1alpha1ClusterKubeNetwork(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "serviceCidrs":
            suggest = "service_cidrs"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in Mk8sV1alpha1ClusterKubeNetwork. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        Mk8sV1alpha1ClusterKubeNetwork.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        Mk8sV1alpha1ClusterKubeNetwork.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 service_cidrs: Optional[Sequence[builtins.str]] = None):
        """
        :param Sequence[builtins.str] service_cidrs: CIDR blocks for Service ClusterIP allocation.
               For now, only one value is supported.
               Must be a valid CIDR block or prefix length.
               In case of prefix length, certain CIDR is auto allocated.
               Specified CIDR blocks will be reserved in Cluster.spec.control_plane.subnet_id to prevent address duplication.
               Allowed prefix length is from "/12" to "/28".
               Empty value treated as ["/16"].
        """
        if service_cidrs is not None:
            pulumi.set(__self__, "service_cidrs", service_cidrs)

    @property
    @pulumi.getter(name="serviceCidrs")
    def service_cidrs(self) -> Optional[Sequence[builtins.str]]:
        """
        CIDR blocks for Service ClusterIP allocation.
        For now, only one value is supported.
        Must be a valid CIDR block or prefix length.
        In case of prefix length, certain CIDR is auto allocated.
        Specified CIDR blocks will be reserved in Cluster.spec.control_plane.subnet_id to prevent address duplication.
        Allowed prefix length is from "/12" to "/28".
        Empty value treated as ["/16"].
        """
        return pulumi.get(self, "service_cidrs")


@pulumi.output_type
class Mk8sV1alpha1ClusterMetadata(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class Mk8sV1alpha1ClusterStatus(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "controlPlane":
            suggest = "control_plane"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in Mk8sV1alpha1ClusterStatus. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        Mk8sV1alpha1ClusterStatus.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        Mk8sV1alpha1ClusterStatus.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 control_plane: Optional['outputs.Mk8sV1alpha1ClusterStatusControlPlane'] = None,
                 reconciling: Optional[builtins.bool] = None,
                 state: Optional[builtins.str] = None):
        """
        :param builtins.bool reconciling: Show that changes are in flight
        :param builtins.str state: ### Supported values
               
               Possible values:
               
                - `STATE_UNSPECIFIED`
                - `PROVISIONING`
                - `RUNNING`
                - `DELETING`
        """
        if control_plane is not None:
            pulumi.set(__self__, "control_plane", control_plane)
        if reconciling is not None:
            pulumi.set(__self__, "reconciling", reconciling)
        if state is not None:
            pulumi.set(__self__, "state", state)

    @property
    @pulumi.getter(name="controlPlane")
    def control_plane(self) -> Optional['outputs.Mk8sV1alpha1ClusterStatusControlPlane']:
        return pulumi.get(self, "control_plane")

    @property
    @pulumi.getter
    def reconciling(self) -> Optional[builtins.bool]:
        """
        Show that changes are in flight
        """
        return pulumi.get(self, "reconciling")

    @property
    @pulumi.getter
    def state(self) -> Optional[builtins.str]:
        """
        ### Supported values

        Possible values:

         - `STATE_UNSPECIFIED`
         - `PROVISIONING`
         - `RUNNING`
         - `DELETING`
        """
        return pulumi.get(self, "state")


@pulumi.output_type
class Mk8sV1alpha1ClusterStatusControlPlane(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "etcdClusterSize":
            suggest = "etcd_cluster_size"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in Mk8sV1alpha1ClusterStatusControlPlane. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        Mk8sV1alpha1ClusterStatusControlPlane.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        Mk8sV1alpha1ClusterStatusControlPlane.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 auth: Optional['outputs.Mk8sV1alpha1ClusterStatusControlPlaneAuth'] = None,
                 endpoints: Optional['outputs.Mk8sV1alpha1ClusterStatusControlPlaneEndpoints'] = None,
                 etcd_cluster_size: Optional[builtins.float] = None,
                 version: Optional[builtins.str] = None):
        """
        :param 'Mk8sV1alpha1ClusterStatusControlPlaneEndpointsArgs' endpoints: ### Inner value description
               
               Endpoints of Kubernetes control plane. Kubernetes API can be accessed at `https://endpoint/`.
        :param builtins.float etcd_cluster_size: Number of instances in etcd cluster.
        :param builtins.str version: Version have format `major.minor.patch-nebius-cp.n` like "1.30.0-nebius-cp.3".
        """
        if auth is not None:
            pulumi.set(__self__, "auth", auth)
        if endpoints is not None:
            pulumi.set(__self__, "endpoints", endpoints)
        if etcd_cluster_size is not None:
            pulumi.set(__self__, "etcd_cluster_size", etcd_cluster_size)
        if version is not None:
            pulumi.set(__self__, "version", version)

    @property
    @pulumi.getter
    def auth(self) -> Optional['outputs.Mk8sV1alpha1ClusterStatusControlPlaneAuth']:
        return pulumi.get(self, "auth")

    @property
    @pulumi.getter
    def endpoints(self) -> Optional['outputs.Mk8sV1alpha1ClusterStatusControlPlaneEndpoints']:
        """
        ### Inner value description

        Endpoints of Kubernetes control plane. Kubernetes API can be accessed at `https://endpoint/`.
        """
        return pulumi.get(self, "endpoints")

    @property
    @pulumi.getter(name="etcdClusterSize")
    def etcd_cluster_size(self) -> Optional[builtins.float]:
        """
        Number of instances in etcd cluster.
        """
        return pulumi.get(self, "etcd_cluster_size")

    @property
    @pulumi.getter
    def version(self) -> Optional[builtins.str]:
        """
        Version have format `major.minor.patch-nebius-cp.n` like "1.30.0-nebius-cp.3".
        """
        return pulumi.get(self, "version")


@pulumi.output_type
class Mk8sV1alpha1ClusterStatusControlPlaneAuth(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clusterCaCertificate":
            suggest = "cluster_ca_certificate"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in Mk8sV1alpha1ClusterStatusControlPlaneAuth. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        Mk8sV1alpha1ClusterStatusControlPlaneAuth.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        Mk8sV1alpha1ClusterStatusControlPlaneAuth.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cluster_ca_certificate: Optional[builtins.str] = None):
        if cluster_ca_certificate is not None:
            pulumi.set(__self__, "cluster_ca_certificate", cluster_ca_certificate)

    @property
    @pulumi.getter(name="clusterCaCertificate")
    def cluster_ca_certificate(self) -> Optional[builtins.str]:
        return pulumi.get(self, "cluster_ca_certificate")


@pulumi.output_type
class Mk8sV1alpha1ClusterStatusControlPlaneEndpoints(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "privateEndpoint":
            suggest = "private_endpoint"
        elif key == "publicEndpoint":
            suggest = "public_endpoint"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in Mk8sV1alpha1ClusterStatusControlPlaneEndpoints. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        Mk8sV1alpha1ClusterStatusControlPlaneEndpoints.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        Mk8sV1alpha1ClusterStatusControlPlaneEndpoints.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 private_endpoint: Optional[builtins.str] = None,
                 public_endpoint: Optional[builtins.str] = None):
        """
        :param builtins.str private_endpoint: DNS name or IP address accessible from the user VPC.
        :param builtins.str public_endpoint: DNS name or IP address accessible from the Internet.
        """
        if private_endpoint is not None:
            pulumi.set(__self__, "private_endpoint", private_endpoint)
        if public_endpoint is not None:
            pulumi.set(__self__, "public_endpoint", public_endpoint)

    @property
    @pulumi.getter(name="privateEndpoint")
    def private_endpoint(self) -> Optional[builtins.str]:
        """
        DNS name or IP address accessible from the user VPC.
        """
        return pulumi.get(self, "private_endpoint")

    @property
    @pulumi.getter(name="publicEndpoint")
    def public_endpoint(self) -> Optional[builtins.str]:
        """
        DNS name or IP address accessible from the Internet.
        """
        return pulumi.get(self, "public_endpoint")


@pulumi.output_type
class Mk8sV1alpha1NodeGroupAutoscaling(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "maxNodeCount":
            suggest = "max_node_count"
        elif key == "minNodeCount":
            suggest = "min_node_count"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in Mk8sV1alpha1NodeGroupAutoscaling. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        Mk8sV1alpha1NodeGroupAutoscaling.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        Mk8sV1alpha1NodeGroupAutoscaling.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 max_node_count: Optional[builtins.float] = None,
                 min_node_count: Optional[builtins.float] = None):
        if max_node_count is not None:
            pulumi.set(__self__, "max_node_count", max_node_count)
        if min_node_count is not None:
            pulumi.set(__self__, "min_node_count", min_node_count)

    @property
    @pulumi.getter(name="maxNodeCount")
    def max_node_count(self) -> Optional[builtins.float]:
        return pulumi.get(self, "max_node_count")

    @property
    @pulumi.getter(name="minNodeCount")
    def min_node_count(self) -> Optional[builtins.float]:
        return pulumi.get(self, "min_node_count")


@pulumi.output_type
class Mk8sV1alpha1NodeGroupMetadata(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class Mk8sV1alpha1NodeGroupStatus(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "nodeCount":
            suggest = "node_count"
        elif key == "outdatedNodeCount":
            suggest = "outdated_node_count"
        elif key == "readyNodeCount":
            suggest = "ready_node_count"
        elif key == "targetNodeCount":
            suggest = "target_node_count"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in Mk8sV1alpha1NodeGroupStatus. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        Mk8sV1alpha1NodeGroupStatus.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        Mk8sV1alpha1NodeGroupStatus.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 node_count: Optional[builtins.float] = None,
                 outdated_node_count: Optional[builtins.float] = None,
                 ready_node_count: Optional[builtins.float] = None,
                 reconciling: Optional[builtins.bool] = None,
                 state: Optional[builtins.str] = None,
                 target_node_count: Optional[builtins.float] = None,
                 version: Optional[builtins.str] = None):
        """
        :param builtins.float node_count: Total number of nodes that are currently in the node group.
               Both ready and not ready nodes are counted.
        :param builtins.float outdated_node_count: Total number of nodes that has outdated node configuration.
               These nodes will be replaced by new nodes with up-to-date configuration.
        :param builtins.float ready_node_count: Total number of nodes that successfully joined the cluster and are ready to serve workloads.
               Both outdated and up-to-date nodes are counted.
        :param builtins.bool reconciling: Show that changes are in flight
        :param builtins.str state: ### Supported values
               
               Possible values:
               
                - `STATE_UNSPECIFIED`
                - `PROVISIONING`
                - `RUNNING`
                - `DELETING`
        :param builtins.float target_node_count: Desired total number of nodes that should be in the node group.
               It is either fixed_node_count or arbitrary number between min_node_count and max_node_count decided by autoscaler.
        :param builtins.str version: Version have format `MAJOR.MINOR.PATCH-nebius-node.n` like "1.30.0-nebius-node.10".
        """
        if node_count is not None:
            pulumi.set(__self__, "node_count", node_count)
        if outdated_node_count is not None:
            pulumi.set(__self__, "outdated_node_count", outdated_node_count)
        if ready_node_count is not None:
            pulumi.set(__self__, "ready_node_count", ready_node_count)
        if reconciling is not None:
            pulumi.set(__self__, "reconciling", reconciling)
        if state is not None:
            pulumi.set(__self__, "state", state)
        if target_node_count is not None:
            pulumi.set(__self__, "target_node_count", target_node_count)
        if version is not None:
            pulumi.set(__self__, "version", version)

    @property
    @pulumi.getter(name="nodeCount")
    def node_count(self) -> Optional[builtins.float]:
        """
        Total number of nodes that are currently in the node group.
        Both ready and not ready nodes are counted.
        """
        return pulumi.get(self, "node_count")

    @property
    @pulumi.getter(name="outdatedNodeCount")
    def outdated_node_count(self) -> Optional[builtins.float]:
        """
        Total number of nodes that has outdated node configuration.
        These nodes will be replaced by new nodes with up-to-date configuration.
        """
        return pulumi.get(self, "outdated_node_count")

    @property
    @pulumi.getter(name="readyNodeCount")
    def ready_node_count(self) -> Optional[builtins.float]:
        """
        Total number of nodes that successfully joined the cluster and are ready to serve workloads.
        Both outdated and up-to-date nodes are counted.
        """
        return pulumi.get(self, "ready_node_count")

    @property
    @pulumi.getter
    def reconciling(self) -> Optional[builtins.bool]:
        """
        Show that changes are in flight
        """
        return pulumi.get(self, "reconciling")

    @property
    @pulumi.getter
    def state(self) -> Optional[builtins.str]:
        """
        ### Supported values

        Possible values:

         - `STATE_UNSPECIFIED`
         - `PROVISIONING`
         - `RUNNING`
         - `DELETING`
        """
        return pulumi.get(self, "state")

    @property
    @pulumi.getter(name="targetNodeCount")
    def target_node_count(self) -> Optional[builtins.float]:
        """
        Desired total number of nodes that should be in the node group.
        It is either fixed_node_count or arbitrary number between min_node_count and max_node_count decided by autoscaler.
        """
        return pulumi.get(self, "target_node_count")

    @property
    @pulumi.getter
    def version(self) -> Optional[builtins.str]:
        """
        Version have format `MAJOR.MINOR.PATCH-nebius-node.n` like "1.30.0-nebius-node.10".
        """
        return pulumi.get(self, "version")


@pulumi.output_type
class Mk8sV1alpha1NodeGroupStrategy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "drainTimeout":
            suggest = "drain_timeout"
        elif key == "maxSurge":
            suggest = "max_surge"
        elif key == "maxUnavailable":
            suggest = "max_unavailable"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in Mk8sV1alpha1NodeGroupStrategy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        Mk8sV1alpha1NodeGroupStrategy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        Mk8sV1alpha1NodeGroupStrategy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 drain_timeout: Optional[builtins.str] = None,
                 max_surge: Optional['outputs.Mk8sV1alpha1NodeGroupStrategyMaxSurge'] = None,
                 max_unavailable: Optional['outputs.Mk8sV1alpha1NodeGroupStrategyMaxUnavailable'] = None):
        """
        :param builtins.str drain_timeout: DrainTimeout is the total amount of time that the service will spend on draining a node.
               By default, node can be drained without any time limitations.
               NOTE: NodeDrainTimeout is different from `kubectl drain --timeout`
               
               Duration as a string: possibly signed sequence of decimal numbers, each with optional fraction and a unit suffix, such as `300ms`, `-1.5h` or `2h45m`. Valid time units are `ns`, `us` (or `µs`), `ms`, `s`, `m`, `h`, `d`.
        :param 'Mk8sV1alpha1NodeGroupStrategyMaxSurgeArgs' max_surge: The maximum number of machines that can be scheduled above the
               desired number of machines.
               Value can be an absolute number (ex: 5) or a percentage of
               desired machines (ex: 10%).
               This can not be 0 if MaxUnavailable is 0.
               Absolute number is calculated from percentage by rounding up.
               Defaults to 1.
               Example: when this is set to 30%, the new MachineSet can be scaled
               up immediately when the rolling update starts, such that the total
               number of old and new machines do not exceed 130% of desired
               machines. Once old machines have been killed, new MachineSet can
               be scaled up further, ensuring that total number of machines running
               at any time during the update is at most 130% of desired machines.
        :param 'Mk8sV1alpha1NodeGroupStrategyMaxUnavailableArgs' max_unavailable: The maximum number of machines that can be unavailable during the update.
               Value can be an absolute number (ex: 5) or a percentage of desired
               machines (ex: 10%).
               Absolute number is calculated from percentage by rounding down.
               This can not be 0 if MaxSurge is 0.
               Defaults to 0.
               Example: when this is set to 30%, the old MachineSet can be scaled
               down to 70% of desired machines immediately when the rolling update
               starts. Once new machines are ready, old MachineSet can be scaled
               down further, followed by scaling up the new MachineSet, ensuring
               that the total number of machines available at all times
               during the update is at least 70% of desired machines.
        """
        if drain_timeout is not None:
            pulumi.set(__self__, "drain_timeout", drain_timeout)
        if max_surge is not None:
            pulumi.set(__self__, "max_surge", max_surge)
        if max_unavailable is not None:
            pulumi.set(__self__, "max_unavailable", max_unavailable)

    @property
    @pulumi.getter(name="drainTimeout")
    def drain_timeout(self) -> Optional[builtins.str]:
        """
        DrainTimeout is the total amount of time that the service will spend on draining a node.
        By default, node can be drained without any time limitations.
        NOTE: NodeDrainTimeout is different from `kubectl drain --timeout`

        Duration as a string: possibly signed sequence of decimal numbers, each with optional fraction and a unit suffix, such as `300ms`, `-1.5h` or `2h45m`. Valid time units are `ns`, `us` (or `µs`), `ms`, `s`, `m`, `h`, `d`.
        """
        return pulumi.get(self, "drain_timeout")

    @property
    @pulumi.getter(name="maxSurge")
    def max_surge(self) -> Optional['outputs.Mk8sV1alpha1NodeGroupStrategyMaxSurge']:
        """
        The maximum number of machines that can be scheduled above the
        desired number of machines.
        Value can be an absolute number (ex: 5) or a percentage of
        desired machines (ex: 10%).
        This can not be 0 if MaxUnavailable is 0.
        Absolute number is calculated from percentage by rounding up.
        Defaults to 1.
        Example: when this is set to 30%, the new MachineSet can be scaled
        up immediately when the rolling update starts, such that the total
        number of old and new machines do not exceed 130% of desired
        machines. Once old machines have been killed, new MachineSet can
        be scaled up further, ensuring that total number of machines running
        at any time during the update is at most 130% of desired machines.
        """
        return pulumi.get(self, "max_surge")

    @property
    @pulumi.getter(name="maxUnavailable")
    def max_unavailable(self) -> Optional['outputs.Mk8sV1alpha1NodeGroupStrategyMaxUnavailable']:
        """
        The maximum number of machines that can be unavailable during the update.
        Value can be an absolute number (ex: 5) or a percentage of desired
        machines (ex: 10%).
        Absolute number is calculated from percentage by rounding down.
        This can not be 0 if MaxSurge is 0.
        Defaults to 0.
        Example: when this is set to 30%, the old MachineSet can be scaled
        down to 70% of desired machines immediately when the rolling update
        starts. Once new machines are ready, old MachineSet can be scaled
        down further, followed by scaling up the new MachineSet, ensuring
        that the total number of machines available at all times
        during the update is at least 70% of desired machines.
        """
        return pulumi.get(self, "max_unavailable")


@pulumi.output_type
class Mk8sV1alpha1NodeGroupStrategyMaxSurge(dict):
    def __init__(__self__, *,
                 count: Optional[builtins.float] = None,
                 percent: Optional[builtins.float] = None):
        """
        :param builtins.float count: *Cannot be set alongside percent.*
        :param builtins.float percent: *Cannot be set alongside count.*
        """
        if count is not None:
            pulumi.set(__self__, "count", count)
        if percent is not None:
            pulumi.set(__self__, "percent", percent)

    @property
    @pulumi.getter
    def count(self) -> Optional[builtins.float]:
        """
        *Cannot be set alongside percent.*
        """
        return pulumi.get(self, "count")

    @property
    @pulumi.getter
    def percent(self) -> Optional[builtins.float]:
        """
        *Cannot be set alongside count.*
        """
        return pulumi.get(self, "percent")


@pulumi.output_type
class Mk8sV1alpha1NodeGroupStrategyMaxUnavailable(dict):
    def __init__(__self__, *,
                 count: Optional[builtins.float] = None,
                 percent: Optional[builtins.float] = None):
        """
        :param builtins.float count: *Cannot be set alongside percent.*
        :param builtins.float percent: *Cannot be set alongside count.*
        """
        if count is not None:
            pulumi.set(__self__, "count", count)
        if percent is not None:
            pulumi.set(__self__, "percent", percent)

    @property
    @pulumi.getter
    def count(self) -> Optional[builtins.float]:
        """
        *Cannot be set alongside percent.*
        """
        return pulumi.get(self, "count")

    @property
    @pulumi.getter
    def percent(self) -> Optional[builtins.float]:
        """
        *Cannot be set alongside count.*
        """
        return pulumi.get(self, "percent")


@pulumi.output_type
class Mk8sV1alpha1NodeGroupTemplate(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "bootDisk":
            suggest = "boot_disk"
        elif key == "cloudInitUserData":
            suggest = "cloud_init_user_data"
        elif key == "gpuCluster":
            suggest = "gpu_cluster"
        elif key == "gpuSettings":
            suggest = "gpu_settings"
        elif key == "networkInterfaces":
            suggest = "network_interfaces"
        elif key == "serviceAccountId":
            suggest = "service_account_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in Mk8sV1alpha1NodeGroupTemplate. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        Mk8sV1alpha1NodeGroupTemplate.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        Mk8sV1alpha1NodeGroupTemplate.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 resources: 'outputs.Mk8sV1alpha1NodeGroupTemplateResources',
                 boot_disk: Optional['outputs.Mk8sV1alpha1NodeGroupTemplateBootDisk'] = None,
                 cloud_init_user_data: Optional[builtins.str] = None,
                 filesystems: Optional[Sequence['outputs.Mk8sV1alpha1NodeGroupTemplateFilesystem']] = None,
                 gpu_cluster: Optional['outputs.Mk8sV1alpha1NodeGroupTemplateGpuCluster'] = None,
                 gpu_settings: Optional['outputs.Mk8sV1alpha1NodeGroupTemplateGpuSettings'] = None,
                 metadata: Optional['outputs.Mk8sV1alpha1NodeGroupTemplateMetadata'] = None,
                 network_interfaces: Optional[Sequence['outputs.Mk8sV1alpha1NodeGroupTemplateNetworkInterface']] = None,
                 service_account_id: Optional[builtins.str] = None,
                 taints: Optional[Sequence['outputs.Mk8sV1alpha1NodeGroupTemplateTaint']] = None):
        """
        :param builtins.str cloud_init_user_data: cloud-init user-data. Must contain at least one SSH key.
        :param 'Mk8sV1alpha1NodeGroupTemplateGpuSettingsArgs' gpu_settings: GPU-related settings.
               
               ### Inner value description
               
               GPU-related settings.
        :param builtins.str service_account_id: the Nebius service account whose credentials will be available on the nodes of the group.
               With these credentials, it is possible to make `npc` or public API requests from the nodes without the need for extra authentication.
               This service account is also used to make requests to container registry.
               
               `resource.serviceaccount.issueAccessToken` permission is required to use this field.
        :param Sequence['Mk8sV1alpha1NodeGroupTemplateTaintArgs'] taints: ### Inner value description
               
               See https://kubernetes.io/docs/concepts/scheduling-eviction/taint-and-toleration/
        """
        pulumi.set(__self__, "resources", resources)
        if boot_disk is not None:
            pulumi.set(__self__, "boot_disk", boot_disk)
        if cloud_init_user_data is not None:
            pulumi.set(__self__, "cloud_init_user_data", cloud_init_user_data)
        if filesystems is not None:
            pulumi.set(__self__, "filesystems", filesystems)
        if gpu_cluster is not None:
            pulumi.set(__self__, "gpu_cluster", gpu_cluster)
        if gpu_settings is not None:
            pulumi.set(__self__, "gpu_settings", gpu_settings)
        if metadata is not None:
            pulumi.set(__self__, "metadata", metadata)
        if network_interfaces is not None:
            pulumi.set(__self__, "network_interfaces", network_interfaces)
        if service_account_id is not None:
            pulumi.set(__self__, "service_account_id", service_account_id)
        if taints is not None:
            pulumi.set(__self__, "taints", taints)

    @property
    @pulumi.getter
    def resources(self) -> 'outputs.Mk8sV1alpha1NodeGroupTemplateResources':
        return pulumi.get(self, "resources")

    @property
    @pulumi.getter(name="bootDisk")
    def boot_disk(self) -> Optional['outputs.Mk8sV1alpha1NodeGroupTemplateBootDisk']:
        return pulumi.get(self, "boot_disk")

    @property
    @pulumi.getter(name="cloudInitUserData")
    def cloud_init_user_data(self) -> Optional[builtins.str]:
        """
        cloud-init user-data. Must contain at least one SSH key.
        """
        return pulumi.get(self, "cloud_init_user_data")

    @property
    @pulumi.getter
    def filesystems(self) -> Optional[Sequence['outputs.Mk8sV1alpha1NodeGroupTemplateFilesystem']]:
        return pulumi.get(self, "filesystems")

    @property
    @pulumi.getter(name="gpuCluster")
    def gpu_cluster(self) -> Optional['outputs.Mk8sV1alpha1NodeGroupTemplateGpuCluster']:
        return pulumi.get(self, "gpu_cluster")

    @property
    @pulumi.getter(name="gpuSettings")
    def gpu_settings(self) -> Optional['outputs.Mk8sV1alpha1NodeGroupTemplateGpuSettings']:
        """
        GPU-related settings.

        ### Inner value description

        GPU-related settings.
        """
        return pulumi.get(self, "gpu_settings")

    @property
    @pulumi.getter
    def metadata(self) -> Optional['outputs.Mk8sV1alpha1NodeGroupTemplateMetadata']:
        return pulumi.get(self, "metadata")

    @property
    @pulumi.getter(name="networkInterfaces")
    def network_interfaces(self) -> Optional[Sequence['outputs.Mk8sV1alpha1NodeGroupTemplateNetworkInterface']]:
        return pulumi.get(self, "network_interfaces")

    @property
    @pulumi.getter(name="serviceAccountId")
    def service_account_id(self) -> Optional[builtins.str]:
        """
        the Nebius service account whose credentials will be available on the nodes of the group.
        With these credentials, it is possible to make `npc` or public API requests from the nodes without the need for extra authentication.
        This service account is also used to make requests to container registry.

        `resource.serviceaccount.issueAccessToken` permission is required to use this field.
        """
        return pulumi.get(self, "service_account_id")

    @property
    @pulumi.getter
    def taints(self) -> Optional[Sequence['outputs.Mk8sV1alpha1NodeGroupTemplateTaint']]:
        """
        ### Inner value description

        See https://kubernetes.io/docs/concepts/scheduling-eviction/taint-and-toleration/
        """
        return pulumi.get(self, "taints")


@pulumi.output_type
class Mk8sV1alpha1NodeGroupTemplateBootDisk(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "blockSizeBytes":
            suggest = "block_size_bytes"
        elif key == "sizeBytes":
            suggest = "size_bytes"
        elif key == "sizeGibibytes":
            suggest = "size_gibibytes"
        elif key == "sizeKibibytes":
            suggest = "size_kibibytes"
        elif key == "sizeMebibytes":
            suggest = "size_mebibytes"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in Mk8sV1alpha1NodeGroupTemplateBootDisk. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        Mk8sV1alpha1NodeGroupTemplateBootDisk.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        Mk8sV1alpha1NodeGroupTemplateBootDisk.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 block_size_bytes: Optional[builtins.float] = None,
                 size_bytes: Optional[builtins.float] = None,
                 size_gibibytes: Optional[builtins.float] = None,
                 size_kibibytes: Optional[builtins.float] = None,
                 size_mebibytes: Optional[builtins.float] = None,
                 type: Optional[builtins.str] = None):
        """
        :param builtins.float size_bytes: *Cannot be set alongside size_kibibytes or size_gibibytes.*
        :param builtins.float size_gibibytes: *Cannot be set alongside size_bytes or size_mebibytes.*
        :param builtins.float size_kibibytes: *Cannot be set alongside size_bytes or size_gibibytes.*
        :param builtins.float size_mebibytes: *Cannot be set alongside size_bytes or size_gibibytes.*
        :param builtins.str type: ### Supported values
               
               Possible values:
               
                - `UNSPECIFIED`
                - `NETWORK_SSD` - the list of available types will be clarified later, it is not final version
                - `NETWORK_HDD`
                - `NETWORK_SSD_IO_M3`
                - `NETWORK_SSD_NON_REPLICATED`
        """
        if block_size_bytes is not None:
            pulumi.set(__self__, "block_size_bytes", block_size_bytes)
        if size_bytes is not None:
            pulumi.set(__self__, "size_bytes", size_bytes)
        if size_gibibytes is not None:
            pulumi.set(__self__, "size_gibibytes", size_gibibytes)
        if size_kibibytes is not None:
            pulumi.set(__self__, "size_kibibytes", size_kibibytes)
        if size_mebibytes is not None:
            pulumi.set(__self__, "size_mebibytes", size_mebibytes)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter(name="blockSizeBytes")
    def block_size_bytes(self) -> Optional[builtins.float]:
        return pulumi.get(self, "block_size_bytes")

    @property
    @pulumi.getter(name="sizeBytes")
    def size_bytes(self) -> Optional[builtins.float]:
        """
        *Cannot be set alongside size_kibibytes or size_gibibytes.*
        """
        return pulumi.get(self, "size_bytes")

    @property
    @pulumi.getter(name="sizeGibibytes")
    def size_gibibytes(self) -> Optional[builtins.float]:
        """
        *Cannot be set alongside size_bytes or size_mebibytes.*
        """
        return pulumi.get(self, "size_gibibytes")

    @property
    @pulumi.getter(name="sizeKibibytes")
    def size_kibibytes(self) -> Optional[builtins.float]:
        """
        *Cannot be set alongside size_bytes or size_gibibytes.*
        """
        return pulumi.get(self, "size_kibibytes")

    @property
    @pulumi.getter(name="sizeMebibytes")
    def size_mebibytes(self) -> Optional[builtins.float]:
        """
        *Cannot be set alongside size_bytes or size_gibibytes.*
        """
        return pulumi.get(self, "size_mebibytes")

    @property
    @pulumi.getter
    def type(self) -> Optional[builtins.str]:
        """
        ### Supported values

        Possible values:

         - `UNSPECIFIED`
         - `NETWORK_SSD` - the list of available types will be clarified later, it is not final version
         - `NETWORK_HDD`
         - `NETWORK_SSD_IO_M3`
         - `NETWORK_SSD_NON_REPLICATED`
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class Mk8sV1alpha1NodeGroupTemplateFilesystem(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "attachMode":
            suggest = "attach_mode"
        elif key == "deviceName":
            suggest = "device_name"
        elif key == "existingFilesystem":
            suggest = "existing_filesystem"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in Mk8sV1alpha1NodeGroupTemplateFilesystem. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        Mk8sV1alpha1NodeGroupTemplateFilesystem.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        Mk8sV1alpha1NodeGroupTemplateFilesystem.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 attach_mode: builtins.str,
                 device_name: builtins.str,
                 existing_filesystem: Optional['outputs.Mk8sV1alpha1NodeGroupTemplateFilesystemExistingFilesystem'] = None):
        """
        :param builtins.str attach_mode: ### Supported values
               
               Possible values:
               
                - `UNSPECIFIED`
                - `READ_ONLY`
                - `READ_WRITE`
        """
        pulumi.set(__self__, "attach_mode", attach_mode)
        pulumi.set(__self__, "device_name", device_name)
        if existing_filesystem is not None:
            pulumi.set(__self__, "existing_filesystem", existing_filesystem)

    @property
    @pulumi.getter(name="attachMode")
    def attach_mode(self) -> builtins.str:
        """
        ### Supported values

        Possible values:

         - `UNSPECIFIED`
         - `READ_ONLY`
         - `READ_WRITE`
        """
        return pulumi.get(self, "attach_mode")

    @property
    @pulumi.getter(name="deviceName")
    def device_name(self) -> builtins.str:
        return pulumi.get(self, "device_name")

    @property
    @pulumi.getter(name="existingFilesystem")
    def existing_filesystem(self) -> Optional['outputs.Mk8sV1alpha1NodeGroupTemplateFilesystemExistingFilesystem']:
        return pulumi.get(self, "existing_filesystem")


@pulumi.output_type
class Mk8sV1alpha1NodeGroupTemplateFilesystemExistingFilesystem(dict):
    def __init__(__self__, *,
                 id: builtins.str):
        pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> builtins.str:
        return pulumi.get(self, "id")


@pulumi.output_type
class Mk8sV1alpha1NodeGroupTemplateGpuCluster(dict):
    def __init__(__self__, *,
                 id: Optional[builtins.str] = None):
        if id is not None:
            pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> Optional[builtins.str]:
        return pulumi.get(self, "id")


@pulumi.output_type
class Mk8sV1alpha1NodeGroupTemplateGpuSettings(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "driversPreset":
            suggest = "drivers_preset"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in Mk8sV1alpha1NodeGroupTemplateGpuSettings. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        Mk8sV1alpha1NodeGroupTemplateGpuSettings.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        Mk8sV1alpha1NodeGroupTemplateGpuSettings.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 drivers_preset: builtins.str):
        """
        :param builtins.str drivers_preset: Identifier of the predefined set of drivers included in the ComputeImage deployed on ComputeInstances that are part of the NodeGroup.
               Supported presets: cuda12
        """
        pulumi.set(__self__, "drivers_preset", drivers_preset)

    @property
    @pulumi.getter(name="driversPreset")
    def drivers_preset(self) -> builtins.str:
        """
        Identifier of the predefined set of drivers included in the ComputeImage deployed on ComputeInstances that are part of the NodeGroup.
        Supported presets: cuda12
        """
        return pulumi.get(self, "drivers_preset")


@pulumi.output_type
class Mk8sV1alpha1NodeGroupTemplateMetadata(dict):
    def __init__(__self__, *,
                 labels: Optional[Mapping[str, builtins.str]] = None):
        """
        :param Mapping[str, builtins.str] labels: Labels will be propagated into nodes metadata.
               System labels containing "kubernetes.io" and "k8s.io" will not be propagated.
               On update labels they will not be updated in nodes right away, only on node group update.
        """
        if labels is not None:
            pulumi.set(__self__, "labels", labels)

    @property
    @pulumi.getter
    def labels(self) -> Optional[Mapping[str, builtins.str]]:
        """
        Labels will be propagated into nodes metadata.
        System labels containing "kubernetes.io" and "k8s.io" will not be propagated.
        On update labels they will not be updated in nodes right away, only on node group update.
        """
        return pulumi.get(self, "labels")


@pulumi.output_type
class Mk8sV1alpha1NodeGroupTemplateNetworkInterface(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "publicIpAddress":
            suggest = "public_ip_address"
        elif key == "subnetId":
            suggest = "subnet_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in Mk8sV1alpha1NodeGroupTemplateNetworkInterface. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        Mk8sV1alpha1NodeGroupTemplateNetworkInterface.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        Mk8sV1alpha1NodeGroupTemplateNetworkInterface.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 public_ip_address: Optional['outputs.Mk8sV1alpha1NodeGroupTemplateNetworkInterfacePublicIpAddress'] = None,
                 subnet_id: Optional[builtins.str] = None):
        """
        :param 'Mk8sV1alpha1NodeGroupTemplateNetworkInterfacePublicIpAddressArgs' public_ip_address: Public IPv4 address associated with the interface.
               
               ### Inner value description
               
               Describes a public IP address.
        :param builtins.str subnet_id: Subnet ID that will be attached to a node cloud intstance network interface.
               By default control plane subnet_id used.
               Subnet should be located in the same network with control plane and have same parent ID as cluster.
        """
        if public_ip_address is not None:
            pulumi.set(__self__, "public_ip_address", public_ip_address)
        if subnet_id is not None:
            pulumi.set(__self__, "subnet_id", subnet_id)

    @property
    @pulumi.getter(name="publicIpAddress")
    def public_ip_address(self) -> Optional['outputs.Mk8sV1alpha1NodeGroupTemplateNetworkInterfacePublicIpAddress']:
        """
        Public IPv4 address associated with the interface.

        ### Inner value description

        Describes a public IP address.
        """
        return pulumi.get(self, "public_ip_address")

    @property
    @pulumi.getter(name="subnetId")
    def subnet_id(self) -> Optional[builtins.str]:
        """
        Subnet ID that will be attached to a node cloud intstance network interface.
        By default control plane subnet_id used.
        Subnet should be located in the same network with control plane and have same parent ID as cluster.
        """
        return pulumi.get(self, "subnet_id")


@pulumi.output_type
class Mk8sV1alpha1NodeGroupTemplateNetworkInterfacePublicIpAddress(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class Mk8sV1alpha1NodeGroupTemplateResources(dict):
    def __init__(__self__, *,
                 platform: builtins.str,
                 preset: Optional[builtins.str] = None):
        pulumi.set(__self__, "platform", platform)
        if preset is not None:
            pulumi.set(__self__, "preset", preset)

    @property
    @pulumi.getter
    def platform(self) -> builtins.str:
        return pulumi.get(self, "platform")

    @property
    @pulumi.getter
    def preset(self) -> Optional[builtins.str]:
        return pulumi.get(self, "preset")


@pulumi.output_type
class Mk8sV1alpha1NodeGroupTemplateTaint(dict):
    def __init__(__self__, *,
                 effect: builtins.str,
                 key: builtins.str,
                 value: builtins.str):
        """
        :param builtins.str effect: ### Supported values
               
               Possible values:
               
                - `EFFECT_UNSPECIFIED`
                - `NO_EXECUTE`
                - `NO_SCHEDULE`
                - `PREFER_NO_SCHEDULE`
        """
        pulumi.set(__self__, "effect", effect)
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def effect(self) -> builtins.str:
        """
        ### Supported values

        Possible values:

         - `EFFECT_UNSPECIFIED`
         - `NO_EXECUTE`
         - `NO_SCHEDULE`
         - `PREFER_NO_SCHEDULE`
        """
        return pulumi.get(self, "effect")

    @property
    @pulumi.getter
    def key(self) -> builtins.str:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def value(self) -> builtins.str:
        return pulumi.get(self, "value")


@pulumi.output_type
class MspMlflowV1alpha1ClusterMetadata(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class MspMlflowV1alpha1ClusterStatus(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "effectiveStorageBucketName":
            suggest = "effective_storage_bucket_name"
        elif key == "experimentsCount":
            suggest = "experiments_count"
        elif key == "mlflowVersion":
            suggest = "mlflow_version"
        elif key == "trackingEndpoint":
            suggest = "tracking_endpoint"
        elif key == "trackingEndpoints":
            suggest = "tracking_endpoints"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MspMlflowV1alpha1ClusterStatus. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MspMlflowV1alpha1ClusterStatus.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MspMlflowV1alpha1ClusterStatus.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 effective_storage_bucket_name: Optional[builtins.str] = None,
                 experiments_count: Optional[builtins.float] = None,
                 mlflow_version: Optional[builtins.str] = None,
                 phase: Optional[builtins.str] = None,
                 state: Optional[builtins.str] = None,
                 tracking_endpoint: Optional[builtins.str] = None,
                 tracking_endpoints: Optional['outputs.MspMlflowV1alpha1ClusterStatusTrackingEndpoints'] = None):
        """
        :param builtins.str effective_storage_bucket_name: Name of the Nebius S3 bucket for MLflow artifacts.
        :param builtins.float experiments_count: Count of experiments in the MLflow cluster
        :param builtins.str mlflow_version: MLflow version
        :param builtins.str phase: Current phase of the cluster.
               
               ### Supported values
               
               Possible values:
               
                - `PHASE_UNSPECIFIED`
                - `PHASE_PROVISIONING`
                - `PHASE_RUNNING`
                - `PHASE_UPDATING`
                - `PHASE_DELETING`
                - `PHASE_DELETED`
                - `PHASE_PURGING`
                - `PHASE_STOPPING`
                - `PHASE_RESUMING`
        :param builtins.str state: State reflects substatus of the phase to define whether it's healthy or not.
               
               ### Supported values
               
               Possible values:
               
                - `STATE_UNSPECIFIED`
                - `STATE_IN_PROGRESS`
                - `STATE_FINISHED`
                - `STATE_ERROR`
                - `STATE_DEGRADED`
                - `STATE_SCHEDULED`
        :param builtins.str tracking_endpoint: Tracking endpoint url.
               Will be removed soon in favor of private_tracking_endpoint and public_tracking_endpoint.
        :param 'MspMlflowV1alpha1ClusterStatusTrackingEndpointsArgs' tracking_endpoints: Public and private tracking endpoints
        """
        if effective_storage_bucket_name is not None:
            pulumi.set(__self__, "effective_storage_bucket_name", effective_storage_bucket_name)
        if experiments_count is not None:
            pulumi.set(__self__, "experiments_count", experiments_count)
        if mlflow_version is not None:
            pulumi.set(__self__, "mlflow_version", mlflow_version)
        if phase is not None:
            pulumi.set(__self__, "phase", phase)
        if state is not None:
            pulumi.set(__self__, "state", state)
        if tracking_endpoint is not None:
            pulumi.set(__self__, "tracking_endpoint", tracking_endpoint)
        if tracking_endpoints is not None:
            pulumi.set(__self__, "tracking_endpoints", tracking_endpoints)

    @property
    @pulumi.getter(name="effectiveStorageBucketName")
    def effective_storage_bucket_name(self) -> Optional[builtins.str]:
        """
        Name of the Nebius S3 bucket for MLflow artifacts.
        """
        return pulumi.get(self, "effective_storage_bucket_name")

    @property
    @pulumi.getter(name="experimentsCount")
    def experiments_count(self) -> Optional[builtins.float]:
        """
        Count of experiments in the MLflow cluster
        """
        return pulumi.get(self, "experiments_count")

    @property
    @pulumi.getter(name="mlflowVersion")
    def mlflow_version(self) -> Optional[builtins.str]:
        """
        MLflow version
        """
        return pulumi.get(self, "mlflow_version")

    @property
    @pulumi.getter
    def phase(self) -> Optional[builtins.str]:
        """
        Current phase of the cluster.

        ### Supported values

        Possible values:

         - `PHASE_UNSPECIFIED`
         - `PHASE_PROVISIONING`
         - `PHASE_RUNNING`
         - `PHASE_UPDATING`
         - `PHASE_DELETING`
         - `PHASE_DELETED`
         - `PHASE_PURGING`
         - `PHASE_STOPPING`
         - `PHASE_RESUMING`
        """
        return pulumi.get(self, "phase")

    @property
    @pulumi.getter
    def state(self) -> Optional[builtins.str]:
        """
        State reflects substatus of the phase to define whether it's healthy or not.

        ### Supported values

        Possible values:

         - `STATE_UNSPECIFIED`
         - `STATE_IN_PROGRESS`
         - `STATE_FINISHED`
         - `STATE_ERROR`
         - `STATE_DEGRADED`
         - `STATE_SCHEDULED`
        """
        return pulumi.get(self, "state")

    @property
    @pulumi.getter(name="trackingEndpoint")
    def tracking_endpoint(self) -> Optional[builtins.str]:
        """
        Tracking endpoint url.
        Will be removed soon in favor of private_tracking_endpoint and public_tracking_endpoint.
        """
        return pulumi.get(self, "tracking_endpoint")

    @property
    @pulumi.getter(name="trackingEndpoints")
    def tracking_endpoints(self) -> Optional['outputs.MspMlflowV1alpha1ClusterStatusTrackingEndpoints']:
        """
        Public and private tracking endpoints
        """
        return pulumi.get(self, "tracking_endpoints")


@pulumi.output_type
class MspMlflowV1alpha1ClusterStatusTrackingEndpoints(dict):
    def __init__(__self__, *,
                 private: Optional[builtins.str] = None,
                 public: Optional[builtins.str] = None):
        """
        :param builtins.str private: Private endpoint
        :param builtins.str public: Public endpoint
        """
        if private is not None:
            pulumi.set(__self__, "private", private)
        if public is not None:
            pulumi.set(__self__, "public", public)

    @property
    @pulumi.getter
    def private(self) -> Optional[builtins.str]:
        """
        Private endpoint
        """
        return pulumi.get(self, "private")

    @property
    @pulumi.getter
    def public(self) -> Optional[builtins.str]:
        """
        Public endpoint
        """
        return pulumi.get(self, "public")


@pulumi.output_type
class MspPostgresqlV1alpha1ClusterBackup(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "backupWindowStart":
            suggest = "backup_window_start"
        elif key == "retentionPolicy":
            suggest = "retention_policy"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MspPostgresqlV1alpha1ClusterBackup. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MspPostgresqlV1alpha1ClusterBackup.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MspPostgresqlV1alpha1ClusterBackup.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 backup_window_start: Optional[builtins.str] = None,
                 retention_policy: Optional[builtins.str] = None):
        """
        :param builtins.str backup_window_start: Backup window start in "HH:MM:SS" format (UTC Time)
        :param builtins.str retention_policy: Retention policy to be used for backups and WALs (i.e. '7d')
        """
        if backup_window_start is not None:
            pulumi.set(__self__, "backup_window_start", backup_window_start)
        if retention_policy is not None:
            pulumi.set(__self__, "retention_policy", retention_policy)

    @property
    @pulumi.getter(name="backupWindowStart")
    def backup_window_start(self) -> Optional[builtins.str]:
        """
        Backup window start in "HH:MM:SS" format (UTC Time)
        """
        return pulumi.get(self, "backup_window_start")

    @property
    @pulumi.getter(name="retentionPolicy")
    def retention_policy(self) -> Optional[builtins.str]:
        """
        Retention policy to be used for backups and WALs (i.e. '7d')
        """
        return pulumi.get(self, "retention_policy")


@pulumi.output_type
class MspPostgresqlV1alpha1ClusterBootstrap(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dbName":
            suggest = "db_name"
        elif key == "userName":
            suggest = "user_name"
        elif key == "userPassword":
            suggest = "user_password"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MspPostgresqlV1alpha1ClusterBootstrap. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MspPostgresqlV1alpha1ClusterBootstrap.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MspPostgresqlV1alpha1ClusterBootstrap.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 db_name: builtins.str,
                 user_name: builtins.str,
                 user_password: Optional[builtins.str] = None):
        """
        :param builtins.str db_name: Name of the PostgreSQL database. 1-63 characters long.
        :param builtins.str user_name: Name of the bootstrap PostgreSQL user.
        :param builtins.str user_password: Password of the bootstrap PostgreSQL user.
        """
        pulumi.set(__self__, "db_name", db_name)
        pulumi.set(__self__, "user_name", user_name)
        if user_password is not None:
            pulumi.set(__self__, "user_password", user_password)

    @property
    @pulumi.getter(name="dbName")
    def db_name(self) -> builtins.str:
        """
        Name of the PostgreSQL database. 1-63 characters long.
        """
        return pulumi.get(self, "db_name")

    @property
    @pulumi.getter(name="userName")
    def user_name(self) -> builtins.str:
        """
        Name of the bootstrap PostgreSQL user.
        """
        return pulumi.get(self, "user_name")

    @property
    @pulumi.getter(name="userPassword")
    def user_password(self) -> Optional[builtins.str]:
        """
        Password of the bootstrap PostgreSQL user.
        """
        return pulumi.get(self, "user_password")


@pulumi.output_type
class MspPostgresqlV1alpha1ClusterConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "poolerConfig":
            suggest = "pooler_config"
        elif key == "postgresqlConfig16":
            suggest = "postgresql_config16"
        elif key == "publicAccess":
            suggest = "public_access"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MspPostgresqlV1alpha1ClusterConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MspPostgresqlV1alpha1ClusterConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MspPostgresqlV1alpha1ClusterConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 template: 'outputs.MspPostgresqlV1alpha1ClusterConfigTemplate',
                 version: builtins.str,
                 pooler_config: Optional['outputs.MspPostgresqlV1alpha1ClusterConfigPoolerConfig'] = None,
                 postgresql_config16: Optional['outputs.MspPostgresqlV1alpha1ClusterConfigPostgresqlConfig16'] = None,
                 public_access: Optional[builtins.bool] = None):
        """
        :param 'MspPostgresqlV1alpha1ClusterConfigTemplateArgs' template: Resources allocated to PostgreSQL hosts.
        :param builtins.str version: Version of PostgreSQL used in the cluster.
               Possible values: `16`
        :param 'MspPostgresqlV1alpha1ClusterConfigPoolerConfigArgs' pooler_config: Configuration of the connection pooler.
        :param 'MspPostgresqlV1alpha1ClusterConfigPostgresqlConfig16Args' postgresql_config16: Configuration parameters for postgres
        :param builtins.bool public_access: Either make cluster public accessible or accessible only via private VPC.
        """
        pulumi.set(__self__, "template", template)
        pulumi.set(__self__, "version", version)
        if pooler_config is not None:
            pulumi.set(__self__, "pooler_config", pooler_config)
        if postgresql_config16 is not None:
            pulumi.set(__self__, "postgresql_config16", postgresql_config16)
        if public_access is not None:
            pulumi.set(__self__, "public_access", public_access)

    @property
    @pulumi.getter
    def template(self) -> 'outputs.MspPostgresqlV1alpha1ClusterConfigTemplate':
        """
        Resources allocated to PostgreSQL hosts.
        """
        return pulumi.get(self, "template")

    @property
    @pulumi.getter
    def version(self) -> builtins.str:
        """
        Version of PostgreSQL used in the cluster.
        Possible values: `16`
        """
        return pulumi.get(self, "version")

    @property
    @pulumi.getter(name="poolerConfig")
    def pooler_config(self) -> Optional['outputs.MspPostgresqlV1alpha1ClusterConfigPoolerConfig']:
        """
        Configuration of the connection pooler.
        """
        return pulumi.get(self, "pooler_config")

    @property
    @pulumi.getter(name="postgresqlConfig16")
    def postgresql_config16(self) -> Optional['outputs.MspPostgresqlV1alpha1ClusterConfigPostgresqlConfig16']:
        """
        Configuration parameters for postgres
        """
        return pulumi.get(self, "postgresql_config16")

    @property
    @pulumi.getter(name="publicAccess")
    def public_access(self) -> Optional[builtins.bool]:
        """
        Either make cluster public accessible or accessible only via private VPC.
        """
        return pulumi.get(self, "public_access")


@pulumi.output_type
class MspPostgresqlV1alpha1ClusterConfigPoolerConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "maxPoolSize":
            suggest = "max_pool_size"
        elif key == "poolingMode":
            suggest = "pooling_mode"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MspPostgresqlV1alpha1ClusterConfigPoolerConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MspPostgresqlV1alpha1ClusterConfigPoolerConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MspPostgresqlV1alpha1ClusterConfigPoolerConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 max_pool_size: Optional[builtins.float] = None,
                 pooling_mode: Optional[builtins.str] = None):
        """
        :param builtins.float max_pool_size: Maximum number of connections in the pool for a single database.
        :param builtins.str pooling_mode: Mode that the connection pooler is working in.
               
               ### Supported values
               
               Possible values:
               
                - `POOLING_MODE_UNSPECIFIED`
                - `SESSION` - Session pooling mode.
                - `TRANSACTION` - Transaction pooling mode.
        """
        if max_pool_size is not None:
            pulumi.set(__self__, "max_pool_size", max_pool_size)
        if pooling_mode is not None:
            pulumi.set(__self__, "pooling_mode", pooling_mode)

    @property
    @pulumi.getter(name="maxPoolSize")
    def max_pool_size(self) -> Optional[builtins.float]:
        """
        Maximum number of connections in the pool for a single database.
        """
        return pulumi.get(self, "max_pool_size")

    @property
    @pulumi.getter(name="poolingMode")
    def pooling_mode(self) -> Optional[builtins.str]:
        """
        Mode that the connection pooler is working in.

        ### Supported values

        Possible values:

         - `POOLING_MODE_UNSPECIFIED`
         - `SESSION` - Session pooling mode.
         - `TRANSACTION` - Transaction pooling mode.
        """
        return pulumi.get(self, "pooling_mode")


@pulumi.output_type
class MspPostgresqlV1alpha1ClusterConfigPostgresqlConfig16(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "autovacuumAnalyzeScaleFactor":
            suggest = "autovacuum_analyze_scale_factor"
        elif key == "autovacuumNaptime":
            suggest = "autovacuum_naptime"
        elif key == "autovacuumVacuumCostDelay":
            suggest = "autovacuum_vacuum_cost_delay"
        elif key == "autovacuumVacuumCostLimit":
            suggest = "autovacuum_vacuum_cost_limit"
        elif key == "autovacuumVacuumScaleFactor":
            suggest = "autovacuum_vacuum_scale_factor"
        elif key == "autovacuumWorkMem":
            suggest = "autovacuum_work_mem"
        elif key == "defaultTransactionReadOnly":
            suggest = "default_transaction_read_only"
        elif key == "idleInTransactionSessionTimeout":
            suggest = "idle_in_transaction_session_timeout"
        elif key == "maxConnections":
            suggest = "max_connections"
        elif key == "searchPath":
            suggest = "search_path"
        elif key == "sharedBuffers":
            suggest = "shared_buffers"
        elif key == "statementTimeout":
            suggest = "statement_timeout"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MspPostgresqlV1alpha1ClusterConfigPostgresqlConfig16. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MspPostgresqlV1alpha1ClusterConfigPostgresqlConfig16.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MspPostgresqlV1alpha1ClusterConfigPostgresqlConfig16.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 autovacuum_analyze_scale_factor: Optional[builtins.float] = None,
                 autovacuum_naptime: Optional[builtins.float] = None,
                 autovacuum_vacuum_cost_delay: Optional[builtins.float] = None,
                 autovacuum_vacuum_cost_limit: Optional[builtins.float] = None,
                 autovacuum_vacuum_scale_factor: Optional[builtins.float] = None,
                 autovacuum_work_mem: Optional[builtins.float] = None,
                 default_transaction_read_only: Optional[builtins.bool] = None,
                 idle_in_transaction_session_timeout: Optional[builtins.float] = None,
                 max_connections: Optional[builtins.float] = None,
                 search_path: Optional[builtins.str] = None,
                 shared_buffers: Optional[builtins.float] = None,
                 statement_timeout: Optional[builtins.float] = None):
        """
        :param builtins.float autovacuum_naptime: in seconds.
        :param builtins.float autovacuum_vacuum_cost_delay: in milliseconds.
        :param builtins.float autovacuum_work_mem: in kilobytes.
        :param builtins.float idle_in_transaction_session_timeout: in milliseconds.
        :param builtins.float shared_buffers: in kilobytes.
        :param builtins.float statement_timeout: in milliseconds.
        """
        if autovacuum_analyze_scale_factor is not None:
            pulumi.set(__self__, "autovacuum_analyze_scale_factor", autovacuum_analyze_scale_factor)
        if autovacuum_naptime is not None:
            pulumi.set(__self__, "autovacuum_naptime", autovacuum_naptime)
        if autovacuum_vacuum_cost_delay is not None:
            pulumi.set(__self__, "autovacuum_vacuum_cost_delay", autovacuum_vacuum_cost_delay)
        if autovacuum_vacuum_cost_limit is not None:
            pulumi.set(__self__, "autovacuum_vacuum_cost_limit", autovacuum_vacuum_cost_limit)
        if autovacuum_vacuum_scale_factor is not None:
            pulumi.set(__self__, "autovacuum_vacuum_scale_factor", autovacuum_vacuum_scale_factor)
        if autovacuum_work_mem is not None:
            pulumi.set(__self__, "autovacuum_work_mem", autovacuum_work_mem)
        if default_transaction_read_only is not None:
            pulumi.set(__self__, "default_transaction_read_only", default_transaction_read_only)
        if idle_in_transaction_session_timeout is not None:
            pulumi.set(__self__, "idle_in_transaction_session_timeout", idle_in_transaction_session_timeout)
        if max_connections is not None:
            pulumi.set(__self__, "max_connections", max_connections)
        if search_path is not None:
            pulumi.set(__self__, "search_path", search_path)
        if shared_buffers is not None:
            pulumi.set(__self__, "shared_buffers", shared_buffers)
        if statement_timeout is not None:
            pulumi.set(__self__, "statement_timeout", statement_timeout)

    @property
    @pulumi.getter(name="autovacuumAnalyzeScaleFactor")
    def autovacuum_analyze_scale_factor(self) -> Optional[builtins.float]:
        return pulumi.get(self, "autovacuum_analyze_scale_factor")

    @property
    @pulumi.getter(name="autovacuumNaptime")
    def autovacuum_naptime(self) -> Optional[builtins.float]:
        """
        in seconds.
        """
        return pulumi.get(self, "autovacuum_naptime")

    @property
    @pulumi.getter(name="autovacuumVacuumCostDelay")
    def autovacuum_vacuum_cost_delay(self) -> Optional[builtins.float]:
        """
        in milliseconds.
        """
        return pulumi.get(self, "autovacuum_vacuum_cost_delay")

    @property
    @pulumi.getter(name="autovacuumVacuumCostLimit")
    def autovacuum_vacuum_cost_limit(self) -> Optional[builtins.float]:
        return pulumi.get(self, "autovacuum_vacuum_cost_limit")

    @property
    @pulumi.getter(name="autovacuumVacuumScaleFactor")
    def autovacuum_vacuum_scale_factor(self) -> Optional[builtins.float]:
        return pulumi.get(self, "autovacuum_vacuum_scale_factor")

    @property
    @pulumi.getter(name="autovacuumWorkMem")
    def autovacuum_work_mem(self) -> Optional[builtins.float]:
        """
        in kilobytes.
        """
        return pulumi.get(self, "autovacuum_work_mem")

    @property
    @pulumi.getter(name="defaultTransactionReadOnly")
    def default_transaction_read_only(self) -> Optional[builtins.bool]:
        return pulumi.get(self, "default_transaction_read_only")

    @property
    @pulumi.getter(name="idleInTransactionSessionTimeout")
    def idle_in_transaction_session_timeout(self) -> Optional[builtins.float]:
        """
        in milliseconds.
        """
        return pulumi.get(self, "idle_in_transaction_session_timeout")

    @property
    @pulumi.getter(name="maxConnections")
    def max_connections(self) -> Optional[builtins.float]:
        return pulumi.get(self, "max_connections")

    @property
    @pulumi.getter(name="searchPath")
    def search_path(self) -> Optional[builtins.str]:
        return pulumi.get(self, "search_path")

    @property
    @pulumi.getter(name="sharedBuffers")
    def shared_buffers(self) -> Optional[builtins.float]:
        """
        in kilobytes.
        """
        return pulumi.get(self, "shared_buffers")

    @property
    @pulumi.getter(name="statementTimeout")
    def statement_timeout(self) -> Optional[builtins.float]:
        """
        in milliseconds.
        """
        return pulumi.get(self, "statement_timeout")


@pulumi.output_type
class MspPostgresqlV1alpha1ClusterConfigTemplate(dict):
    def __init__(__self__, *,
                 disk: 'outputs.MspPostgresqlV1alpha1ClusterConfigTemplateDisk',
                 hosts: 'outputs.MspPostgresqlV1alpha1ClusterConfigTemplateHosts',
                 resources: 'outputs.MspPostgresqlV1alpha1ClusterConfigTemplateResources'):
        """
        :param 'MspPostgresqlV1alpha1ClusterConfigTemplateResourcesArgs' resources: reduced msp.v1alpha1.resource.TemplateSpec
        """
        pulumi.set(__self__, "disk", disk)
        pulumi.set(__self__, "hosts", hosts)
        pulumi.set(__self__, "resources", resources)

    @property
    @pulumi.getter
    def disk(self) -> 'outputs.MspPostgresqlV1alpha1ClusterConfigTemplateDisk':
        return pulumi.get(self, "disk")

    @property
    @pulumi.getter
    def hosts(self) -> 'outputs.MspPostgresqlV1alpha1ClusterConfigTemplateHosts':
        return pulumi.get(self, "hosts")

    @property
    @pulumi.getter
    def resources(self) -> 'outputs.MspPostgresqlV1alpha1ClusterConfigTemplateResources':
        """
        reduced msp.v1alpha1.resource.TemplateSpec
        """
        return pulumi.get(self, "resources")


@pulumi.output_type
class MspPostgresqlV1alpha1ClusterConfigTemplateDisk(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sizeGibibytes":
            suggest = "size_gibibytes"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MspPostgresqlV1alpha1ClusterConfigTemplateDisk. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MspPostgresqlV1alpha1ClusterConfigTemplateDisk.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MspPostgresqlV1alpha1ClusterConfigTemplateDisk.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 size_gibibytes: builtins.float,
                 type: builtins.str):
        pulumi.set(__self__, "size_gibibytes", size_gibibytes)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter(name="sizeGibibytes")
    def size_gibibytes(self) -> builtins.float:
        return pulumi.get(self, "size_gibibytes")

    @property
    @pulumi.getter
    def type(self) -> builtins.str:
        return pulumi.get(self, "type")


@pulumi.output_type
class MspPostgresqlV1alpha1ClusterConfigTemplateHosts(dict):
    def __init__(__self__, *,
                 count: builtins.float):
        pulumi.set(__self__, "count", count)

    @property
    @pulumi.getter
    def count(self) -> builtins.float:
        return pulumi.get(self, "count")


@pulumi.output_type
class MspPostgresqlV1alpha1ClusterConfigTemplateResources(dict):
    def __init__(__self__, *,
                 platform: builtins.str,
                 preset: builtins.str):
        pulumi.set(__self__, "platform", platform)
        pulumi.set(__self__, "preset", preset)

    @property
    @pulumi.getter
    def platform(self) -> builtins.str:
        return pulumi.get(self, "platform")

    @property
    @pulumi.getter
    def preset(self) -> builtins.str:
        return pulumi.get(self, "preset")


@pulumi.output_type
class MspPostgresqlV1alpha1ClusterMetadata(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class MspPostgresqlV1alpha1ClusterStatus(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "connectionEndpoints":
            suggest = "connection_endpoints"
        elif key == "presetDetails":
            suggest = "preset_details"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MspPostgresqlV1alpha1ClusterStatus. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MspPostgresqlV1alpha1ClusterStatus.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MspPostgresqlV1alpha1ClusterStatus.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 connection_endpoints: Optional['outputs.MspPostgresqlV1alpha1ClusterStatusConnectionEndpoints'] = None,
                 phase: Optional[builtins.str] = None,
                 preset_details: Optional['outputs.MspPostgresqlV1alpha1ClusterStatusPresetDetails'] = None,
                 state: Optional[builtins.str] = None):
        """
        :param 'MspPostgresqlV1alpha1ClusterStatusConnectionEndpointsArgs' connection_endpoints: Connection endpoints of the PostgreSQL cluster.
        :param builtins.str phase: Current phase of the cluster.
               
               ### Supported values
               
               Possible values:
               
                - `PHASE_UNSPECIFIED`
                - `PHASE_PROVISIONING`
                - `PHASE_RUNNING`
                - `PHASE_UPDATING`
                - `PHASE_DELETING`
                - `PHASE_DELETED`
                - `PHASE_PURGING`
                - `PHASE_STOPPING`
                - `PHASE_RESUMING`
        :param 'MspPostgresqlV1alpha1ClusterStatusPresetDetailsArgs' preset_details: Cluster resource preset details
        :param builtins.str state: State reflects substatus of the phase to define whether it's healthy or not.
               
               ### Supported values
               
               Possible values:
               
                - `STATE_UNSPECIFIED`
                - `STATE_IN_PROGRESS`
                - `STATE_FINISHED`
                - `STATE_ERROR`
                - `STATE_DEGRADED`
                - `STATE_SCHEDULED`
        """
        if connection_endpoints is not None:
            pulumi.set(__self__, "connection_endpoints", connection_endpoints)
        if phase is not None:
            pulumi.set(__self__, "phase", phase)
        if preset_details is not None:
            pulumi.set(__self__, "preset_details", preset_details)
        if state is not None:
            pulumi.set(__self__, "state", state)

    @property
    @pulumi.getter(name="connectionEndpoints")
    def connection_endpoints(self) -> Optional['outputs.MspPostgresqlV1alpha1ClusterStatusConnectionEndpoints']:
        """
        Connection endpoints of the PostgreSQL cluster.
        """
        return pulumi.get(self, "connection_endpoints")

    @property
    @pulumi.getter
    def phase(self) -> Optional[builtins.str]:
        """
        Current phase of the cluster.

        ### Supported values

        Possible values:

         - `PHASE_UNSPECIFIED`
         - `PHASE_PROVISIONING`
         - `PHASE_RUNNING`
         - `PHASE_UPDATING`
         - `PHASE_DELETING`
         - `PHASE_DELETED`
         - `PHASE_PURGING`
         - `PHASE_STOPPING`
         - `PHASE_RESUMING`
        """
        return pulumi.get(self, "phase")

    @property
    @pulumi.getter(name="presetDetails")
    def preset_details(self) -> Optional['outputs.MspPostgresqlV1alpha1ClusterStatusPresetDetails']:
        """
        Cluster resource preset details
        """
        return pulumi.get(self, "preset_details")

    @property
    @pulumi.getter
    def state(self) -> Optional[builtins.str]:
        """
        State reflects substatus of the phase to define whether it's healthy or not.

        ### Supported values

        Possible values:

         - `STATE_UNSPECIFIED`
         - `STATE_IN_PROGRESS`
         - `STATE_FINISHED`
         - `STATE_ERROR`
         - `STATE_DEGRADED`
         - `STATE_SCHEDULED`
        """
        return pulumi.get(self, "state")


@pulumi.output_type
class MspPostgresqlV1alpha1ClusterStatusConnectionEndpoints(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "privateReadOnly":
            suggest = "private_read_only"
        elif key == "privateReadWrite":
            suggest = "private_read_write"
        elif key == "publicReadOnly":
            suggest = "public_read_only"
        elif key == "publicReadWrite":
            suggest = "public_read_write"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MspPostgresqlV1alpha1ClusterStatusConnectionEndpoints. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MspPostgresqlV1alpha1ClusterStatusConnectionEndpoints.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MspPostgresqlV1alpha1ClusterStatusConnectionEndpoints.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 private_read_only: Optional[builtins.str] = None,
                 private_read_write: Optional[builtins.str] = None,
                 public_read_only: Optional[builtins.str] = None,
                 public_read_write: Optional[builtins.str] = None):
        """
        :param builtins.str private_read_only: Read only endpoint of the PostgreSQL cluster accessible from the private VPC.
        :param builtins.str private_read_write: Read write endpoint of the PostgreSQL cluster accessible from the private VPC.
        :param builtins.str public_read_only: Read only endpoint of the PostgreSQL cluster accessible from the internet.
        :param builtins.str public_read_write: Read write endpoint of the PostgreSQL cluster accessible from the internet.
        """
        if private_read_only is not None:
            pulumi.set(__self__, "private_read_only", private_read_only)
        if private_read_write is not None:
            pulumi.set(__self__, "private_read_write", private_read_write)
        if public_read_only is not None:
            pulumi.set(__self__, "public_read_only", public_read_only)
        if public_read_write is not None:
            pulumi.set(__self__, "public_read_write", public_read_write)

    @property
    @pulumi.getter(name="privateReadOnly")
    def private_read_only(self) -> Optional[builtins.str]:
        """
        Read only endpoint of the PostgreSQL cluster accessible from the private VPC.
        """
        return pulumi.get(self, "private_read_only")

    @property
    @pulumi.getter(name="privateReadWrite")
    def private_read_write(self) -> Optional[builtins.str]:
        """
        Read write endpoint of the PostgreSQL cluster accessible from the private VPC.
        """
        return pulumi.get(self, "private_read_write")

    @property
    @pulumi.getter(name="publicReadOnly")
    def public_read_only(self) -> Optional[builtins.str]:
        """
        Read only endpoint of the PostgreSQL cluster accessible from the internet.
        """
        return pulumi.get(self, "public_read_only")

    @property
    @pulumi.getter(name="publicReadWrite")
    def public_read_write(self) -> Optional[builtins.str]:
        """
        Read write endpoint of the PostgreSQL cluster accessible from the internet.
        """
        return pulumi.get(self, "public_read_write")


@pulumi.output_type
class MspPostgresqlV1alpha1ClusterStatusPresetDetails(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "cpuCount":
            suggest = "cpu_count"
        elif key == "gpuCount":
            suggest = "gpu_count"
        elif key == "memoryGibibytes":
            suggest = "memory_gibibytes"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MspPostgresqlV1alpha1ClusterStatusPresetDetails. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MspPostgresqlV1alpha1ClusterStatusPresetDetails.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MspPostgresqlV1alpha1ClusterStatusPresetDetails.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cpu_count: Optional[builtins.float] = None,
                 gpu_count: Optional[builtins.float] = None,
                 memory_gibibytes: Optional[builtins.float] = None):
        if cpu_count is not None:
            pulumi.set(__self__, "cpu_count", cpu_count)
        if gpu_count is not None:
            pulumi.set(__self__, "gpu_count", gpu_count)
        if memory_gibibytes is not None:
            pulumi.set(__self__, "memory_gibibytes", memory_gibibytes)

    @property
    @pulumi.getter(name="cpuCount")
    def cpu_count(self) -> Optional[builtins.float]:
        return pulumi.get(self, "cpu_count")

    @property
    @pulumi.getter(name="gpuCount")
    def gpu_count(self) -> Optional[builtins.float]:
        return pulumi.get(self, "gpu_count")

    @property
    @pulumi.getter(name="memoryGibibytes")
    def memory_gibibytes(self) -> Optional[builtins.float]:
        return pulumi.get(self, "memory_gibibytes")


@pulumi.output_type
class MspSparkV1alpha1ClusterAuthorization(dict):
    def __init__(__self__, *,
                 password: builtins.str):
        pulumi.set(__self__, "password", password)

    @property
    @pulumi.getter
    def password(self) -> builtins.str:
        return pulumi.get(self, "password")


@pulumi.output_type
class MspSparkV1alpha1ClusterLimits(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "memoryGibibytes":
            suggest = "memory_gibibytes"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MspSparkV1alpha1ClusterLimits. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MspSparkV1alpha1ClusterLimits.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MspSparkV1alpha1ClusterLimits.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cpu: builtins.float,
                 memory_gibibytes: builtins.float):
        pulumi.set(__self__, "cpu", cpu)
        pulumi.set(__self__, "memory_gibibytes", memory_gibibytes)

    @property
    @pulumi.getter
    def cpu(self) -> builtins.float:
        return pulumi.get(self, "cpu")

    @property
    @pulumi.getter(name="memoryGibibytes")
    def memory_gibibytes(self) -> builtins.float:
        return pulumi.get(self, "memory_gibibytes")


@pulumi.output_type
class MspSparkV1alpha1ClusterMetadata(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class MspSparkV1alpha1ClusterStatus(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "historyServerEndpoint":
            suggest = "history_server_endpoint"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MspSparkV1alpha1ClusterStatus. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MspSparkV1alpha1ClusterStatus.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MspSparkV1alpha1ClusterStatus.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 history_server_endpoint: Optional[builtins.str] = None,
                 phase: Optional[builtins.str] = None,
                 state: Optional[builtins.str] = None):
        """
        :param builtins.str history_server_endpoint: History Server WebUI endpoint
        :param builtins.str phase: Current phase (or stage) of the cluster.
               
               ### Supported values
               
               Possible values:
               
                - `PHASE_UNSPECIFIED`
                - `PHASE_PROVISIONING`
                - `PHASE_RUNNING`
                - `PHASE_UPDATING`
                - `PHASE_DELETING`
                - `PHASE_DELETED`
                - `PHASE_PURGING`
                - `PHASE_STOPPING`
                - `PHASE_RESUMING`
        :param builtins.str state: State reflects substatus of the stage to define whether it's healthy or not.
               
               ### Supported values
               
               Possible values:
               
                - `STATE_UNSPECIFIED`
                - `STATE_IN_PROGRESS`
                - `STATE_FINISHED`
                - `STATE_ERROR`
                - `STATE_DEGRADED`
                - `STATE_SCHEDULED`
        """
        if history_server_endpoint is not None:
            pulumi.set(__self__, "history_server_endpoint", history_server_endpoint)
        if phase is not None:
            pulumi.set(__self__, "phase", phase)
        if state is not None:
            pulumi.set(__self__, "state", state)

    @property
    @pulumi.getter(name="historyServerEndpoint")
    def history_server_endpoint(self) -> Optional[builtins.str]:
        """
        History Server WebUI endpoint
        """
        return pulumi.get(self, "history_server_endpoint")

    @property
    @pulumi.getter
    def phase(self) -> Optional[builtins.str]:
        """
        Current phase (or stage) of the cluster.

        ### Supported values

        Possible values:

         - `PHASE_UNSPECIFIED`
         - `PHASE_PROVISIONING`
         - `PHASE_RUNNING`
         - `PHASE_UPDATING`
         - `PHASE_DELETING`
         - `PHASE_DELETED`
         - `PHASE_PURGING`
         - `PHASE_STOPPING`
         - `PHASE_RESUMING`
        """
        return pulumi.get(self, "phase")

    @property
    @pulumi.getter
    def state(self) -> Optional[builtins.str]:
        """
        State reflects substatus of the stage to define whether it's healthy or not.

        ### Supported values

        Possible values:

         - `STATE_UNSPECIFIED`
         - `STATE_IN_PROGRESS`
         - `STATE_FINISHED`
         - `STATE_ERROR`
         - `STATE_DEGRADED`
         - `STATE_SCHEDULED`
        """
        return pulumi.get(self, "state")


@pulumi.output_type
class MspSparkV1alpha1SessionDriver(dict):
    def __init__(__self__, *,
                 disk: 'outputs.MspSparkV1alpha1SessionDriverDisk',
                 resources: Optional['outputs.MspSparkV1alpha1SessionDriverResources'] = None):
        pulumi.set(__self__, "disk", disk)
        if resources is not None:
            pulumi.set(__self__, "resources", resources)

    @property
    @pulumi.getter
    def disk(self) -> 'outputs.MspSparkV1alpha1SessionDriverDisk':
        return pulumi.get(self, "disk")

    @property
    @pulumi.getter
    def resources(self) -> Optional['outputs.MspSparkV1alpha1SessionDriverResources']:
        return pulumi.get(self, "resources")


@pulumi.output_type
class MspSparkV1alpha1SessionDriverDisk(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sizeGibibytes":
            suggest = "size_gibibytes"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MspSparkV1alpha1SessionDriverDisk. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MspSparkV1alpha1SessionDriverDisk.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MspSparkV1alpha1SessionDriverDisk.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 size_gibibytes: builtins.float,
                 type: builtins.str):
        pulumi.set(__self__, "size_gibibytes", size_gibibytes)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter(name="sizeGibibytes")
    def size_gibibytes(self) -> builtins.float:
        return pulumi.get(self, "size_gibibytes")

    @property
    @pulumi.getter
    def type(self) -> builtins.str:
        return pulumi.get(self, "type")


@pulumi.output_type
class MspSparkV1alpha1SessionDriverResources(dict):
    def __init__(__self__, *,
                 platform: builtins.str,
                 preset: builtins.str):
        pulumi.set(__self__, "platform", platform)
        pulumi.set(__self__, "preset", preset)

    @property
    @pulumi.getter
    def platform(self) -> builtins.str:
        return pulumi.get(self, "platform")

    @property
    @pulumi.getter
    def preset(self) -> builtins.str:
        return pulumi.get(self, "preset")


@pulumi.output_type
class MspSparkV1alpha1SessionExecutor(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "hostsDynamicAllocation":
            suggest = "hosts_dynamic_allocation"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MspSparkV1alpha1SessionExecutor. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MspSparkV1alpha1SessionExecutor.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MspSparkV1alpha1SessionExecutor.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 disk: 'outputs.MspSparkV1alpha1SessionExecutorDisk',
                 hosts: Optional['outputs.MspSparkV1alpha1SessionExecutorHosts'] = None,
                 hosts_dynamic_allocation: Optional['outputs.MspSparkV1alpha1SessionExecutorHostsDynamicAllocation'] = None,
                 resources: Optional['outputs.MspSparkV1alpha1SessionExecutorResources'] = None):
        """
        :param 'MspSparkV1alpha1SessionExecutorHostsArgs' hosts: *Cannot be set alongside hosts_dynamic_allocation.*
        :param 'MspSparkV1alpha1SessionExecutorHostsDynamicAllocationArgs' hosts_dynamic_allocation: *Cannot be set alongside hosts.*
        """
        pulumi.set(__self__, "disk", disk)
        if hosts is not None:
            pulumi.set(__self__, "hosts", hosts)
        if hosts_dynamic_allocation is not None:
            pulumi.set(__self__, "hosts_dynamic_allocation", hosts_dynamic_allocation)
        if resources is not None:
            pulumi.set(__self__, "resources", resources)

    @property
    @pulumi.getter
    def disk(self) -> 'outputs.MspSparkV1alpha1SessionExecutorDisk':
        return pulumi.get(self, "disk")

    @property
    @pulumi.getter
    def hosts(self) -> Optional['outputs.MspSparkV1alpha1SessionExecutorHosts']:
        """
        *Cannot be set alongside hosts_dynamic_allocation.*
        """
        return pulumi.get(self, "hosts")

    @property
    @pulumi.getter(name="hostsDynamicAllocation")
    def hosts_dynamic_allocation(self) -> Optional['outputs.MspSparkV1alpha1SessionExecutorHostsDynamicAllocation']:
        """
        *Cannot be set alongside hosts.*
        """
        return pulumi.get(self, "hosts_dynamic_allocation")

    @property
    @pulumi.getter
    def resources(self) -> Optional['outputs.MspSparkV1alpha1SessionExecutorResources']:
        return pulumi.get(self, "resources")


@pulumi.output_type
class MspSparkV1alpha1SessionExecutorDisk(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sizeGibibytes":
            suggest = "size_gibibytes"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MspSparkV1alpha1SessionExecutorDisk. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MspSparkV1alpha1SessionExecutorDisk.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MspSparkV1alpha1SessionExecutorDisk.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 size_gibibytes: builtins.float,
                 type: builtins.str):
        pulumi.set(__self__, "size_gibibytes", size_gibibytes)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter(name="sizeGibibytes")
    def size_gibibytes(self) -> builtins.float:
        return pulumi.get(self, "size_gibibytes")

    @property
    @pulumi.getter
    def type(self) -> builtins.str:
        return pulumi.get(self, "type")


@pulumi.output_type
class MspSparkV1alpha1SessionExecutorHosts(dict):
    def __init__(__self__, *,
                 count: builtins.float):
        pulumi.set(__self__, "count", count)

    @property
    @pulumi.getter
    def count(self) -> builtins.float:
        return pulumi.get(self, "count")


@pulumi.output_type
class MspSparkV1alpha1SessionExecutorHostsDynamicAllocation(dict):
    def __init__(__self__, *,
                 max: builtins.float,
                 min: builtins.float):
        pulumi.set(__self__, "max", max)
        pulumi.set(__self__, "min", min)

    @property
    @pulumi.getter
    def max(self) -> builtins.float:
        return pulumi.get(self, "max")

    @property
    @pulumi.getter
    def min(self) -> builtins.float:
        return pulumi.get(self, "min")


@pulumi.output_type
class MspSparkV1alpha1SessionExecutorResources(dict):
    def __init__(__self__, *,
                 platform: builtins.str,
                 preset: builtins.str):
        pulumi.set(__self__, "platform", platform)
        pulumi.set(__self__, "preset", preset)

    @property
    @pulumi.getter
    def platform(self) -> builtins.str:
        return pulumi.get(self, "platform")

    @property
    @pulumi.getter
    def preset(self) -> builtins.str:
        return pulumi.get(self, "preset")


@pulumi.output_type
class MspSparkV1alpha1SessionMetadata(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class MspSparkV1alpha1SessionPython(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fileUris":
            suggest = "file_uris"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MspSparkV1alpha1SessionPython. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MspSparkV1alpha1SessionPython.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MspSparkV1alpha1SessionPython.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 file_uris: Optional[Sequence[builtins.str]] = None,
                 requirements: Optional[Sequence[builtins.str]] = None):
        """
        :param Sequence[builtins.str] file_uris: S3 URIs of files to be placed in PYTHONPATH of driver and executors for python applications (.py, .zip, .egg)
        :param Sequence[builtins.str] requirements: Python requirements
        """
        if file_uris is not None:
            pulumi.set(__self__, "file_uris", file_uris)
        if requirements is not None:
            pulumi.set(__self__, "requirements", requirements)

    @property
    @pulumi.getter(name="fileUris")
    def file_uris(self) -> Optional[Sequence[builtins.str]]:
        """
        S3 URIs of files to be placed in PYTHONPATH of driver and executors for python applications (.py, .zip, .egg)
        """
        return pulumi.get(self, "file_uris")

    @property
    @pulumi.getter
    def requirements(self) -> Optional[Sequence[builtins.str]]:
        """
        Python requirements
        """
        return pulumi.get(self, "requirements")


@pulumi.output_type
class MspSparkV1alpha1SessionStatus(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "driverPresetDetails":
            suggest = "driver_preset_details"
        elif key == "executorPresetDetails":
            suggest = "executor_preset_details"
        elif key == "sparkConnectEndpoint":
            suggest = "spark_connect_endpoint"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MspSparkV1alpha1SessionStatus. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MspSparkV1alpha1SessionStatus.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MspSparkV1alpha1SessionStatus.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 driver_preset_details: Optional['outputs.MspSparkV1alpha1SessionStatusDriverPresetDetails'] = None,
                 executor_preset_details: Optional['outputs.MspSparkV1alpha1SessionStatusExecutorPresetDetails'] = None,
                 phase: Optional[builtins.str] = None,
                 spark_connect_endpoint: Optional[builtins.str] = None,
                 state: Optional[builtins.str] = None):
        """
        :param 'MspSparkV1alpha1SessionStatusDriverPresetDetailsArgs' driver_preset_details: Session driver resource preset details
        :param 'MspSparkV1alpha1SessionStatusExecutorPresetDetailsArgs' executor_preset_details: Session executor resource preset details
        :param builtins.str phase: Current phase (or stage) of the cluster.
               
               ### Supported values
               
               Possible values:
               
                - `PHASE_UNSPECIFIED`
                - `PHASE_PROVISIONING`
                - `PHASE_RUNNING`
                - `PHASE_UPDATING`
                - `PHASE_DELETING`
                - `PHASE_DELETED`
                - `PHASE_PURGING`
                - `PHASE_STOPPING`
                - `PHASE_RESUMING`
        :param builtins.str spark_connect_endpoint: Spark Connect endpoint
        :param builtins.str state: State reflects substatus of the stage to define whether it's healthy or not.
               
               ### Supported values
               
               Possible values:
               
                - `STATE_UNSPECIFIED`
                - `STATE_IN_PROGRESS`
                - `STATE_FINISHED`
                - `STATE_ERROR`
                - `STATE_DEGRADED`
                - `STATE_SCHEDULED`
        """
        if driver_preset_details is not None:
            pulumi.set(__self__, "driver_preset_details", driver_preset_details)
        if executor_preset_details is not None:
            pulumi.set(__self__, "executor_preset_details", executor_preset_details)
        if phase is not None:
            pulumi.set(__self__, "phase", phase)
        if spark_connect_endpoint is not None:
            pulumi.set(__self__, "spark_connect_endpoint", spark_connect_endpoint)
        if state is not None:
            pulumi.set(__self__, "state", state)

    @property
    @pulumi.getter(name="driverPresetDetails")
    def driver_preset_details(self) -> Optional['outputs.MspSparkV1alpha1SessionStatusDriverPresetDetails']:
        """
        Session driver resource preset details
        """
        return pulumi.get(self, "driver_preset_details")

    @property
    @pulumi.getter(name="executorPresetDetails")
    def executor_preset_details(self) -> Optional['outputs.MspSparkV1alpha1SessionStatusExecutorPresetDetails']:
        """
        Session executor resource preset details
        """
        return pulumi.get(self, "executor_preset_details")

    @property
    @pulumi.getter
    def phase(self) -> Optional[builtins.str]:
        """
        Current phase (or stage) of the cluster.

        ### Supported values

        Possible values:

         - `PHASE_UNSPECIFIED`
         - `PHASE_PROVISIONING`
         - `PHASE_RUNNING`
         - `PHASE_UPDATING`
         - `PHASE_DELETING`
         - `PHASE_DELETED`
         - `PHASE_PURGING`
         - `PHASE_STOPPING`
         - `PHASE_RESUMING`
        """
        return pulumi.get(self, "phase")

    @property
    @pulumi.getter(name="sparkConnectEndpoint")
    def spark_connect_endpoint(self) -> Optional[builtins.str]:
        """
        Spark Connect endpoint
        """
        return pulumi.get(self, "spark_connect_endpoint")

    @property
    @pulumi.getter
    def state(self) -> Optional[builtins.str]:
        """
        State reflects substatus of the stage to define whether it's healthy or not.

        ### Supported values

        Possible values:

         - `STATE_UNSPECIFIED`
         - `STATE_IN_PROGRESS`
         - `STATE_FINISHED`
         - `STATE_ERROR`
         - `STATE_DEGRADED`
         - `STATE_SCHEDULED`
        """
        return pulumi.get(self, "state")


@pulumi.output_type
class MspSparkV1alpha1SessionStatusDriverPresetDetails(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "cpuCount":
            suggest = "cpu_count"
        elif key == "gpuCount":
            suggest = "gpu_count"
        elif key == "memoryGibibytes":
            suggest = "memory_gibibytes"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MspSparkV1alpha1SessionStatusDriverPresetDetails. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MspSparkV1alpha1SessionStatusDriverPresetDetails.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MspSparkV1alpha1SessionStatusDriverPresetDetails.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cpu_count: Optional[builtins.float] = None,
                 gpu_count: Optional[builtins.float] = None,
                 memory_gibibytes: Optional[builtins.float] = None):
        if cpu_count is not None:
            pulumi.set(__self__, "cpu_count", cpu_count)
        if gpu_count is not None:
            pulumi.set(__self__, "gpu_count", gpu_count)
        if memory_gibibytes is not None:
            pulumi.set(__self__, "memory_gibibytes", memory_gibibytes)

    @property
    @pulumi.getter(name="cpuCount")
    def cpu_count(self) -> Optional[builtins.float]:
        return pulumi.get(self, "cpu_count")

    @property
    @pulumi.getter(name="gpuCount")
    def gpu_count(self) -> Optional[builtins.float]:
        return pulumi.get(self, "gpu_count")

    @property
    @pulumi.getter(name="memoryGibibytes")
    def memory_gibibytes(self) -> Optional[builtins.float]:
        return pulumi.get(self, "memory_gibibytes")


@pulumi.output_type
class MspSparkV1alpha1SessionStatusExecutorPresetDetails(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "cpuCount":
            suggest = "cpu_count"
        elif key == "gpuCount":
            suggest = "gpu_count"
        elif key == "memoryGibibytes":
            suggest = "memory_gibibytes"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MspSparkV1alpha1SessionStatusExecutorPresetDetails. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MspSparkV1alpha1SessionStatusExecutorPresetDetails.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MspSparkV1alpha1SessionStatusExecutorPresetDetails.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cpu_count: Optional[builtins.float] = None,
                 gpu_count: Optional[builtins.float] = None,
                 memory_gibibytes: Optional[builtins.float] = None):
        if cpu_count is not None:
            pulumi.set(__self__, "cpu_count", cpu_count)
        if gpu_count is not None:
            pulumi.set(__self__, "gpu_count", gpu_count)
        if memory_gibibytes is not None:
            pulumi.set(__self__, "memory_gibibytes", memory_gibibytes)

    @property
    @pulumi.getter(name="cpuCount")
    def cpu_count(self) -> Optional[builtins.float]:
        return pulumi.get(self, "cpu_count")

    @property
    @pulumi.getter(name="gpuCount")
    def gpu_count(self) -> Optional[builtins.float]:
        return pulumi.get(self, "gpu_count")

    @property
    @pulumi.getter(name="memoryGibibytes")
    def memory_gibibytes(self) -> Optional[builtins.float]:
        return pulumi.get(self, "memory_gibibytes")


@pulumi.output_type
class RegistryV1RegistryMetadata(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class RegistryV1RegistryStatus(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "imagesCount":
            suggest = "images_count"
        elif key == "registryFqdn":
            suggest = "registry_fqdn"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RegistryV1RegistryStatus. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RegistryV1RegistryStatus.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RegistryV1RegistryStatus.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 images_count: Optional[builtins.float] = None,
                 registry_fqdn: Optional[builtins.str] = None,
                 state: Optional[builtins.str] = None):
        """
        :param builtins.str registry_fqdn: regional fqdn "cr.eu-north1.nebius.cloud"
        :param builtins.str state: ### Supported values
               
               Possible values:
               
                - `CREATING`
                - `ACTIVE`
                - `DELETING`
                - `SUSPENDED`
        """
        if images_count is not None:
            pulumi.set(__self__, "images_count", images_count)
        if registry_fqdn is not None:
            pulumi.set(__self__, "registry_fqdn", registry_fqdn)
        if state is not None:
            pulumi.set(__self__, "state", state)

    @property
    @pulumi.getter(name="imagesCount")
    def images_count(self) -> Optional[builtins.float]:
        return pulumi.get(self, "images_count")

    @property
    @pulumi.getter(name="registryFqdn")
    def registry_fqdn(self) -> Optional[builtins.str]:
        """
        regional fqdn "cr.eu-north1.nebius.cloud"
        """
        return pulumi.get(self, "registry_fqdn")

    @property
    @pulumi.getter
    def state(self) -> Optional[builtins.str]:
        """
        ### Supported values

        Possible values:

         - `CREATING`
         - `ACTIVE`
         - `DELETING`
         - `SUSPENDED`
        """
        return pulumi.get(self, "state")


@pulumi.output_type
class StorageV1BucketLifecycleConfiguration(dict):
    def __init__(__self__, *,
                 rules: Optional[Sequence['outputs.StorageV1BucketLifecycleConfigurationRule']] = None):
        if rules is not None:
            pulumi.set(__self__, "rules", rules)

    @property
    @pulumi.getter
    def rules(self) -> Optional[Sequence['outputs.StorageV1BucketLifecycleConfigurationRule']]:
        return pulumi.get(self, "rules")


@pulumi.output_type
class StorageV1BucketLifecycleConfigurationRule(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "abortIncompleteMultipartUpload":
            suggest = "abort_incomplete_multipart_upload"
        elif key == "noncurrentVersionExpiration":
            suggest = "noncurrent_version_expiration"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in StorageV1BucketLifecycleConfigurationRule. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        StorageV1BucketLifecycleConfigurationRule.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        StorageV1BucketLifecycleConfigurationRule.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 id: builtins.str,
                 status: builtins.str,
                 abort_incomplete_multipart_upload: Optional['outputs.StorageV1BucketLifecycleConfigurationRuleAbortIncompleteMultipartUpload'] = None,
                 expiration: Optional['outputs.StorageV1BucketLifecycleConfigurationRuleExpiration'] = None,
                 filter: Optional['outputs.StorageV1BucketLifecycleConfigurationRuleFilter'] = None,
                 noncurrent_version_expiration: Optional['outputs.StorageV1BucketLifecycleConfigurationRuleNoncurrentVersionExpiration'] = None):
        """
        :param builtins.str id: Unique identifier for the rule per configuration.
               The value cannot be longer than 255 characters.
        :param builtins.str status: ### Supported values
               
               Possible values:
               
                - `STATUS_UNSPECIFIED`
                - `ENABLED`
                - `DISABLED`
        :param 'StorageV1BucketLifecycleConfigurationRuleAbortIncompleteMultipartUploadArgs' abort_incomplete_multipart_upload: Specifies the days since the initiation of an incomplete multipart upload that
               the system will wait before permanently removing all parts of the upload.
        :param 'StorageV1BucketLifecycleConfigurationRuleExpirationArgs' expiration: Specifies the expiration for the lifecycle of the object in the form of date, days and,
               whether the object has a delete marker.
        :param 'StorageV1BucketLifecycleConfigurationRuleFilterArgs' filter: The Filter is used to identify objects that a Lifecycle Rule applies to.
               The Lifecycle Rule will apply to any object matching all of the predicates
               configured inside (using logical AND).
        :param 'StorageV1BucketLifecycleConfigurationRuleNoncurrentVersionExpirationArgs' noncurrent_version_expiration: Specifies when noncurrent object versions expire.
               It works only on a bucket that has versioning enabled (or suspended).
        """
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "status", status)
        if abort_incomplete_multipart_upload is not None:
            pulumi.set(__self__, "abort_incomplete_multipart_upload", abort_incomplete_multipart_upload)
        if expiration is not None:
            pulumi.set(__self__, "expiration", expiration)
        if filter is not None:
            pulumi.set(__self__, "filter", filter)
        if noncurrent_version_expiration is not None:
            pulumi.set(__self__, "noncurrent_version_expiration", noncurrent_version_expiration)

    @property
    @pulumi.getter
    def id(self) -> builtins.str:
        """
        Unique identifier for the rule per configuration.
        The value cannot be longer than 255 characters.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def status(self) -> builtins.str:
        """
        ### Supported values

        Possible values:

         - `STATUS_UNSPECIFIED`
         - `ENABLED`
         - `DISABLED`
        """
        return pulumi.get(self, "status")

    @property
    @pulumi.getter(name="abortIncompleteMultipartUpload")
    def abort_incomplete_multipart_upload(self) -> Optional['outputs.StorageV1BucketLifecycleConfigurationRuleAbortIncompleteMultipartUpload']:
        """
        Specifies the days since the initiation of an incomplete multipart upload that
        the system will wait before permanently removing all parts of the upload.
        """
        return pulumi.get(self, "abort_incomplete_multipart_upload")

    @property
    @pulumi.getter
    def expiration(self) -> Optional['outputs.StorageV1BucketLifecycleConfigurationRuleExpiration']:
        """
        Specifies the expiration for the lifecycle of the object in the form of date, days and,
        whether the object has a delete marker.
        """
        return pulumi.get(self, "expiration")

    @property
    @pulumi.getter
    def filter(self) -> Optional['outputs.StorageV1BucketLifecycleConfigurationRuleFilter']:
        """
        The Filter is used to identify objects that a Lifecycle Rule applies to.
        The Lifecycle Rule will apply to any object matching all of the predicates
        configured inside (using logical AND).
        """
        return pulumi.get(self, "filter")

    @property
    @pulumi.getter(name="noncurrentVersionExpiration")
    def noncurrent_version_expiration(self) -> Optional['outputs.StorageV1BucketLifecycleConfigurationRuleNoncurrentVersionExpiration']:
        """
        Specifies when noncurrent object versions expire.
        It works only on a bucket that has versioning enabled (or suspended).
        """
        return pulumi.get(self, "noncurrent_version_expiration")


@pulumi.output_type
class StorageV1BucketLifecycleConfigurationRuleAbortIncompleteMultipartUpload(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "daysAfterInitiation":
            suggest = "days_after_initiation"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in StorageV1BucketLifecycleConfigurationRuleAbortIncompleteMultipartUpload. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        StorageV1BucketLifecycleConfigurationRuleAbortIncompleteMultipartUpload.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        StorageV1BucketLifecycleConfigurationRuleAbortIncompleteMultipartUpload.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 days_after_initiation: Optional[builtins.float] = None):
        """
        :param builtins.float days_after_initiation: Specifies the days since the initiation of an incomplete multipart upload that
               the system will wait before permanently removing all parts of the upload.
        """
        if days_after_initiation is not None:
            pulumi.set(__self__, "days_after_initiation", days_after_initiation)

    @property
    @pulumi.getter(name="daysAfterInitiation")
    def days_after_initiation(self) -> Optional[builtins.float]:
        """
        Specifies the days since the initiation of an incomplete multipart upload that
        the system will wait before permanently removing all parts of the upload.
        """
        return pulumi.get(self, "days_after_initiation")


@pulumi.output_type
class StorageV1BucketLifecycleConfigurationRuleExpiration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "expiredObjectDeleteMarker":
            suggest = "expired_object_delete_marker"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in StorageV1BucketLifecycleConfigurationRuleExpiration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        StorageV1BucketLifecycleConfigurationRuleExpiration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        StorageV1BucketLifecycleConfigurationRuleExpiration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 date: Optional[builtins.str] = None,
                 days: Optional[builtins.float] = None,
                 expired_object_delete_marker: Optional[builtins.bool] = None):
        """
        :param builtins.str date: Indicates at what date the object will be deleted. The time is always midnight UTC.
               
               A string representing a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ` or `YYYY-MM-DDTHH:MM:SS.SSS±HH:MM`
               
               *Cannot be set alongside days.*
        :param builtins.float days: Indicates the lifetime, in days, of the objects that are subject to the rule.
               The value must be a non-zero positive integer.
               
               *Cannot be set alongside date.*
        :param builtins.bool expired_object_delete_marker: Indicates whether the system will remove a "delete marker" with no noncurrent versions.
               If set to true, the "delete marker" will be permanently removed.
               If set to false the policy takes no action.
               This cannot be specified with Days or Date in a LifecycleExpiration Policy.
        """
        if date is not None:
            pulumi.set(__self__, "date", date)
        if days is not None:
            pulumi.set(__self__, "days", days)
        if expired_object_delete_marker is not None:
            pulumi.set(__self__, "expired_object_delete_marker", expired_object_delete_marker)

    @property
    @pulumi.getter
    def date(self) -> Optional[builtins.str]:
        """
        Indicates at what date the object will be deleted. The time is always midnight UTC.

        A string representing a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ` or `YYYY-MM-DDTHH:MM:SS.SSS±HH:MM`

        *Cannot be set alongside days.*
        """
        return pulumi.get(self, "date")

    @property
    @pulumi.getter
    def days(self) -> Optional[builtins.float]:
        """
        Indicates the lifetime, in days, of the objects that are subject to the rule.
        The value must be a non-zero positive integer.

        *Cannot be set alongside date.*
        """
        return pulumi.get(self, "days")

    @property
    @pulumi.getter(name="expiredObjectDeleteMarker")
    def expired_object_delete_marker(self) -> Optional[builtins.bool]:
        """
        Indicates whether the system will remove a "delete marker" with no noncurrent versions.
        If set to true, the "delete marker" will be permanently removed.
        If set to false the policy takes no action.
        This cannot be specified with Days or Date in a LifecycleExpiration Policy.
        """
        return pulumi.get(self, "expired_object_delete_marker")


@pulumi.output_type
class StorageV1BucketLifecycleConfigurationRuleFilter(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "objectSizeGreaterThanBytes":
            suggest = "object_size_greater_than_bytes"
        elif key == "objectSizeLessThanBytes":
            suggest = "object_size_less_than_bytes"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in StorageV1BucketLifecycleConfigurationRuleFilter. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        StorageV1BucketLifecycleConfigurationRuleFilter.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        StorageV1BucketLifecycleConfigurationRuleFilter.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 object_size_greater_than_bytes: Optional[builtins.float] = None,
                 object_size_less_than_bytes: Optional[builtins.float] = None,
                 prefix: Optional[builtins.str] = None):
        """
        :param builtins.float object_size_greater_than_bytes: Minimum object size to which the rule applies.
        :param builtins.float object_size_less_than_bytes: Maximum object size to which the rule applies.
        :param builtins.str prefix: Prefix identifying one or more objects to which the rule applies.
               If prefix is empty, the rule applies to all objects in the bucket.
        """
        if object_size_greater_than_bytes is not None:
            pulumi.set(__self__, "object_size_greater_than_bytes", object_size_greater_than_bytes)
        if object_size_less_than_bytes is not None:
            pulumi.set(__self__, "object_size_less_than_bytes", object_size_less_than_bytes)
        if prefix is not None:
            pulumi.set(__self__, "prefix", prefix)

    @property
    @pulumi.getter(name="objectSizeGreaterThanBytes")
    def object_size_greater_than_bytes(self) -> Optional[builtins.float]:
        """
        Minimum object size to which the rule applies.
        """
        return pulumi.get(self, "object_size_greater_than_bytes")

    @property
    @pulumi.getter(name="objectSizeLessThanBytes")
    def object_size_less_than_bytes(self) -> Optional[builtins.float]:
        """
        Maximum object size to which the rule applies.
        """
        return pulumi.get(self, "object_size_less_than_bytes")

    @property
    @pulumi.getter
    def prefix(self) -> Optional[builtins.str]:
        """
        Prefix identifying one or more objects to which the rule applies.
        If prefix is empty, the rule applies to all objects in the bucket.
        """
        return pulumi.get(self, "prefix")


@pulumi.output_type
class StorageV1BucketLifecycleConfigurationRuleNoncurrentVersionExpiration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "newerNoncurrentVersions":
            suggest = "newer_noncurrent_versions"
        elif key == "noncurrentDays":
            suggest = "noncurrent_days"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in StorageV1BucketLifecycleConfigurationRuleNoncurrentVersionExpiration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        StorageV1BucketLifecycleConfigurationRuleNoncurrentVersionExpiration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        StorageV1BucketLifecycleConfigurationRuleNoncurrentVersionExpiration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 newer_noncurrent_versions: Optional[builtins.float] = None,
                 noncurrent_days: Optional[builtins.float] = None):
        """
        :param builtins.float newer_noncurrent_versions: Specifies how many noncurrent versions the system will retain.
        :param builtins.float noncurrent_days: Specifies the number of days an object is noncurrent before the system will expire it.
        """
        if newer_noncurrent_versions is not None:
            pulumi.set(__self__, "newer_noncurrent_versions", newer_noncurrent_versions)
        if noncurrent_days is not None:
            pulumi.set(__self__, "noncurrent_days", noncurrent_days)

    @property
    @pulumi.getter(name="newerNoncurrentVersions")
    def newer_noncurrent_versions(self) -> Optional[builtins.float]:
        """
        Specifies how many noncurrent versions the system will retain.
        """
        return pulumi.get(self, "newer_noncurrent_versions")

    @property
    @pulumi.getter(name="noncurrentDays")
    def noncurrent_days(self) -> Optional[builtins.float]:
        """
        Specifies the number of days an object is noncurrent before the system will expire it.
        """
        return pulumi.get(self, "noncurrent_days")


@pulumi.output_type
class StorageV1BucketMetadata(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class StorageV1BucketStatus(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "deletedAt":
            suggest = "deleted_at"
        elif key == "domainName":
            suggest = "domain_name"
        elif key == "purgeAt":
            suggest = "purge_at"
        elif key == "suspensionState":
            suggest = "suspension_state"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in StorageV1BucketStatus. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        StorageV1BucketStatus.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        StorageV1BucketStatus.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 counters: Optional[Sequence['outputs.StorageV1BucketStatusCounter']] = None,
                 deleted_at: Optional[builtins.str] = None,
                 domain_name: Optional[builtins.str] = None,
                 purge_at: Optional[builtins.str] = None,
                 region: Optional[builtins.str] = None,
                 state: Optional[builtins.str] = None,
                 suspension_state: Optional[builtins.str] = None):
        """
        :param builtins.str deleted_at: The time when the bucket was deleted (or scheduled for deletion).
               It resets to null if the bucket is undeleted.
               
               A string representing a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ` or `YYYY-MM-DDTHH:MM:SS.SSS±HH:MM`
        :param builtins.str domain_name: The domain of the endpoint where the bucket can be accessed. It omits the scheme (HTTPS) and the port (443)
               and contains only the FQDN address.
        :param builtins.str purge_at: The time when the bucket will be automatically purged in case it was soft-deleted.
               
               A string representing a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ` or `YYYY-MM-DDTHH:MM:SS.SSS±HH:MM`
        :param builtins.str region: The name of the region where the bucket is located for use with S3 clients, i.e. "eu-west1".
        :param builtins.str state: ### Supported values
               
               Possible values:
               
                - `STATE_UNSPECIFIED`
                - `CREATING` - Bucket is under creation and cannot be used yet.
                - `ACTIVE` - Bucket is active and ready for usage.
                - `UPDATING` - Bucket is being updated.
               It can be used, but some settings are being modified and you can observe their inconsistency.
                - `SCHEDULED_FOR_DELETION` - Bucket is scheduled for deletion.
               It cannot be used in s3 api anymore.
        :param builtins.str suspension_state: ### Supported values
               
               Possible values:
               
                - `SUSPENSION_STATE_UNSPECIFIED`
                - `NOT_SUSPENDED`
                - `SUSPENDED`
        """
        if counters is not None:
            pulumi.set(__self__, "counters", counters)
        if deleted_at is not None:
            pulumi.set(__self__, "deleted_at", deleted_at)
        if domain_name is not None:
            pulumi.set(__self__, "domain_name", domain_name)
        if purge_at is not None:
            pulumi.set(__self__, "purge_at", purge_at)
        if region is not None:
            pulumi.set(__self__, "region", region)
        if state is not None:
            pulumi.set(__self__, "state", state)
        if suspension_state is not None:
            pulumi.set(__self__, "suspension_state", suspension_state)

    @property
    @pulumi.getter
    def counters(self) -> Optional[Sequence['outputs.StorageV1BucketStatusCounter']]:
        return pulumi.get(self, "counters")

    @property
    @pulumi.getter(name="deletedAt")
    def deleted_at(self) -> Optional[builtins.str]:
        """
        The time when the bucket was deleted (or scheduled for deletion).
        It resets to null if the bucket is undeleted.

        A string representing a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ` or `YYYY-MM-DDTHH:MM:SS.SSS±HH:MM`
        """
        return pulumi.get(self, "deleted_at")

    @property
    @pulumi.getter(name="domainName")
    def domain_name(self) -> Optional[builtins.str]:
        """
        The domain of the endpoint where the bucket can be accessed. It omits the scheme (HTTPS) and the port (443)
        and contains only the FQDN address.
        """
        return pulumi.get(self, "domain_name")

    @property
    @pulumi.getter(name="purgeAt")
    def purge_at(self) -> Optional[builtins.str]:
        """
        The time when the bucket will be automatically purged in case it was soft-deleted.

        A string representing a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ` or `YYYY-MM-DDTHH:MM:SS.SSS±HH:MM`
        """
        return pulumi.get(self, "purge_at")

    @property
    @pulumi.getter
    def region(self) -> Optional[builtins.str]:
        """
        The name of the region where the bucket is located for use with S3 clients, i.e. "eu-west1".
        """
        return pulumi.get(self, "region")

    @property
    @pulumi.getter
    def state(self) -> Optional[builtins.str]:
        """
        ### Supported values

        Possible values:

         - `STATE_UNSPECIFIED`
         - `CREATING` - Bucket is under creation and cannot be used yet.
         - `ACTIVE` - Bucket is active and ready for usage.
         - `UPDATING` - Bucket is being updated.
        It can be used, but some settings are being modified and you can observe their inconsistency.
         - `SCHEDULED_FOR_DELETION` - Bucket is scheduled for deletion.
        It cannot be used in s3 api anymore.
        """
        return pulumi.get(self, "state")

    @property
    @pulumi.getter(name="suspensionState")
    def suspension_state(self) -> Optional[builtins.str]:
        """
        ### Supported values

        Possible values:

         - `SUSPENSION_STATE_UNSPECIFIED`
         - `NOT_SUSPENDED`
         - `SUSPENDED`
        """
        return pulumi.get(self, "suspension_state")


@pulumi.output_type
class StorageV1BucketStatusCounter(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "nonCurrentCounters":
            suggest = "non_current_counters"
        elif key == "storageClass":
            suggest = "storage_class"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in StorageV1BucketStatusCounter. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        StorageV1BucketStatusCounter.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        StorageV1BucketStatusCounter.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 counters: Optional['outputs.StorageV1BucketStatusCounterCounters'] = None,
                 non_current_counters: Optional['outputs.StorageV1BucketStatusCounterNonCurrentCounters'] = None,
                 storage_class: Optional[builtins.str] = None):
        """
        :param 'StorageV1BucketStatusCounterNonCurrentCountersArgs' non_current_counters: ### Inner value description
               
               Counters for non-current object versions (for versioning buckets).
        :param builtins.str storage_class: ### Supported values
               
               Possible values:
               
                - `STORAGE_CLASS_UNSPECIFIED`
                - `STANDARD`
                - `ENHANCED_THROUGHPUT`
        """
        if counters is not None:
            pulumi.set(__self__, "counters", counters)
        if non_current_counters is not None:
            pulumi.set(__self__, "non_current_counters", non_current_counters)
        if storage_class is not None:
            pulumi.set(__self__, "storage_class", storage_class)

    @property
    @pulumi.getter
    def counters(self) -> Optional['outputs.StorageV1BucketStatusCounterCounters']:
        return pulumi.get(self, "counters")

    @property
    @pulumi.getter(name="nonCurrentCounters")
    def non_current_counters(self) -> Optional['outputs.StorageV1BucketStatusCounterNonCurrentCounters']:
        """
        ### Inner value description

        Counters for non-current object versions (for versioning buckets).
        """
        return pulumi.get(self, "non_current_counters")

    @property
    @pulumi.getter(name="storageClass")
    def storage_class(self) -> Optional[builtins.str]:
        """
        ### Supported values

        Possible values:

         - `STORAGE_CLASS_UNSPECIFIED`
         - `STANDARD`
         - `ENHANCED_THROUGHPUT`
        """
        return pulumi.get(self, "storage_class")


@pulumi.output_type
class StorageV1BucketStatusCounterCounters(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "inflightPartsQuantity":
            suggest = "inflight_parts_quantity"
        elif key == "inflightPartsSize":
            suggest = "inflight_parts_size"
        elif key == "multipartObjectsQuantity":
            suggest = "multipart_objects_quantity"
        elif key == "multipartObjectsSize":
            suggest = "multipart_objects_size"
        elif key == "multipartUploadsQuantity":
            suggest = "multipart_uploads_quantity"
        elif key == "simpleObjectsQuantity":
            suggest = "simple_objects_quantity"
        elif key == "simpleObjectsSize":
            suggest = "simple_objects_size"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in StorageV1BucketStatusCounterCounters. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        StorageV1BucketStatusCounterCounters.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        StorageV1BucketStatusCounterCounters.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 inflight_parts_quantity: Optional[builtins.float] = None,
                 inflight_parts_size: Optional[builtins.float] = None,
                 multipart_objects_quantity: Optional[builtins.float] = None,
                 multipart_objects_size: Optional[builtins.float] = None,
                 multipart_uploads_quantity: Optional[builtins.float] = None,
                 simple_objects_quantity: Optional[builtins.float] = None,
                 simple_objects_size: Optional[builtins.float] = None):
        if inflight_parts_quantity is not None:
            pulumi.set(__self__, "inflight_parts_quantity", inflight_parts_quantity)
        if inflight_parts_size is not None:
            pulumi.set(__self__, "inflight_parts_size", inflight_parts_size)
        if multipart_objects_quantity is not None:
            pulumi.set(__self__, "multipart_objects_quantity", multipart_objects_quantity)
        if multipart_objects_size is not None:
            pulumi.set(__self__, "multipart_objects_size", multipart_objects_size)
        if multipart_uploads_quantity is not None:
            pulumi.set(__self__, "multipart_uploads_quantity", multipart_uploads_quantity)
        if simple_objects_quantity is not None:
            pulumi.set(__self__, "simple_objects_quantity", simple_objects_quantity)
        if simple_objects_size is not None:
            pulumi.set(__self__, "simple_objects_size", simple_objects_size)

    @property
    @pulumi.getter(name="inflightPartsQuantity")
    def inflight_parts_quantity(self) -> Optional[builtins.float]:
        return pulumi.get(self, "inflight_parts_quantity")

    @property
    @pulumi.getter(name="inflightPartsSize")
    def inflight_parts_size(self) -> Optional[builtins.float]:
        return pulumi.get(self, "inflight_parts_size")

    @property
    @pulumi.getter(name="multipartObjectsQuantity")
    def multipart_objects_quantity(self) -> Optional[builtins.float]:
        return pulumi.get(self, "multipart_objects_quantity")

    @property
    @pulumi.getter(name="multipartObjectsSize")
    def multipart_objects_size(self) -> Optional[builtins.float]:
        return pulumi.get(self, "multipart_objects_size")

    @property
    @pulumi.getter(name="multipartUploadsQuantity")
    def multipart_uploads_quantity(self) -> Optional[builtins.float]:
        return pulumi.get(self, "multipart_uploads_quantity")

    @property
    @pulumi.getter(name="simpleObjectsQuantity")
    def simple_objects_quantity(self) -> Optional[builtins.float]:
        return pulumi.get(self, "simple_objects_quantity")

    @property
    @pulumi.getter(name="simpleObjectsSize")
    def simple_objects_size(self) -> Optional[builtins.float]:
        return pulumi.get(self, "simple_objects_size")


@pulumi.output_type
class StorageV1BucketStatusCounterNonCurrentCounters(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "multipartObjectsQuantity":
            suggest = "multipart_objects_quantity"
        elif key == "multipartObjectsSize":
            suggest = "multipart_objects_size"
        elif key == "simpleObjectsQuantity":
            suggest = "simple_objects_quantity"
        elif key == "simpleObjectsSize":
            suggest = "simple_objects_size"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in StorageV1BucketStatusCounterNonCurrentCounters. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        StorageV1BucketStatusCounterNonCurrentCounters.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        StorageV1BucketStatusCounterNonCurrentCounters.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 multipart_objects_quantity: Optional[builtins.float] = None,
                 multipart_objects_size: Optional[builtins.float] = None,
                 simple_objects_quantity: Optional[builtins.float] = None,
                 simple_objects_size: Optional[builtins.float] = None):
        if multipart_objects_quantity is not None:
            pulumi.set(__self__, "multipart_objects_quantity", multipart_objects_quantity)
        if multipart_objects_size is not None:
            pulumi.set(__self__, "multipart_objects_size", multipart_objects_size)
        if simple_objects_quantity is not None:
            pulumi.set(__self__, "simple_objects_quantity", simple_objects_quantity)
        if simple_objects_size is not None:
            pulumi.set(__self__, "simple_objects_size", simple_objects_size)

    @property
    @pulumi.getter(name="multipartObjectsQuantity")
    def multipart_objects_quantity(self) -> Optional[builtins.float]:
        return pulumi.get(self, "multipart_objects_quantity")

    @property
    @pulumi.getter(name="multipartObjectsSize")
    def multipart_objects_size(self) -> Optional[builtins.float]:
        return pulumi.get(self, "multipart_objects_size")

    @property
    @pulumi.getter(name="simpleObjectsQuantity")
    def simple_objects_quantity(self) -> Optional[builtins.float]:
        return pulumi.get(self, "simple_objects_quantity")

    @property
    @pulumi.getter(name="simpleObjectsSize")
    def simple_objects_size(self) -> Optional[builtins.float]:
        return pulumi.get(self, "simple_objects_size")


@pulumi.output_type
class VpcV1AllocationIpv4Private(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "poolId":
            suggest = "pool_id"
        elif key == "subnetId":
            suggest = "subnet_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VpcV1AllocationIpv4Private. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VpcV1AllocationIpv4Private.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VpcV1AllocationIpv4Private.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cidr: Optional[builtins.str] = None,
                 pool_id: Optional[builtins.str] = None,
                 subnet_id: Optional[builtins.str] = None):
        """
        :param builtins.str cidr: CIDR block for IPv4 Allocation.
               May be a single IP address (such as 10.2.3.4),
               a prefix length (such as /24) or a CIDR-formatted string (such as 10.1.2.0/24).
               Random address (/32) from pool would be allocated if field is omitted.
        :param builtins.str pool_id: Pool for the IPv4 private allocation.
               
               *Cannot be set alongside subnet_id.*
        :param builtins.str subnet_id: Subnet ID.
               Required same subnet to use allocation in subnet-resources (e.g. Network Interface)
               
               *Cannot be set alongside pool_id.*
        """
        if cidr is not None:
            pulumi.set(__self__, "cidr", cidr)
        if pool_id is not None:
            pulumi.set(__self__, "pool_id", pool_id)
        if subnet_id is not None:
            pulumi.set(__self__, "subnet_id", subnet_id)

    @property
    @pulumi.getter
    def cidr(self) -> Optional[builtins.str]:
        """
        CIDR block for IPv4 Allocation.
        May be a single IP address (such as 10.2.3.4),
        a prefix length (such as /24) or a CIDR-formatted string (such as 10.1.2.0/24).
        Random address (/32) from pool would be allocated if field is omitted.
        """
        return pulumi.get(self, "cidr")

    @property
    @pulumi.getter(name="poolId")
    def pool_id(self) -> Optional[builtins.str]:
        """
        Pool for the IPv4 private allocation.

        *Cannot be set alongside subnet_id.*
        """
        return pulumi.get(self, "pool_id")

    @property
    @pulumi.getter(name="subnetId")
    def subnet_id(self) -> Optional[builtins.str]:
        """
        Subnet ID.
        Required same subnet to use allocation in subnet-resources (e.g. Network Interface)

        *Cannot be set alongside pool_id.*
        """
        return pulumi.get(self, "subnet_id")


@pulumi.output_type
class VpcV1AllocationIpv4Public(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "poolId":
            suggest = "pool_id"
        elif key == "subnetId":
            suggest = "subnet_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VpcV1AllocationIpv4Public. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VpcV1AllocationIpv4Public.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VpcV1AllocationIpv4Public.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cidr: Optional[builtins.str] = None,
                 pool_id: Optional[builtins.str] = None,
                 subnet_id: Optional[builtins.str] = None):
        """
        :param builtins.str cidr: CIDR block for IPv4 Allocation.
               May be a single IP address (such as 10.2.3.4),
               a prefix length (such as /32) or a CIDR-formatted string (such as 10.1.2.0/32).
               Random address (/32) from pool would be allocated if field is omitted.
        :param builtins.str pool_id: Pool for the IPv4 public allocation.
               
               *Cannot be set alongside subnet_id.*
        :param builtins.str subnet_id: Subnet ID.
               Required same subnet to use allocation in subnet-resources (e.g. Network Interface)
               
               *Cannot be set alongside pool_id.*
        """
        if cidr is not None:
            pulumi.set(__self__, "cidr", cidr)
        if pool_id is not None:
            pulumi.set(__self__, "pool_id", pool_id)
        if subnet_id is not None:
            pulumi.set(__self__, "subnet_id", subnet_id)

    @property
    @pulumi.getter
    def cidr(self) -> Optional[builtins.str]:
        """
        CIDR block for IPv4 Allocation.
        May be a single IP address (such as 10.2.3.4),
        a prefix length (such as /32) or a CIDR-formatted string (such as 10.1.2.0/32).
        Random address (/32) from pool would be allocated if field is omitted.
        """
        return pulumi.get(self, "cidr")

    @property
    @pulumi.getter(name="poolId")
    def pool_id(self) -> Optional[builtins.str]:
        """
        Pool for the IPv4 public allocation.

        *Cannot be set alongside subnet_id.*
        """
        return pulumi.get(self, "pool_id")

    @property
    @pulumi.getter(name="subnetId")
    def subnet_id(self) -> Optional[builtins.str]:
        """
        Subnet ID.
        Required same subnet to use allocation in subnet-resources (e.g. Network Interface)

        *Cannot be set alongside pool_id.*
        """
        return pulumi.get(self, "subnet_id")


@pulumi.output_type
class VpcV1AllocationMetadata(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class VpcV1AllocationStatus(dict):
    def __init__(__self__, *,
                 assignment: Optional['outputs.VpcV1AllocationStatusAssignment'] = None,
                 details: Optional['outputs.VpcV1AllocationStatusDetails'] = None,
                 state: Optional[builtins.str] = None,
                 static: Optional[builtins.bool] = None):
        """
        :param 'VpcV1AllocationStatusAssignmentArgs' assignment: Information about the assignment associated with the allocation,
               such as network interface or load balancer assignment.
        :param 'VpcV1AllocationStatusDetailsArgs' details: Detailed information about the allocation status,
               including the allocated CIDR, pool ID and IP version.
        :param builtins.str state: This field represents the current state of the allocation.
               
               ### Supported values
               
               Enumeration of possible states of the Allocation.
               Possible values:
               
                - `STATE_UNSPECIFIED` - Default state, unspecified.
                - `CREATING` - Allocation is being created.
                - `ALLOCATED` - Allocation is ready for use.
                - `ASSIGNED` - Allocation is used.
                - `DELETING` - Allocation is being deleted.
        :param builtins.bool static: If false - Lifecycle of allocation depends on resource that using it.
        """
        if assignment is not None:
            pulumi.set(__self__, "assignment", assignment)
        if details is not None:
            pulumi.set(__self__, "details", details)
        if state is not None:
            pulumi.set(__self__, "state", state)
        if static is not None:
            pulumi.set(__self__, "static", static)

    @property
    @pulumi.getter
    def assignment(self) -> Optional['outputs.VpcV1AllocationStatusAssignment']:
        """
        Information about the assignment associated with the allocation,
        such as network interface or load balancer assignment.
        """
        return pulumi.get(self, "assignment")

    @property
    @pulumi.getter
    def details(self) -> Optional['outputs.VpcV1AllocationStatusDetails']:
        """
        Detailed information about the allocation status,
        including the allocated CIDR, pool ID and IP version.
        """
        return pulumi.get(self, "details")

    @property
    @pulumi.getter
    def state(self) -> Optional[builtins.str]:
        """
        This field represents the current state of the allocation.

        ### Supported values

        Enumeration of possible states of the Allocation.
        Possible values:

         - `STATE_UNSPECIFIED` - Default state, unspecified.
         - `CREATING` - Allocation is being created.
         - `ALLOCATED` - Allocation is ready for use.
         - `ASSIGNED` - Allocation is used.
         - `DELETING` - Allocation is being deleted.
        """
        return pulumi.get(self, "state")

    @property
    @pulumi.getter
    def static(self) -> Optional[builtins.bool]:
        """
        If false - Lifecycle of allocation depends on resource that using it.
        """
        return pulumi.get(self, "static")


@pulumi.output_type
class VpcV1AllocationStatusAssignment(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "loadBalancer":
            suggest = "load_balancer"
        elif key == "networkInterface":
            suggest = "network_interface"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VpcV1AllocationStatusAssignment. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VpcV1AllocationStatusAssignment.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VpcV1AllocationStatusAssignment.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 load_balancer: Optional['outputs.VpcV1AllocationStatusAssignmentLoadBalancer'] = None,
                 network_interface: Optional['outputs.VpcV1AllocationStatusAssignmentNetworkInterface'] = None):
        """
        :param 'VpcV1AllocationStatusAssignmentLoadBalancerArgs' load_balancer: *Cannot be set alongside network_interface.*
        :param 'VpcV1AllocationStatusAssignmentNetworkInterfaceArgs' network_interface: *Cannot be set alongside load_balancer.*
        """
        if load_balancer is not None:
            pulumi.set(__self__, "load_balancer", load_balancer)
        if network_interface is not None:
            pulumi.set(__self__, "network_interface", network_interface)

    @property
    @pulumi.getter(name="loadBalancer")
    def load_balancer(self) -> Optional['outputs.VpcV1AllocationStatusAssignmentLoadBalancer']:
        """
        *Cannot be set alongside network_interface.*
        """
        return pulumi.get(self, "load_balancer")

    @property
    @pulumi.getter(name="networkInterface")
    def network_interface(self) -> Optional['outputs.VpcV1AllocationStatusAssignmentNetworkInterface']:
        """
        *Cannot be set alongside load_balancer.*
        """
        return pulumi.get(self, "network_interface")


@pulumi.output_type
class VpcV1AllocationStatusAssignmentLoadBalancer(dict):
    def __init__(__self__, *,
                 id: Optional[builtins.str] = None):
        """
        :param builtins.str id: ID of the Load Balancer.
        """
        if id is not None:
            pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> Optional[builtins.str]:
        """
        ID of the Load Balancer.
        """
        return pulumi.get(self, "id")


@pulumi.output_type
class VpcV1AllocationStatusAssignmentNetworkInterface(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "instanceId":
            suggest = "instance_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VpcV1AllocationStatusAssignmentNetworkInterface. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VpcV1AllocationStatusAssignmentNetworkInterface.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VpcV1AllocationStatusAssignmentNetworkInterface.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 instance_id: Optional[builtins.str] = None,
                 name: Optional[builtins.str] = None):
        """
        :param builtins.str instance_id: ID of the Compute instance network interface belongs to.
        :param builtins.str name: Network interface name
        """
        if instance_id is not None:
            pulumi.set(__self__, "instance_id", instance_id)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter(name="instanceId")
    def instance_id(self) -> Optional[builtins.str]:
        """
        ID of the Compute instance network interface belongs to.
        """
        return pulumi.get(self, "instance_id")

    @property
    @pulumi.getter
    def name(self) -> Optional[builtins.str]:
        """
        Network interface name
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class VpcV1AllocationStatusDetails(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "allocatedCidr":
            suggest = "allocated_cidr"
        elif key == "poolId":
            suggest = "pool_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VpcV1AllocationStatusDetails. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VpcV1AllocationStatusDetails.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VpcV1AllocationStatusDetails.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 allocated_cidr: Optional[builtins.str] = None,
                 pool_id: Optional[builtins.str] = None,
                 version: Optional[builtins.str] = None):
        """
        :param builtins.str allocated_cidr: The actual CIDR block that has been allocated.
        :param builtins.str pool_id: ID of the pool from which this allocation was made.
        :param builtins.str version: The IP version of this allocation (IPv4 or IPv6).
               
               ### Supported values
               
               Possible values:
               
                - `IP_VERSION_UNSPECIFIED` - Default, unspecified IP version.
                - `IPV4` - IPv4 address.
                - `IPV6` - IPv6 address.
        """
        if allocated_cidr is not None:
            pulumi.set(__self__, "allocated_cidr", allocated_cidr)
        if pool_id is not None:
            pulumi.set(__self__, "pool_id", pool_id)
        if version is not None:
            pulumi.set(__self__, "version", version)

    @property
    @pulumi.getter(name="allocatedCidr")
    def allocated_cidr(self) -> Optional[builtins.str]:
        """
        The actual CIDR block that has been allocated.
        """
        return pulumi.get(self, "allocated_cidr")

    @property
    @pulumi.getter(name="poolId")
    def pool_id(self) -> Optional[builtins.str]:
        """
        ID of the pool from which this allocation was made.
        """
        return pulumi.get(self, "pool_id")

    @property
    @pulumi.getter
    def version(self) -> Optional[builtins.str]:
        """
        The IP version of this allocation (IPv4 or IPv6).

        ### Supported values

        Possible values:

         - `IP_VERSION_UNSPECIFIED` - Default, unspecified IP version.
         - `IPV4` - IPv4 address.
         - `IPV6` - IPv6 address.
        """
        return pulumi.get(self, "version")


@pulumi.output_type
class VpcV1NetworkIpv4PrivatePools(dict):
    def __init__(__self__, *,
                 pools: Optional[Sequence['outputs.VpcV1NetworkIpv4PrivatePoolsPool']] = None):
        if pools is not None:
            pulumi.set(__self__, "pools", pools)

    @property
    @pulumi.getter
    def pools(self) -> Optional[Sequence['outputs.VpcV1NetworkIpv4PrivatePoolsPool']]:
        return pulumi.get(self, "pools")


@pulumi.output_type
class VpcV1NetworkIpv4PrivatePoolsPool(dict):
    def __init__(__self__, *,
                 id: Optional[builtins.str] = None):
        """
        :param builtins.str id: ID of the IP address pool.
        """
        if id is not None:
            pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> Optional[builtins.str]:
        """
        ID of the IP address pool.
        """
        return pulumi.get(self, "id")


@pulumi.output_type
class VpcV1NetworkIpv4PublicPools(dict):
    def __init__(__self__, *,
                 pools: Optional[Sequence['outputs.VpcV1NetworkIpv4PublicPoolsPool']] = None):
        if pools is not None:
            pulumi.set(__self__, "pools", pools)

    @property
    @pulumi.getter
    def pools(self) -> Optional[Sequence['outputs.VpcV1NetworkIpv4PublicPoolsPool']]:
        return pulumi.get(self, "pools")


@pulumi.output_type
class VpcV1NetworkIpv4PublicPoolsPool(dict):
    def __init__(__self__, *,
                 id: Optional[builtins.str] = None):
        """
        :param builtins.str id: ID of the IP address pool.
        """
        if id is not None:
            pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> Optional[builtins.str]:
        """
        ID of the IP address pool.
        """
        return pulumi.get(self, "id")


@pulumi.output_type
class VpcV1NetworkMetadata(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class VpcV1NetworkStatus(dict):
    def __init__(__self__, *,
                 state: Optional[builtins.str] = None):
        """
        :param builtins.str state: Current state of the network.
               
               ### Supported values
               
               Enumeration of possible states of the network.
               Possible values:
               
                - `STATE_UNSPECIFIED` - Default state, unspecified.
                - `CREATING` - Network is being created.
                - `READY` - Network is ready for use.
                - `DELETING` - Network is being deleted.
        """
        if state is not None:
            pulumi.set(__self__, "state", state)

    @property
    @pulumi.getter
    def state(self) -> Optional[builtins.str]:
        """
        Current state of the network.

        ### Supported values

        Enumeration of possible states of the network.
        Possible values:

         - `STATE_UNSPECIFIED` - Default state, unspecified.
         - `CREATING` - Network is being created.
         - `READY` - Network is ready for use.
         - `DELETING` - Network is being deleted.
        """
        return pulumi.get(self, "state")


@pulumi.output_type
class VpcV1PoolCidr(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "maxMaskLength":
            suggest = "max_mask_length"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VpcV1PoolCidr. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VpcV1PoolCidr.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VpcV1PoolCidr.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cidr: builtins.str,
                 max_mask_length: Optional[builtins.float] = None,
                 state: Optional[builtins.str] = None):
        """
        :param builtins.str cidr: CIDR block.
               May be a prefix length (such as /24) for non-top-level pools
               or a CIDR-formatted string (such as 10.1.2.0/24).
        :param builtins.float max_mask_length: Maximum mask length for allocation from this cidr including creation of sub-pools
               Default max_mask_length is 32 for IPv4 and 128 for IPv6
        :param builtins.str state: State of the Cidr.
               Default state is AVAILABLE
               
               ### Supported values
               
               Possible values:
               
                - `STATE_UNSPECIFIED` - Default, unspecified state.
                - `AVAILABLE` - Allocation from range is available.
                - `DISABLED` - New allocation would not be created.
        """
        pulumi.set(__self__, "cidr", cidr)
        if max_mask_length is not None:
            pulumi.set(__self__, "max_mask_length", max_mask_length)
        if state is not None:
            pulumi.set(__self__, "state", state)

    @property
    @pulumi.getter
    def cidr(self) -> builtins.str:
        """
        CIDR block.
        May be a prefix length (such as /24) for non-top-level pools
        or a CIDR-formatted string (such as 10.1.2.0/24).
        """
        return pulumi.get(self, "cidr")

    @property
    @pulumi.getter(name="maxMaskLength")
    def max_mask_length(self) -> Optional[builtins.float]:
        """
        Maximum mask length for allocation from this cidr including creation of sub-pools
        Default max_mask_length is 32 for IPv4 and 128 for IPv6
        """
        return pulumi.get(self, "max_mask_length")

    @property
    @pulumi.getter
    def state(self) -> Optional[builtins.str]:
        """
        State of the Cidr.
        Default state is AVAILABLE

        ### Supported values

        Possible values:

         - `STATE_UNSPECIFIED` - Default, unspecified state.
         - `AVAILABLE` - Allocation from range is available.
         - `DISABLED` - New allocation would not be created.
        """
        return pulumi.get(self, "state")


@pulumi.output_type
class VpcV1PoolMetadata(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class VpcV1PoolStatus(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "scopeId":
            suggest = "scope_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VpcV1PoolStatus. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VpcV1PoolStatus.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VpcV1PoolStatus.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 assignment: Optional['outputs.VpcV1PoolStatusAssignment'] = None,
                 cidrs: Optional[Sequence[builtins.str]] = None,
                 scope_id: Optional[builtins.str] = None,
                 state: Optional[builtins.str] = None):
        """
        :param 'VpcV1PoolStatusAssignmentArgs' assignment: Assignment details for this Pool
        :param Sequence[builtins.str] cidrs: CIDR blocks.
        :param builtins.str scope_id: Scope is the unique identifier for single pool tree.
        :param builtins.str state: Current state of the Pool.
               
               ### Supported values
               
               Possible states of the Pool.
               Possible values:
               
                - `STATE_UNSPECIFIED` - Default, unspecified state.
                - `CREATING` - Pool is being created.
                - `READY` - Pool is ready for use.
                - `DELETING` - Pool is being deleted.
        """
        if assignment is not None:
            pulumi.set(__self__, "assignment", assignment)
        if cidrs is not None:
            pulumi.set(__self__, "cidrs", cidrs)
        if scope_id is not None:
            pulumi.set(__self__, "scope_id", scope_id)
        if state is not None:
            pulumi.set(__self__, "state", state)

    @property
    @pulumi.getter
    def assignment(self) -> Optional['outputs.VpcV1PoolStatusAssignment']:
        """
        Assignment details for this Pool
        """
        return pulumi.get(self, "assignment")

    @property
    @pulumi.getter
    def cidrs(self) -> Optional[Sequence[builtins.str]]:
        """
        CIDR blocks.
        """
        return pulumi.get(self, "cidrs")

    @property
    @pulumi.getter(name="scopeId")
    def scope_id(self) -> Optional[builtins.str]:
        """
        Scope is the unique identifier for single pool tree.
        """
        return pulumi.get(self, "scope_id")

    @property
    @pulumi.getter
    def state(self) -> Optional[builtins.str]:
        """
        Current state of the Pool.

        ### Supported values

        Possible states of the Pool.
        Possible values:

         - `STATE_UNSPECIFIED` - Default, unspecified state.
         - `CREATING` - Pool is being created.
         - `READY` - Pool is ready for use.
         - `DELETING` - Pool is being deleted.
        """
        return pulumi.get(self, "state")


@pulumi.output_type
class VpcV1PoolStatusAssignment(dict):
    def __init__(__self__, *,
                 networks: Optional[Sequence[builtins.str]] = None,
                 subnets: Optional[Sequence[builtins.str]] = None):
        """
        :param Sequence[builtins.str] networks: IDs of Networks to which the Pool is assigned.
        :param Sequence[builtins.str] subnets: IDs of Subnets to which the Pool is assigned.
        """
        if networks is not None:
            pulumi.set(__self__, "networks", networks)
        if subnets is not None:
            pulumi.set(__self__, "subnets", subnets)

    @property
    @pulumi.getter
    def networks(self) -> Optional[Sequence[builtins.str]]:
        """
        IDs of Networks to which the Pool is assigned.
        """
        return pulumi.get(self, "networks")

    @property
    @pulumi.getter
    def subnets(self) -> Optional[Sequence[builtins.str]]:
        """
        IDs of Subnets to which the Pool is assigned.
        """
        return pulumi.get(self, "subnets")


@pulumi.output_type
class VpcV1SubnetIpv4PrivatePools(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "useNetworkPools":
            suggest = "use_network_pools"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VpcV1SubnetIpv4PrivatePools. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VpcV1SubnetIpv4PrivatePools.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VpcV1SubnetIpv4PrivatePools.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 pools: Optional[Sequence['outputs.VpcV1SubnetIpv4PrivatePoolsPool']] = None,
                 use_network_pools: Optional[builtins.bool] = None):
        """
        :param Sequence['VpcV1SubnetIpv4PrivatePoolsPoolArgs'] pools: Pools for private ipv4 allocations in subnet
               Must be empty if 'use_network_pools = true'
        :param builtins.bool use_network_pools: Allow using of private ipv4 pools which are specified in network
               Must be false if 'pools' is not empty
        """
        if pools is not None:
            pulumi.set(__self__, "pools", pools)
        if use_network_pools is not None:
            pulumi.set(__self__, "use_network_pools", use_network_pools)

    @property
    @pulumi.getter
    def pools(self) -> Optional[Sequence['outputs.VpcV1SubnetIpv4PrivatePoolsPool']]:
        """
        Pools for private ipv4 allocations in subnet
        Must be empty if 'use_network_pools = true'
        """
        return pulumi.get(self, "pools")

    @property
    @pulumi.getter(name="useNetworkPools")
    def use_network_pools(self) -> Optional[builtins.bool]:
        """
        Allow using of private ipv4 pools which are specified in network
        Must be false if 'pools' is not empty
        """
        return pulumi.get(self, "use_network_pools")


@pulumi.output_type
class VpcV1SubnetIpv4PrivatePoolsPool(dict):
    def __init__(__self__, *,
                 cidrs: Optional[Sequence['outputs.VpcV1SubnetIpv4PrivatePoolsPoolCidr']] = None):
        if cidrs is not None:
            pulumi.set(__self__, "cidrs", cidrs)

    @property
    @pulumi.getter
    def cidrs(self) -> Optional[Sequence['outputs.VpcV1SubnetIpv4PrivatePoolsPoolCidr']]:
        return pulumi.get(self, "cidrs")


@pulumi.output_type
class VpcV1SubnetIpv4PrivatePoolsPoolCidr(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "maxMaskLength":
            suggest = "max_mask_length"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VpcV1SubnetIpv4PrivatePoolsPoolCidr. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VpcV1SubnetIpv4PrivatePoolsPoolCidr.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VpcV1SubnetIpv4PrivatePoolsPoolCidr.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cidr: Optional[builtins.str] = None,
                 max_mask_length: Optional[builtins.float] = None,
                 state: Optional[builtins.str] = None):
        """
        :param builtins.str cidr: CIDR block.
               May be a prefix length (such as /24) or a CIDR-formatted string (such as 10.1.2.0/24).
        :param builtins.float max_mask_length: Maximum mask length for allocation from this cidr
               Default max_mask_length is 32 for IPv4 and 128 for IPv6
        :param builtins.str state: State of the Cidr.
               Default state is AVAILABLE
               
               ### Supported values
               
               Possible values:
               
                - `STATE_UNSPECIFIED` - Default, unspecified state.
                - `AVAILABLE` - Allocation from range is available.
                - `DISABLED` - New allocation would not be created.
        """
        if cidr is not None:
            pulumi.set(__self__, "cidr", cidr)
        if max_mask_length is not None:
            pulumi.set(__self__, "max_mask_length", max_mask_length)
        if state is not None:
            pulumi.set(__self__, "state", state)

    @property
    @pulumi.getter
    def cidr(self) -> Optional[builtins.str]:
        """
        CIDR block.
        May be a prefix length (such as /24) or a CIDR-formatted string (such as 10.1.2.0/24).
        """
        return pulumi.get(self, "cidr")

    @property
    @pulumi.getter(name="maxMaskLength")
    def max_mask_length(self) -> Optional[builtins.float]:
        """
        Maximum mask length for allocation from this cidr
        Default max_mask_length is 32 for IPv4 and 128 for IPv6
        """
        return pulumi.get(self, "max_mask_length")

    @property
    @pulumi.getter
    def state(self) -> Optional[builtins.str]:
        """
        State of the Cidr.
        Default state is AVAILABLE

        ### Supported values

        Possible values:

         - `STATE_UNSPECIFIED` - Default, unspecified state.
         - `AVAILABLE` - Allocation from range is available.
         - `DISABLED` - New allocation would not be created.
        """
        return pulumi.get(self, "state")


@pulumi.output_type
class VpcV1SubnetIpv4PublicPools(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "useNetworkPools":
            suggest = "use_network_pools"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VpcV1SubnetIpv4PublicPools. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VpcV1SubnetIpv4PublicPools.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VpcV1SubnetIpv4PublicPools.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 pools: Optional[Sequence['outputs.VpcV1SubnetIpv4PublicPoolsPool']] = None,
                 use_network_pools: Optional[builtins.bool] = None):
        """
        :param Sequence['VpcV1SubnetIpv4PublicPoolsPoolArgs'] pools: Pools for public ipv4 allocations in subnet
               Must be empty if 'use_network_pools = true'
        :param builtins.bool use_network_pools: Allow using of public ipv4 pools which are specified in network
               Must be false if 'pools' is not empty
        """
        if pools is not None:
            pulumi.set(__self__, "pools", pools)
        if use_network_pools is not None:
            pulumi.set(__self__, "use_network_pools", use_network_pools)

    @property
    @pulumi.getter
    def pools(self) -> Optional[Sequence['outputs.VpcV1SubnetIpv4PublicPoolsPool']]:
        """
        Pools for public ipv4 allocations in subnet
        Must be empty if 'use_network_pools = true'
        """
        return pulumi.get(self, "pools")

    @property
    @pulumi.getter(name="useNetworkPools")
    def use_network_pools(self) -> Optional[builtins.bool]:
        """
        Allow using of public ipv4 pools which are specified in network
        Must be false if 'pools' is not empty
        """
        return pulumi.get(self, "use_network_pools")


@pulumi.output_type
class VpcV1SubnetIpv4PublicPoolsPool(dict):
    def __init__(__self__, *,
                 cidrs: Optional[Sequence['outputs.VpcV1SubnetIpv4PublicPoolsPoolCidr']] = None):
        if cidrs is not None:
            pulumi.set(__self__, "cidrs", cidrs)

    @property
    @pulumi.getter
    def cidrs(self) -> Optional[Sequence['outputs.VpcV1SubnetIpv4PublicPoolsPoolCidr']]:
        return pulumi.get(self, "cidrs")


@pulumi.output_type
class VpcV1SubnetIpv4PublicPoolsPoolCidr(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "maxMaskLength":
            suggest = "max_mask_length"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VpcV1SubnetIpv4PublicPoolsPoolCidr. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VpcV1SubnetIpv4PublicPoolsPoolCidr.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VpcV1SubnetIpv4PublicPoolsPoolCidr.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cidr: Optional[builtins.str] = None,
                 max_mask_length: Optional[builtins.float] = None,
                 state: Optional[builtins.str] = None):
        """
        :param builtins.str cidr: CIDR block.
               May be a prefix length (such as /24) or a CIDR-formatted string (such as 10.1.2.0/24).
        :param builtins.float max_mask_length: Maximum mask length for allocation from this cidr
               Default max_mask_length is 32 for IPv4 and 128 for IPv6
        :param builtins.str state: State of the Cidr.
               Default state is AVAILABLE
               
               ### Supported values
               
               Possible values:
               
                - `STATE_UNSPECIFIED` - Default, unspecified state.
                - `AVAILABLE` - Allocation from range is available.
                - `DISABLED` - New allocation would not be created.
        """
        if cidr is not None:
            pulumi.set(__self__, "cidr", cidr)
        if max_mask_length is not None:
            pulumi.set(__self__, "max_mask_length", max_mask_length)
        if state is not None:
            pulumi.set(__self__, "state", state)

    @property
    @pulumi.getter
    def cidr(self) -> Optional[builtins.str]:
        """
        CIDR block.
        May be a prefix length (such as /24) or a CIDR-formatted string (such as 10.1.2.0/24).
        """
        return pulumi.get(self, "cidr")

    @property
    @pulumi.getter(name="maxMaskLength")
    def max_mask_length(self) -> Optional[builtins.float]:
        """
        Maximum mask length for allocation from this cidr
        Default max_mask_length is 32 for IPv4 and 128 for IPv6
        """
        return pulumi.get(self, "max_mask_length")

    @property
    @pulumi.getter
    def state(self) -> Optional[builtins.str]:
        """
        State of the Cidr.
        Default state is AVAILABLE

        ### Supported values

        Possible values:

         - `STATE_UNSPECIFIED` - Default, unspecified state.
         - `AVAILABLE` - Allocation from range is available.
         - `DISABLED` - New allocation would not be created.
        """
        return pulumi.get(self, "state")


@pulumi.output_type
class VpcV1SubnetMetadata(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class VpcV1SubnetStatus(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "ipv4PrivateCidrs":
            suggest = "ipv4_private_cidrs"
        elif key == "ipv4PublicCidrs":
            suggest = "ipv4_public_cidrs"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VpcV1SubnetStatus. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VpcV1SubnetStatus.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VpcV1SubnetStatus.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ipv4_private_cidrs: Optional[Sequence[builtins.str]] = None,
                 ipv4_public_cidrs: Optional[Sequence[builtins.str]] = None,
                 state: Optional[builtins.str] = None):
        """
        :param Sequence[builtins.str] ipv4_private_cidrs: CIDR blocks.
        :param Sequence[builtins.str] ipv4_public_cidrs: CIDR blocks.
        :param builtins.str state: Current state of the subnet.
               
               ### Supported values
               
               Enumeration of possible states of the subnet.
               Possible values:
               
                - `STATE_UNSPECIFIED` - Default state, unspecified.
                - `CREATING` - Subnet is being created.
                - `READY` - Subnet is ready for use.
                - `DELETING` - Subnet is being deleted.
        """
        if ipv4_private_cidrs is not None:
            pulumi.set(__self__, "ipv4_private_cidrs", ipv4_private_cidrs)
        if ipv4_public_cidrs is not None:
            pulumi.set(__self__, "ipv4_public_cidrs", ipv4_public_cidrs)
        if state is not None:
            pulumi.set(__self__, "state", state)

    @property
    @pulumi.getter(name="ipv4PrivateCidrs")
    def ipv4_private_cidrs(self) -> Optional[Sequence[builtins.str]]:
        """
        CIDR blocks.
        """
        return pulumi.get(self, "ipv4_private_cidrs")

    @property
    @pulumi.getter(name="ipv4PublicCidrs")
    def ipv4_public_cidrs(self) -> Optional[Sequence[builtins.str]]:
        """
        CIDR blocks.
        """
        return pulumi.get(self, "ipv4_public_cidrs")

    @property
    @pulumi.getter
    def state(self) -> Optional[builtins.str]:
        """
        Current state of the subnet.

        ### Supported values

        Enumeration of possible states of the subnet.
        Possible values:

         - `STATE_UNSPECIFIED` - Default state, unspecified.
         - `CREATING` - Subnet is being created.
         - `READY` - Subnet is ready for use.
         - `DELETING` - Subnet is being deleted.
        """
        return pulumi.get(self, "state")


@pulumi.output_type
class VpcV1alpha1AllocationIpv4Private(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "poolId":
            suggest = "pool_id"
        elif key == "subnetId":
            suggest = "subnet_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VpcV1alpha1AllocationIpv4Private. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VpcV1alpha1AllocationIpv4Private.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VpcV1alpha1AllocationIpv4Private.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cidr: Optional[builtins.str] = None,
                 pool_id: Optional[builtins.str] = None,
                 subnet_id: Optional[builtins.str] = None):
        """
        :param builtins.str cidr: CIDR block for IPv4 Allocation.
               May be a single IP address (such as 10.2.3.4),
               a prefix length (such as /24) or a CIDR-formatted string (such as 10.1.2.0/24).
               Random address (/32) from pool would be allocated if field is omitted.
        :param builtins.str pool_id: Pool for the IPv4 private allocation.
               
               *Cannot be set alongside subnet_id.*
        :param builtins.str subnet_id: Subnet ID.
               Required same subnet to use allocation in subnet-resources (e.g. Network Interface)
               
               *Cannot be set alongside pool_id.*
        """
        if cidr is not None:
            pulumi.set(__self__, "cidr", cidr)
        if pool_id is not None:
            pulumi.set(__self__, "pool_id", pool_id)
        if subnet_id is not None:
            pulumi.set(__self__, "subnet_id", subnet_id)

    @property
    @pulumi.getter
    def cidr(self) -> Optional[builtins.str]:
        """
        CIDR block for IPv4 Allocation.
        May be a single IP address (such as 10.2.3.4),
        a prefix length (such as /24) or a CIDR-formatted string (such as 10.1.2.0/24).
        Random address (/32) from pool would be allocated if field is omitted.
        """
        return pulumi.get(self, "cidr")

    @property
    @pulumi.getter(name="poolId")
    def pool_id(self) -> Optional[builtins.str]:
        """
        Pool for the IPv4 private allocation.

        *Cannot be set alongside subnet_id.*
        """
        return pulumi.get(self, "pool_id")

    @property
    @pulumi.getter(name="subnetId")
    def subnet_id(self) -> Optional[builtins.str]:
        """
        Subnet ID.
        Required same subnet to use allocation in subnet-resources (e.g. Network Interface)

        *Cannot be set alongside pool_id.*
        """
        return pulumi.get(self, "subnet_id")


@pulumi.output_type
class VpcV1alpha1AllocationIpv4Public(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "poolId":
            suggest = "pool_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VpcV1alpha1AllocationIpv4Public. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VpcV1alpha1AllocationIpv4Public.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VpcV1alpha1AllocationIpv4Public.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cidr: Optional[builtins.str] = None,
                 pool_id: Optional[builtins.str] = None):
        """
        :param builtins.str cidr: CIDR block for IPv4 Allocation.
               May be a single IP address (such as 10.2.3.4),
               a prefix length (such as /32) or a CIDR-formatted string (such as 10.1.2.0/32).
               Random address (/32) from pool would be allocated if field is omitted.
        :param builtins.str pool_id: Pool for the IPv4 public allocation.
        """
        if cidr is not None:
            pulumi.set(__self__, "cidr", cidr)
        if pool_id is not None:
            pulumi.set(__self__, "pool_id", pool_id)

    @property
    @pulumi.getter
    def cidr(self) -> Optional[builtins.str]:
        """
        CIDR block for IPv4 Allocation.
        May be a single IP address (such as 10.2.3.4),
        a prefix length (such as /32) or a CIDR-formatted string (such as 10.1.2.0/32).
        Random address (/32) from pool would be allocated if field is omitted.
        """
        return pulumi.get(self, "cidr")

    @property
    @pulumi.getter(name="poolId")
    def pool_id(self) -> Optional[builtins.str]:
        """
        Pool for the IPv4 public allocation.
        """
        return pulumi.get(self, "pool_id")


@pulumi.output_type
class VpcV1alpha1AllocationMetadata(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class VpcV1alpha1AllocationStatus(dict):
    def __init__(__self__, *,
                 assignment: Optional['outputs.VpcV1alpha1AllocationStatusAssignment'] = None,
                 details: Optional['outputs.VpcV1alpha1AllocationStatusDetails'] = None,
                 state: Optional[builtins.str] = None,
                 static: Optional[builtins.bool] = None):
        """
        :param 'VpcV1alpha1AllocationStatusAssignmentArgs' assignment: Information about the assignment associated with the allocation,
               such as network interface or load balancer assignment.
        :param 'VpcV1alpha1AllocationStatusDetailsArgs' details: Detailed information about the allocation status,
               including the allocated CIDR, pool ID, scope type, and IP version.
        :param builtins.str state: This field represents the current state of the allocation.
               
               ### Supported values
               
               Enumeration of possible states of the Allocation.
               Possible values:
               
                - `STATE_UNSPECIFIED` - Default state, unspecified.
                - `CREATING` - Allocation is being created.
                - `ALLOCATED` - Allocation is ready for use.
                - `ASSIGNED` - Allocation is used.
                - `DELETING` - Allocation is being deleted.
        :param builtins.bool static: If false - Lifecycle of allocation depends on resource that using it.
        """
        if assignment is not None:
            pulumi.set(__self__, "assignment", assignment)
        if details is not None:
            pulumi.set(__self__, "details", details)
        if state is not None:
            pulumi.set(__self__, "state", state)
        if static is not None:
            pulumi.set(__self__, "static", static)

    @property
    @pulumi.getter
    def assignment(self) -> Optional['outputs.VpcV1alpha1AllocationStatusAssignment']:
        """
        Information about the assignment associated with the allocation,
        such as network interface or load balancer assignment.
        """
        return pulumi.get(self, "assignment")

    @property
    @pulumi.getter
    def details(self) -> Optional['outputs.VpcV1alpha1AllocationStatusDetails']:
        """
        Detailed information about the allocation status,
        including the allocated CIDR, pool ID, scope type, and IP version.
        """
        return pulumi.get(self, "details")

    @property
    @pulumi.getter
    def state(self) -> Optional[builtins.str]:
        """
        This field represents the current state of the allocation.

        ### Supported values

        Enumeration of possible states of the Allocation.
        Possible values:

         - `STATE_UNSPECIFIED` - Default state, unspecified.
         - `CREATING` - Allocation is being created.
         - `ALLOCATED` - Allocation is ready for use.
         - `ASSIGNED` - Allocation is used.
         - `DELETING` - Allocation is being deleted.
        """
        return pulumi.get(self, "state")

    @property
    @pulumi.getter
    def static(self) -> Optional[builtins.bool]:
        """
        If false - Lifecycle of allocation depends on resource that using it.
        """
        return pulumi.get(self, "static")


@pulumi.output_type
class VpcV1alpha1AllocationStatusAssignment(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "loadBalancer":
            suggest = "load_balancer"
        elif key == "networkInterface":
            suggest = "network_interface"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VpcV1alpha1AllocationStatusAssignment. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VpcV1alpha1AllocationStatusAssignment.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VpcV1alpha1AllocationStatusAssignment.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 load_balancer: Optional['outputs.VpcV1alpha1AllocationStatusAssignmentLoadBalancer'] = None,
                 network_interface: Optional['outputs.VpcV1alpha1AllocationStatusAssignmentNetworkInterface'] = None):
        """
        :param 'VpcV1alpha1AllocationStatusAssignmentLoadBalancerArgs' load_balancer: *Cannot be set alongside network_interface.*
        :param 'VpcV1alpha1AllocationStatusAssignmentNetworkInterfaceArgs' network_interface: *Cannot be set alongside load_balancer.*
        """
        if load_balancer is not None:
            pulumi.set(__self__, "load_balancer", load_balancer)
        if network_interface is not None:
            pulumi.set(__self__, "network_interface", network_interface)

    @property
    @pulumi.getter(name="loadBalancer")
    def load_balancer(self) -> Optional['outputs.VpcV1alpha1AllocationStatusAssignmentLoadBalancer']:
        """
        *Cannot be set alongside network_interface.*
        """
        return pulumi.get(self, "load_balancer")

    @property
    @pulumi.getter(name="networkInterface")
    def network_interface(self) -> Optional['outputs.VpcV1alpha1AllocationStatusAssignmentNetworkInterface']:
        """
        *Cannot be set alongside load_balancer.*
        """
        return pulumi.get(self, "network_interface")


@pulumi.output_type
class VpcV1alpha1AllocationStatusAssignmentLoadBalancer(dict):
    def __init__(__self__, *,
                 id: Optional[builtins.str] = None):
        """
        :param builtins.str id: ID of the Load Balancer.
        """
        if id is not None:
            pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> Optional[builtins.str]:
        """
        ID of the Load Balancer.
        """
        return pulumi.get(self, "id")


@pulumi.output_type
class VpcV1alpha1AllocationStatusAssignmentNetworkInterface(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "instanceId":
            suggest = "instance_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VpcV1alpha1AllocationStatusAssignmentNetworkInterface. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VpcV1alpha1AllocationStatusAssignmentNetworkInterface.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VpcV1alpha1AllocationStatusAssignmentNetworkInterface.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 instance_id: Optional[builtins.str] = None,
                 name: Optional[builtins.str] = None):
        """
        :param builtins.str instance_id: ID of the Compute instance network interface belongs to.
        :param builtins.str name: Network interface name
        """
        if instance_id is not None:
            pulumi.set(__self__, "instance_id", instance_id)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter(name="instanceId")
    def instance_id(self) -> Optional[builtins.str]:
        """
        ID of the Compute instance network interface belongs to.
        """
        return pulumi.get(self, "instance_id")

    @property
    @pulumi.getter
    def name(self) -> Optional[builtins.str]:
        """
        Network interface name
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class VpcV1alpha1AllocationStatusDetails(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "allocatedCidr":
            suggest = "allocated_cidr"
        elif key == "poolId":
            suggest = "pool_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VpcV1alpha1AllocationStatusDetails. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VpcV1alpha1AllocationStatusDetails.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VpcV1alpha1AllocationStatusDetails.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 allocated_cidr: Optional[builtins.str] = None,
                 pool_id: Optional[builtins.str] = None,
                 version: Optional[builtins.str] = None):
        """
        :param builtins.str version: ### Supported values
               
               Possible values:
               
                - `IP_VERSION_UNSPECIFIED` - Default, unspecified IP version.
                - `IPV4` - IPv4 address.
                - `IPV6` - IPv6 address.
        """
        if allocated_cidr is not None:
            pulumi.set(__self__, "allocated_cidr", allocated_cidr)
        if pool_id is not None:
            pulumi.set(__self__, "pool_id", pool_id)
        if version is not None:
            pulumi.set(__self__, "version", version)

    @property
    @pulumi.getter(name="allocatedCidr")
    def allocated_cidr(self) -> Optional[builtins.str]:
        return pulumi.get(self, "allocated_cidr")

    @property
    @pulumi.getter(name="poolId")
    def pool_id(self) -> Optional[builtins.str]:
        return pulumi.get(self, "pool_id")

    @property
    @pulumi.getter
    def version(self) -> Optional[builtins.str]:
        """
        ### Supported values

        Possible values:

         - `IP_VERSION_UNSPECIFIED` - Default, unspecified IP version.
         - `IPV4` - IPv4 address.
         - `IPV6` - IPv6 address.
        """
        return pulumi.get(self, "version")


@pulumi.output_type
class GetApplicationsV1alpha1K8sReleaseMetadataResult(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class GetApplicationsV1alpha1K8sReleaseStatusResult(dict):
    def __init__(__self__, *,
                 error_message: builtins.str,
                 state: builtins.str):
        """
        :param builtins.str state: ### Supported values
               
               Possible values:
               
                - `UNSPECIFIED`
                - `CREATED`
                - `RUNNING`
                - `DEPLOYED`
                - `FAILED`
                - `INSTALLING`
        """
        pulumi.set(__self__, "error_message", error_message)
        pulumi.set(__self__, "state", state)

    @property
    @pulumi.getter(name="errorMessage")
    def error_message(self) -> builtins.str:
        return pulumi.get(self, "error_message")

    @property
    @pulumi.getter
    def state(self) -> builtins.str:
        """
        ### Supported values

        Possible values:

         - `UNSPECIFIED`
         - `CREATED`
         - `RUNNING`
         - `DEPLOYED`
         - `FAILED`
         - `INSTALLING`
        """
        return pulumi.get(self, "state")


@pulumi.output_type
class GetComputeV1DiskMetadataResult(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class GetComputeV1DiskPlacementPolicyResult(dict):
    def __init__(__self__, *,
                 placement_group_id: builtins.str,
                 placement_group_partition: builtins.float):
        pulumi.set(__self__, "placement_group_id", placement_group_id)
        pulumi.set(__self__, "placement_group_partition", placement_group_partition)

    @property
    @pulumi.getter(name="placementGroupId")
    def placement_group_id(self) -> builtins.str:
        return pulumi.get(self, "placement_group_id")

    @property
    @pulumi.getter(name="placementGroupPartition")
    def placement_group_partition(self) -> builtins.float:
        return pulumi.get(self, "placement_group_partition")


@pulumi.output_type
class GetComputeV1DiskSourceImageFamilyResult(dict):
    def __init__(__self__, *,
                 image_family: builtins.str,
                 parent_id: builtins.str):
        pulumi.set(__self__, "image_family", image_family)
        pulumi.set(__self__, "parent_id", parent_id)

    @property
    @pulumi.getter(name="imageFamily")
    def image_family(self) -> builtins.str:
        return pulumi.get(self, "image_family")

    @property
    @pulumi.getter(name="parentId")
    def parent_id(self) -> builtins.str:
        return pulumi.get(self, "parent_id")


@pulumi.output_type
class GetComputeV1DiskStatusResult(dict):
    def __init__(__self__, *,
                 block_size_bytes: builtins.float,
                 read_only_attachments: Sequence[builtins.str],
                 read_write_attachment: builtins.str,
                 reconciling: builtins.bool,
                 size_bytes: builtins.float,
                 source_image_cpu_architecture: builtins.str,
                 source_image_id: builtins.str,
                 state: builtins.str,
                 state_description: builtins.str):
        """
        :param builtins.bool reconciling: Indicates whether there is an ongoing operation
        :param builtins.str source_image_cpu_architecture: ### Supported values
               
               Possible values:
               
                - `SOURCE_IMAGE_CPU_UNSPECIFIED`
                - `AMD64`
                - `ARM64`
        :param builtins.str state: ### Supported values
               
               Possible values:
               
                - `UNSPECIFIED`
                - `CREATING`
                - `READY`
                - `UPDATING`
                - `DELETING`
                - `ERROR`
        """
        pulumi.set(__self__, "block_size_bytes", block_size_bytes)
        pulumi.set(__self__, "read_only_attachments", read_only_attachments)
        pulumi.set(__self__, "read_write_attachment", read_write_attachment)
        pulumi.set(__self__, "reconciling", reconciling)
        pulumi.set(__self__, "size_bytes", size_bytes)
        pulumi.set(__self__, "source_image_cpu_architecture", source_image_cpu_architecture)
        pulumi.set(__self__, "source_image_id", source_image_id)
        pulumi.set(__self__, "state", state)
        pulumi.set(__self__, "state_description", state_description)

    @property
    @pulumi.getter(name="blockSizeBytes")
    def block_size_bytes(self) -> builtins.float:
        return pulumi.get(self, "block_size_bytes")

    @property
    @pulumi.getter(name="readOnlyAttachments")
    def read_only_attachments(self) -> Sequence[builtins.str]:
        return pulumi.get(self, "read_only_attachments")

    @property
    @pulumi.getter(name="readWriteAttachment")
    def read_write_attachment(self) -> builtins.str:
        return pulumi.get(self, "read_write_attachment")

    @property
    @pulumi.getter
    def reconciling(self) -> builtins.bool:
        """
        Indicates whether there is an ongoing operation
        """
        return pulumi.get(self, "reconciling")

    @property
    @pulumi.getter(name="sizeBytes")
    def size_bytes(self) -> builtins.float:
        return pulumi.get(self, "size_bytes")

    @property
    @pulumi.getter(name="sourceImageCpuArchitecture")
    def source_image_cpu_architecture(self) -> builtins.str:
        """
        ### Supported values

        Possible values:

         - `SOURCE_IMAGE_CPU_UNSPECIFIED`
         - `AMD64`
         - `ARM64`
        """
        return pulumi.get(self, "source_image_cpu_architecture")

    @property
    @pulumi.getter(name="sourceImageId")
    def source_image_id(self) -> builtins.str:
        return pulumi.get(self, "source_image_id")

    @property
    @pulumi.getter
    def state(self) -> builtins.str:
        """
        ### Supported values

        Possible values:

         - `UNSPECIFIED`
         - `CREATING`
         - `READY`
         - `UPDATING`
         - `DELETING`
         - `ERROR`
        """
        return pulumi.get(self, "state")

    @property
    @pulumi.getter(name="stateDescription")
    def state_description(self) -> builtins.str:
        return pulumi.get(self, "state_description")


@pulumi.output_type
class GetComputeV1FilesystemMetadataResult(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class GetComputeV1FilesystemStatusResult(dict):
    def __init__(__self__, *,
                 block_size_bytes: builtins.float,
                 read_only_attachments: Sequence[builtins.str],
                 read_write_attachments: Sequence[builtins.str],
                 reconciling: builtins.bool,
                 size_bytes: builtins.float,
                 state: builtins.str,
                 state_description: builtins.str):
        """
        :param builtins.bool reconciling: Indicates whether there is an ongoing operation
        :param builtins.str state: ### Supported values
               
               Possible values:
               
                - `UNSPECIFIED`
                - `CREATING`
                - `READY`
                - `UPDATING`
                - `DELETING`
                - `ERROR`
        """
        pulumi.set(__self__, "block_size_bytes", block_size_bytes)
        pulumi.set(__self__, "read_only_attachments", read_only_attachments)
        pulumi.set(__self__, "read_write_attachments", read_write_attachments)
        pulumi.set(__self__, "reconciling", reconciling)
        pulumi.set(__self__, "size_bytes", size_bytes)
        pulumi.set(__self__, "state", state)
        pulumi.set(__self__, "state_description", state_description)

    @property
    @pulumi.getter(name="blockSizeBytes")
    def block_size_bytes(self) -> builtins.float:
        return pulumi.get(self, "block_size_bytes")

    @property
    @pulumi.getter(name="readOnlyAttachments")
    def read_only_attachments(self) -> Sequence[builtins.str]:
        return pulumi.get(self, "read_only_attachments")

    @property
    @pulumi.getter(name="readWriteAttachments")
    def read_write_attachments(self) -> Sequence[builtins.str]:
        return pulumi.get(self, "read_write_attachments")

    @property
    @pulumi.getter
    def reconciling(self) -> builtins.bool:
        """
        Indicates whether there is an ongoing operation
        """
        return pulumi.get(self, "reconciling")

    @property
    @pulumi.getter(name="sizeBytes")
    def size_bytes(self) -> builtins.float:
        return pulumi.get(self, "size_bytes")

    @property
    @pulumi.getter
    def state(self) -> builtins.str:
        """
        ### Supported values

        Possible values:

         - `UNSPECIFIED`
         - `CREATING`
         - `READY`
         - `UPDATING`
         - `DELETING`
         - `ERROR`
        """
        return pulumi.get(self, "state")

    @property
    @pulumi.getter(name="stateDescription")
    def state_description(self) -> builtins.str:
        return pulumi.get(self, "state_description")


@pulumi.output_type
class GetComputeV1GpuClusterMetadataResult(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class GetComputeV1GpuClusterStatusResult(dict):
    def __init__(__self__, *,
                 infiniband_topology_path: 'outputs.GetComputeV1GpuClusterStatusInfinibandTopologyPathResult',
                 instances: Sequence[builtins.str],
                 reconciling: builtins.bool):
        """
        :param builtins.bool reconciling: Indicates whether there is an ongoing operation
        """
        pulumi.set(__self__, "infiniband_topology_path", infiniband_topology_path)
        pulumi.set(__self__, "instances", instances)
        pulumi.set(__self__, "reconciling", reconciling)

    @property
    @pulumi.getter(name="infinibandTopologyPath")
    def infiniband_topology_path(self) -> 'outputs.GetComputeV1GpuClusterStatusInfinibandTopologyPathResult':
        return pulumi.get(self, "infiniband_topology_path")

    @property
    @pulumi.getter
    def instances(self) -> Sequence[builtins.str]:
        return pulumi.get(self, "instances")

    @property
    @pulumi.getter
    def reconciling(self) -> builtins.bool:
        """
        Indicates whether there is an ongoing operation
        """
        return pulumi.get(self, "reconciling")


@pulumi.output_type
class GetComputeV1GpuClusterStatusInfinibandTopologyPathResult(dict):
    def __init__(__self__, *,
                 instances: Sequence['outputs.GetComputeV1GpuClusterStatusInfinibandTopologyPathInstanceResult']):
        pulumi.set(__self__, "instances", instances)

    @property
    @pulumi.getter
    def instances(self) -> Sequence['outputs.GetComputeV1GpuClusterStatusInfinibandTopologyPathInstanceResult']:
        return pulumi.get(self, "instances")


@pulumi.output_type
class GetComputeV1GpuClusterStatusInfinibandTopologyPathInstanceResult(dict):
    def __init__(__self__, *,
                 instance_id: builtins.str,
                 paths: Sequence[builtins.str]):
        pulumi.set(__self__, "instance_id", instance_id)
        pulumi.set(__self__, "paths", paths)

    @property
    @pulumi.getter(name="instanceId")
    def instance_id(self) -> builtins.str:
        return pulumi.get(self, "instance_id")

    @property
    @pulumi.getter
    def paths(self) -> Sequence[builtins.str]:
        return pulumi.get(self, "paths")


@pulumi.output_type
class GetComputeV1ImageMetadataResult(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class GetComputeV1ImageStatusResult(dict):
    def __init__(__self__, *,
                 min_disk_size_bytes: builtins.float,
                 reconciling: builtins.bool,
                 state: builtins.str,
                 state_description: builtins.str,
                 storage_size_bytes: builtins.float):
        """
        :param builtins.bool reconciling: Indicates whether there is an ongoing operation
        :param builtins.str state: ### Supported values
               
               Possible values:
               
                - `UNSPECIFIED`
                - `CREATING`
                - `READY`
                - `UPDATING`
                - `DELETING`
                - `ERROR`
        """
        pulumi.set(__self__, "min_disk_size_bytes", min_disk_size_bytes)
        pulumi.set(__self__, "reconciling", reconciling)
        pulumi.set(__self__, "state", state)
        pulumi.set(__self__, "state_description", state_description)
        pulumi.set(__self__, "storage_size_bytes", storage_size_bytes)

    @property
    @pulumi.getter(name="minDiskSizeBytes")
    def min_disk_size_bytes(self) -> builtins.float:
        return pulumi.get(self, "min_disk_size_bytes")

    @property
    @pulumi.getter
    def reconciling(self) -> builtins.bool:
        """
        Indicates whether there is an ongoing operation
        """
        return pulumi.get(self, "reconciling")

    @property
    @pulumi.getter
    def state(self) -> builtins.str:
        """
        ### Supported values

        Possible values:

         - `UNSPECIFIED`
         - `CREATING`
         - `READY`
         - `UPDATING`
         - `DELETING`
         - `ERROR`
        """
        return pulumi.get(self, "state")

    @property
    @pulumi.getter(name="stateDescription")
    def state_description(self) -> builtins.str:
        return pulumi.get(self, "state_description")

    @property
    @pulumi.getter(name="storageSizeBytes")
    def storage_size_bytes(self) -> builtins.float:
        return pulumi.get(self, "storage_size_bytes")


@pulumi.output_type
class GetComputeV1InstanceBootDiskResult(dict):
    def __init__(__self__, *,
                 attach_mode: builtins.str,
                 device_id: builtins.str,
                 existing_disk: 'outputs.GetComputeV1InstanceBootDiskExistingDiskResult'):
        """
        :param builtins.str attach_mode: ### Supported values
               
               Possible values:
               
                - `UNSPECIFIED`
                - `READ_ONLY`
                - `READ_WRITE`
        :param builtins.str device_id: Specifies the user-defined identifier, allowing to use '/dev/disk/by-id/virtio-{device_id}' as a device path in mount command.
        """
        pulumi.set(__self__, "attach_mode", attach_mode)
        pulumi.set(__self__, "device_id", device_id)
        pulumi.set(__self__, "existing_disk", existing_disk)

    @property
    @pulumi.getter(name="attachMode")
    def attach_mode(self) -> builtins.str:
        """
        ### Supported values

        Possible values:

         - `UNSPECIFIED`
         - `READ_ONLY`
         - `READ_WRITE`
        """
        return pulumi.get(self, "attach_mode")

    @property
    @pulumi.getter(name="deviceId")
    def device_id(self) -> builtins.str:
        """
        Specifies the user-defined identifier, allowing to use '/dev/disk/by-id/virtio-{device_id}' as a device path in mount command.
        """
        return pulumi.get(self, "device_id")

    @property
    @pulumi.getter(name="existingDisk")
    def existing_disk(self) -> 'outputs.GetComputeV1InstanceBootDiskExistingDiskResult':
        return pulumi.get(self, "existing_disk")


@pulumi.output_type
class GetComputeV1InstanceBootDiskExistingDiskResult(dict):
    def __init__(__self__, *,
                 id: builtins.str):
        pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> builtins.str:
        return pulumi.get(self, "id")


@pulumi.output_type
class GetComputeV1InstanceFilesystemResult(dict):
    def __init__(__self__, *,
                 attach_mode: builtins.str,
                 existing_filesystem: 'outputs.GetComputeV1InstanceFilesystemExistingFilesystemResult',
                 mount_tag: builtins.str):
        """
        :param builtins.str attach_mode: ### Supported values
               
               Possible values:
               
                - `UNSPECIFIED`
                - `READ_ONLY`
                - `READ_WRITE`
        :param builtins.str mount_tag: Specifies the user-defined identifier, allowing to use it as a device in mount command.
        """
        pulumi.set(__self__, "attach_mode", attach_mode)
        pulumi.set(__self__, "existing_filesystem", existing_filesystem)
        pulumi.set(__self__, "mount_tag", mount_tag)

    @property
    @pulumi.getter(name="attachMode")
    def attach_mode(self) -> builtins.str:
        """
        ### Supported values

        Possible values:

         - `UNSPECIFIED`
         - `READ_ONLY`
         - `READ_WRITE`
        """
        return pulumi.get(self, "attach_mode")

    @property
    @pulumi.getter(name="existingFilesystem")
    def existing_filesystem(self) -> 'outputs.GetComputeV1InstanceFilesystemExistingFilesystemResult':
        return pulumi.get(self, "existing_filesystem")

    @property
    @pulumi.getter(name="mountTag")
    def mount_tag(self) -> builtins.str:
        """
        Specifies the user-defined identifier, allowing to use it as a device in mount command.
        """
        return pulumi.get(self, "mount_tag")


@pulumi.output_type
class GetComputeV1InstanceFilesystemExistingFilesystemResult(dict):
    def __init__(__self__, *,
                 id: builtins.str):
        pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> builtins.str:
        return pulumi.get(self, "id")


@pulumi.output_type
class GetComputeV1InstanceGpuClusterResult(dict):
    def __init__(__self__, *,
                 id: builtins.str):
        pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> builtins.str:
        return pulumi.get(self, "id")


@pulumi.output_type
class GetComputeV1InstanceMetadataResult(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class GetComputeV1InstanceNetworkInterfaceResult(dict):
    def __init__(__self__, *,
                 ip_address: 'outputs.GetComputeV1InstanceNetworkInterfaceIpAddressResult',
                 name: builtins.str,
                 public_ip_address: 'outputs.GetComputeV1InstanceNetworkInterfacePublicIpAddressResult',
                 subnet_id: builtins.str):
        """
        :param 'GetComputeV1InstanceNetworkInterfaceIpAddressArgs' ip_address: Private IPv4 address associated with the interface.
               
               ### Inner value description
               
               Describes an IPv4 address.
        :param builtins.str name: Interface name
               Value of this field configures the name of the network interface inside VM's OS.
               Longer values will persist in the specification but will be truncated to 15 symbols before being passed to VM configuration.
        :param 'GetComputeV1InstanceNetworkInterfacePublicIpAddressArgs' public_ip_address: Public IPv4 address associated with the interface.
               
               ### Inner value description
               
               Describes a public IP address.
        :param builtins.str subnet_id: Subnet ID
        """
        pulumi.set(__self__, "ip_address", ip_address)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "public_ip_address", public_ip_address)
        pulumi.set(__self__, "subnet_id", subnet_id)

    @property
    @pulumi.getter(name="ipAddress")
    def ip_address(self) -> 'outputs.GetComputeV1InstanceNetworkInterfaceIpAddressResult':
        """
        Private IPv4 address associated with the interface.

        ### Inner value description

        Describes an IPv4 address.
        """
        return pulumi.get(self, "ip_address")

    @property
    @pulumi.getter
    def name(self) -> builtins.str:
        """
        Interface name
        Value of this field configures the name of the network interface inside VM's OS.
        Longer values will persist in the specification but will be truncated to 15 symbols before being passed to VM configuration.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="publicIpAddress")
    def public_ip_address(self) -> 'outputs.GetComputeV1InstanceNetworkInterfacePublicIpAddressResult':
        """
        Public IPv4 address associated with the interface.

        ### Inner value description

        Describes a public IP address.
        """
        return pulumi.get(self, "public_ip_address")

    @property
    @pulumi.getter(name="subnetId")
    def subnet_id(self) -> builtins.str:
        """
        Subnet ID
        """
        return pulumi.get(self, "subnet_id")


@pulumi.output_type
class GetComputeV1InstanceNetworkInterfaceIpAddressResult(dict):
    def __init__(__self__, *,
                 allocation_id: builtins.str):
        """
        :param builtins.str allocation_id: Allocation identifier if it was created before.
        """
        pulumi.set(__self__, "allocation_id", allocation_id)

    @property
    @pulumi.getter(name="allocationId")
    def allocation_id(self) -> builtins.str:
        """
        Allocation identifier if it was created before.
        """
        return pulumi.get(self, "allocation_id")


@pulumi.output_type
class GetComputeV1InstanceNetworkInterfacePublicIpAddressResult(dict):
    def __init__(__self__, *,
                 allocation_id: builtins.str,
                 static: builtins.bool):
        """
        :param builtins.str allocation_id: Allocation identifier if it was created before.
        :param builtins.bool static: If false - Allocation will be created/deleted during NetworkInterface.Allocate/NetworkInterface.Deallocate
               If true  - Allocation will be created/deleted during NetworkInterface.Create/NetworkInterface.Delete
               False by default
        """
        pulumi.set(__self__, "allocation_id", allocation_id)
        pulumi.set(__self__, "static", static)

    @property
    @pulumi.getter(name="allocationId")
    def allocation_id(self) -> builtins.str:
        """
        Allocation identifier if it was created before.
        """
        return pulumi.get(self, "allocation_id")

    @property
    @pulumi.getter
    def static(self) -> builtins.bool:
        """
        If false - Allocation will be created/deleted during NetworkInterface.Allocate/NetworkInterface.Deallocate
        If true  - Allocation will be created/deleted during NetworkInterface.Create/NetworkInterface.Delete
        False by default
        """
        return pulumi.get(self, "static")


@pulumi.output_type
class GetComputeV1InstanceResourcesResult(dict):
    def __init__(__self__, *,
                 platform: builtins.str,
                 preset: builtins.str):
        pulumi.set(__self__, "platform", platform)
        pulumi.set(__self__, "preset", preset)

    @property
    @pulumi.getter
    def platform(self) -> builtins.str:
        return pulumi.get(self, "platform")

    @property
    @pulumi.getter
    def preset(self) -> builtins.str:
        return pulumi.get(self, "preset")


@pulumi.output_type
class GetComputeV1InstanceSecondaryDiskResult(dict):
    def __init__(__self__, *,
                 attach_mode: builtins.str,
                 device_id: builtins.str,
                 existing_disk: 'outputs.GetComputeV1InstanceSecondaryDiskExistingDiskResult'):
        """
        :param builtins.str attach_mode: ### Supported values
               
               Possible values:
               
                - `UNSPECIFIED`
                - `READ_ONLY`
                - `READ_WRITE`
        :param builtins.str device_id: Specifies the user-defined identifier, allowing to use '/dev/disk/by-id/virtio-{device_id}' as a device path in mount command.
        """
        pulumi.set(__self__, "attach_mode", attach_mode)
        pulumi.set(__self__, "device_id", device_id)
        pulumi.set(__self__, "existing_disk", existing_disk)

    @property
    @pulumi.getter(name="attachMode")
    def attach_mode(self) -> builtins.str:
        """
        ### Supported values

        Possible values:

         - `UNSPECIFIED`
         - `READ_ONLY`
         - `READ_WRITE`
        """
        return pulumi.get(self, "attach_mode")

    @property
    @pulumi.getter(name="deviceId")
    def device_id(self) -> builtins.str:
        """
        Specifies the user-defined identifier, allowing to use '/dev/disk/by-id/virtio-{device_id}' as a device path in mount command.
        """
        return pulumi.get(self, "device_id")

    @property
    @pulumi.getter(name="existingDisk")
    def existing_disk(self) -> 'outputs.GetComputeV1InstanceSecondaryDiskExistingDiskResult':
        return pulumi.get(self, "existing_disk")


@pulumi.output_type
class GetComputeV1InstanceSecondaryDiskExistingDiskResult(dict):
    def __init__(__self__, *,
                 id: builtins.str):
        pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> builtins.str:
        return pulumi.get(self, "id")


@pulumi.output_type
class GetComputeV1InstanceStatusResult(dict):
    def __init__(__self__, *,
                 infiniband_topology_path: 'outputs.GetComputeV1InstanceStatusInfinibandTopologyPathResult',
                 maintenance_event_id: builtins.str,
                 network_interfaces: Sequence['outputs.GetComputeV1InstanceStatusNetworkInterfaceResult'],
                 reconciling: builtins.bool,
                 state: builtins.str):
        """
        :param Sequence['GetComputeV1InstanceStatusNetworkInterfaceArgs'] network_interfaces: ### Inner value description
               
               Describes the status of a network interface.
        :param builtins.bool reconciling: Indicates whether there is an ongoing operation
        :param builtins.str state: ### Supported values
               
               Possible values:
               
                - `UNSPECIFIED`
                - `CREATING`
                - `UPDATING`
                - `STARTING`
                - `RUNNING`
                - `STOPPING`
                - `STOPPED`
                - `DELETING`
                - `ERROR`
        """
        pulumi.set(__self__, "infiniband_topology_path", infiniband_topology_path)
        pulumi.set(__self__, "maintenance_event_id", maintenance_event_id)
        pulumi.set(__self__, "network_interfaces", network_interfaces)
        pulumi.set(__self__, "reconciling", reconciling)
        pulumi.set(__self__, "state", state)

    @property
    @pulumi.getter(name="infinibandTopologyPath")
    def infiniband_topology_path(self) -> 'outputs.GetComputeV1InstanceStatusInfinibandTopologyPathResult':
        return pulumi.get(self, "infiniband_topology_path")

    @property
    @pulumi.getter(name="maintenanceEventId")
    def maintenance_event_id(self) -> builtins.str:
        return pulumi.get(self, "maintenance_event_id")

    @property
    @pulumi.getter(name="networkInterfaces")
    def network_interfaces(self) -> Sequence['outputs.GetComputeV1InstanceStatusNetworkInterfaceResult']:
        """
        ### Inner value description

        Describes the status of a network interface.
        """
        return pulumi.get(self, "network_interfaces")

    @property
    @pulumi.getter
    def reconciling(self) -> builtins.bool:
        """
        Indicates whether there is an ongoing operation
        """
        return pulumi.get(self, "reconciling")

    @property
    @pulumi.getter
    def state(self) -> builtins.str:
        """
        ### Supported values

        Possible values:

         - `UNSPECIFIED`
         - `CREATING`
         - `UPDATING`
         - `STARTING`
         - `RUNNING`
         - `STOPPING`
         - `STOPPED`
         - `DELETING`
         - `ERROR`
        """
        return pulumi.get(self, "state")


@pulumi.output_type
class GetComputeV1InstanceStatusInfinibandTopologyPathResult(dict):
    def __init__(__self__, *,
                 paths: Sequence[builtins.str]):
        pulumi.set(__self__, "paths", paths)

    @property
    @pulumi.getter
    def paths(self) -> Sequence[builtins.str]:
        return pulumi.get(self, "paths")


@pulumi.output_type
class GetComputeV1InstanceStatusNetworkInterfaceResult(dict):
    def __init__(__self__, *,
                 index: builtins.float,
                 ip_address: 'outputs.GetComputeV1InstanceStatusNetworkInterfaceIpAddressResult',
                 mac_address: builtins.str,
                 name: builtins.str,
                 public_ip_address: 'outputs.GetComputeV1InstanceStatusNetworkInterfacePublicIpAddressResult'):
        """
        :param builtins.float index: The index of the network interface
        :param 'GetComputeV1InstanceStatusNetworkInterfaceIpAddressArgs' ip_address: Effective Private IPv4 address
        :param builtins.str mac_address: MAC address
        :param builtins.str name: Name for interface.
               Unique within instance's network interfaces
        :param 'GetComputeV1InstanceStatusNetworkInterfacePublicIpAddressArgs' public_ip_address: Effective Public IPv4 address
        """
        pulumi.set(__self__, "index", index)
        pulumi.set(__self__, "ip_address", ip_address)
        pulumi.set(__self__, "mac_address", mac_address)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "public_ip_address", public_ip_address)

    @property
    @pulumi.getter
    def index(self) -> builtins.float:
        """
        The index of the network interface
        """
        return pulumi.get(self, "index")

    @property
    @pulumi.getter(name="ipAddress")
    def ip_address(self) -> 'outputs.GetComputeV1InstanceStatusNetworkInterfaceIpAddressResult':
        """
        Effective Private IPv4 address
        """
        return pulumi.get(self, "ip_address")

    @property
    @pulumi.getter(name="macAddress")
    def mac_address(self) -> builtins.str:
        """
        MAC address
        """
        return pulumi.get(self, "mac_address")

    @property
    @pulumi.getter
    def name(self) -> builtins.str:
        """
        Name for interface.
        Unique within instance's network interfaces
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="publicIpAddress")
    def public_ip_address(self) -> 'outputs.GetComputeV1InstanceStatusNetworkInterfacePublicIpAddressResult':
        """
        Effective Public IPv4 address
        """
        return pulumi.get(self, "public_ip_address")


@pulumi.output_type
class GetComputeV1InstanceStatusNetworkInterfaceIpAddressResult(dict):
    def __init__(__self__, *,
                 address: builtins.str,
                 allocation_id: builtins.str):
        """
        :param builtins.str address: Effective private IPv4 address assigned to the interface.
        :param builtins.str allocation_id: Allocation identifier.
        """
        pulumi.set(__self__, "address", address)
        pulumi.set(__self__, "allocation_id", allocation_id)

    @property
    @pulumi.getter
    def address(self) -> builtins.str:
        """
        Effective private IPv4 address assigned to the interface.
        """
        return pulumi.get(self, "address")

    @property
    @pulumi.getter(name="allocationId")
    def allocation_id(self) -> builtins.str:
        """
        Allocation identifier.
        """
        return pulumi.get(self, "allocation_id")


@pulumi.output_type
class GetComputeV1InstanceStatusNetworkInterfacePublicIpAddressResult(dict):
    def __init__(__self__, *,
                 address: builtins.str,
                 allocation_id: builtins.str,
                 static: builtins.bool):
        """
        :param builtins.str address: Effective public IPv4 address assigned to the interface.
        :param builtins.str allocation_id: Allocation identifier.
        :param builtins.bool static: If false - Allocation will be created/deleted during NetworkInterface.Allocate/NetworkInterface.Deallocate
               If true  - Allocation will be created/deleted during NetworkInterface.Create/NetworkInterface.Delete
               False by default
        """
        pulumi.set(__self__, "address", address)
        pulumi.set(__self__, "allocation_id", allocation_id)
        pulumi.set(__self__, "static", static)

    @property
    @pulumi.getter
    def address(self) -> builtins.str:
        """
        Effective public IPv4 address assigned to the interface.
        """
        return pulumi.get(self, "address")

    @property
    @pulumi.getter(name="allocationId")
    def allocation_id(self) -> builtins.str:
        """
        Allocation identifier.
        """
        return pulumi.get(self, "allocation_id")

    @property
    @pulumi.getter
    def static(self) -> builtins.bool:
        """
        If false - Allocation will be created/deleted during NetworkInterface.Allocate/NetworkInterface.Deallocate
        If true  - Allocation will be created/deleted during NetworkInterface.Create/NetworkInterface.Delete
        False by default
        """
        return pulumi.get(self, "static")


@pulumi.output_type
class GetComputeV1alpha1DiskMetadataResult(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class GetComputeV1alpha1DiskPlacementPolicyResult(dict):
    def __init__(__self__, *,
                 placement_group_id: builtins.str,
                 placement_group_partition: builtins.float):
        pulumi.set(__self__, "placement_group_id", placement_group_id)
        pulumi.set(__self__, "placement_group_partition", placement_group_partition)

    @property
    @pulumi.getter(name="placementGroupId")
    def placement_group_id(self) -> builtins.str:
        return pulumi.get(self, "placement_group_id")

    @property
    @pulumi.getter(name="placementGroupPartition")
    def placement_group_partition(self) -> builtins.float:
        return pulumi.get(self, "placement_group_partition")


@pulumi.output_type
class GetComputeV1alpha1DiskStatusResult(dict):
    def __init__(__self__, *,
                 read_only_attachments: Sequence[builtins.str],
                 read_write_attachment: builtins.str,
                 reconciling: builtins.bool,
                 size_bytes: builtins.float,
                 source_image_id: builtins.str,
                 state: builtins.str,
                 state_description: builtins.str):
        """
        :param builtins.bool reconciling: Indicates whether there is an ongoing operation
        :param builtins.str state: ### Supported values
               
               Possible values:
               
                - `UNSPECIFIED`
                - `CREATING`
                - `READY`
                - `UPDATING`
                - `DELETING`
                - `ERROR`
        """
        pulumi.set(__self__, "read_only_attachments", read_only_attachments)
        pulumi.set(__self__, "read_write_attachment", read_write_attachment)
        pulumi.set(__self__, "reconciling", reconciling)
        pulumi.set(__self__, "size_bytes", size_bytes)
        pulumi.set(__self__, "source_image_id", source_image_id)
        pulumi.set(__self__, "state", state)
        pulumi.set(__self__, "state_description", state_description)

    @property
    @pulumi.getter(name="readOnlyAttachments")
    def read_only_attachments(self) -> Sequence[builtins.str]:
        return pulumi.get(self, "read_only_attachments")

    @property
    @pulumi.getter(name="readWriteAttachment")
    def read_write_attachment(self) -> builtins.str:
        return pulumi.get(self, "read_write_attachment")

    @property
    @pulumi.getter
    def reconciling(self) -> builtins.bool:
        """
        Indicates whether there is an ongoing operation
        """
        return pulumi.get(self, "reconciling")

    @property
    @pulumi.getter(name="sizeBytes")
    def size_bytes(self) -> builtins.float:
        return pulumi.get(self, "size_bytes")

    @property
    @pulumi.getter(name="sourceImageId")
    def source_image_id(self) -> builtins.str:
        return pulumi.get(self, "source_image_id")

    @property
    @pulumi.getter
    def state(self) -> builtins.str:
        """
        ### Supported values

        Possible values:

         - `UNSPECIFIED`
         - `CREATING`
         - `READY`
         - `UPDATING`
         - `DELETING`
         - `ERROR`
        """
        return pulumi.get(self, "state")

    @property
    @pulumi.getter(name="stateDescription")
    def state_description(self) -> builtins.str:
        return pulumi.get(self, "state_description")


@pulumi.output_type
class GetComputeV1alpha1FilesystemMetadataResult(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class GetComputeV1alpha1FilesystemStatusResult(dict):
    def __init__(__self__, *,
                 read_only_attachments: Sequence[builtins.str],
                 read_write_attachments: Sequence[builtins.str],
                 reconciling: builtins.bool,
                 size_bytes: builtins.float,
                 state: builtins.str,
                 state_description: builtins.str):
        """
        :param builtins.bool reconciling: Indicates whether there is an ongoing operation
        :param builtins.str state: ### Supported values
               
               Possible values:
               
                - `UNSPECIFIED`
                - `CREATING`
                - `READY`
                - `UPDATING`
                - `DELETING`
                - `ERROR`
        """
        pulumi.set(__self__, "read_only_attachments", read_only_attachments)
        pulumi.set(__self__, "read_write_attachments", read_write_attachments)
        pulumi.set(__self__, "reconciling", reconciling)
        pulumi.set(__self__, "size_bytes", size_bytes)
        pulumi.set(__self__, "state", state)
        pulumi.set(__self__, "state_description", state_description)

    @property
    @pulumi.getter(name="readOnlyAttachments")
    def read_only_attachments(self) -> Sequence[builtins.str]:
        return pulumi.get(self, "read_only_attachments")

    @property
    @pulumi.getter(name="readWriteAttachments")
    def read_write_attachments(self) -> Sequence[builtins.str]:
        return pulumi.get(self, "read_write_attachments")

    @property
    @pulumi.getter
    def reconciling(self) -> builtins.bool:
        """
        Indicates whether there is an ongoing operation
        """
        return pulumi.get(self, "reconciling")

    @property
    @pulumi.getter(name="sizeBytes")
    def size_bytes(self) -> builtins.float:
        return pulumi.get(self, "size_bytes")

    @property
    @pulumi.getter
    def state(self) -> builtins.str:
        """
        ### Supported values

        Possible values:

         - `UNSPECIFIED`
         - `CREATING`
         - `READY`
         - `UPDATING`
         - `DELETING`
         - `ERROR`
        """
        return pulumi.get(self, "state")

    @property
    @pulumi.getter(name="stateDescription")
    def state_description(self) -> builtins.str:
        return pulumi.get(self, "state_description")


@pulumi.output_type
class GetComputeV1alpha1GpuClusterMetadataResult(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class GetComputeV1alpha1GpuClusterStatusResult(dict):
    def __init__(__self__, *,
                 instances: Sequence[builtins.str],
                 reconciling: builtins.bool):
        """
        :param builtins.bool reconciling: Indicates whether there is an ongoing operation
        """
        pulumi.set(__self__, "instances", instances)
        pulumi.set(__self__, "reconciling", reconciling)

    @property
    @pulumi.getter
    def instances(self) -> Sequence[builtins.str]:
        return pulumi.get(self, "instances")

    @property
    @pulumi.getter
    def reconciling(self) -> builtins.bool:
        """
        Indicates whether there is an ongoing operation
        """
        return pulumi.get(self, "reconciling")


@pulumi.output_type
class GetComputeV1alpha1ImageMetadataResult(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class GetComputeV1alpha1ImageStatusResult(dict):
    def __init__(__self__, *,
                 min_disk_size_bytes: builtins.float,
                 reconciling: builtins.bool,
                 state: builtins.str,
                 state_description: builtins.str,
                 storage_size_bytes: builtins.float):
        """
        :param builtins.bool reconciling: Indicates whether there is an ongoing operation
        :param builtins.str state: ### Supported values
               
               Possible values:
               
                - `UNSPECIFIED`
                - `CREATING`
                - `READY`
                - `UPDATING`
                - `DELETING`
                - `ERROR`
        """
        pulumi.set(__self__, "min_disk_size_bytes", min_disk_size_bytes)
        pulumi.set(__self__, "reconciling", reconciling)
        pulumi.set(__self__, "state", state)
        pulumi.set(__self__, "state_description", state_description)
        pulumi.set(__self__, "storage_size_bytes", storage_size_bytes)

    @property
    @pulumi.getter(name="minDiskSizeBytes")
    def min_disk_size_bytes(self) -> builtins.float:
        return pulumi.get(self, "min_disk_size_bytes")

    @property
    @pulumi.getter
    def reconciling(self) -> builtins.bool:
        """
        Indicates whether there is an ongoing operation
        """
        return pulumi.get(self, "reconciling")

    @property
    @pulumi.getter
    def state(self) -> builtins.str:
        """
        ### Supported values

        Possible values:

         - `UNSPECIFIED`
         - `CREATING`
         - `READY`
         - `UPDATING`
         - `DELETING`
         - `ERROR`
        """
        return pulumi.get(self, "state")

    @property
    @pulumi.getter(name="stateDescription")
    def state_description(self) -> builtins.str:
        return pulumi.get(self, "state_description")

    @property
    @pulumi.getter(name="storageSizeBytes")
    def storage_size_bytes(self) -> builtins.float:
        return pulumi.get(self, "storage_size_bytes")


@pulumi.output_type
class GetComputeV1alpha1InstanceBootDiskResult(dict):
    def __init__(__self__, *,
                 attach_mode: builtins.str,
                 device_name: builtins.str,
                 existing_disk: 'outputs.GetComputeV1alpha1InstanceBootDiskExistingDiskResult'):
        """
        :param builtins.str attach_mode: ### Supported values
               
               Possible values:
               
                - `UNSPECIFIED`
                - `READ_ONLY`
                - `READ_WRITE`
        :param builtins.str device_name: Specifies the user-defined identifier, allowing to use '/dev/disk/by-id/virtio-{device_name}' as a device path in mount command.
        """
        pulumi.set(__self__, "attach_mode", attach_mode)
        pulumi.set(__self__, "device_name", device_name)
        pulumi.set(__self__, "existing_disk", existing_disk)

    @property
    @pulumi.getter(name="attachMode")
    def attach_mode(self) -> builtins.str:
        """
        ### Supported values

        Possible values:

         - `UNSPECIFIED`
         - `READ_ONLY`
         - `READ_WRITE`
        """
        return pulumi.get(self, "attach_mode")

    @property
    @pulumi.getter(name="deviceName")
    def device_name(self) -> builtins.str:
        """
        Specifies the user-defined identifier, allowing to use '/dev/disk/by-id/virtio-{device_name}' as a device path in mount command.
        """
        return pulumi.get(self, "device_name")

    @property
    @pulumi.getter(name="existingDisk")
    def existing_disk(self) -> 'outputs.GetComputeV1alpha1InstanceBootDiskExistingDiskResult':
        return pulumi.get(self, "existing_disk")


@pulumi.output_type
class GetComputeV1alpha1InstanceBootDiskExistingDiskResult(dict):
    def __init__(__self__, *,
                 id: builtins.str):
        pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> builtins.str:
        return pulumi.get(self, "id")


@pulumi.output_type
class GetComputeV1alpha1InstanceFilesystemResult(dict):
    def __init__(__self__, *,
                 attach_mode: builtins.str,
                 device_name: builtins.str,
                 existing_filesystem: 'outputs.GetComputeV1alpha1InstanceFilesystemExistingFilesystemResult'):
        """
        :param builtins.str attach_mode: ### Supported values
               
               Possible values:
               
                - `UNSPECIFIED`
                - `READ_ONLY`
                - `READ_WRITE`
        :param builtins.str device_name: Specifies the user-defined identifier, allowing to use it as a device in mount command.
        """
        pulumi.set(__self__, "attach_mode", attach_mode)
        pulumi.set(__self__, "device_name", device_name)
        pulumi.set(__self__, "existing_filesystem", existing_filesystem)

    @property
    @pulumi.getter(name="attachMode")
    def attach_mode(self) -> builtins.str:
        """
        ### Supported values

        Possible values:

         - `UNSPECIFIED`
         - `READ_ONLY`
         - `READ_WRITE`
        """
        return pulumi.get(self, "attach_mode")

    @property
    @pulumi.getter(name="deviceName")
    def device_name(self) -> builtins.str:
        """
        Specifies the user-defined identifier, allowing to use it as a device in mount command.
        """
        return pulumi.get(self, "device_name")

    @property
    @pulumi.getter(name="existingFilesystem")
    def existing_filesystem(self) -> 'outputs.GetComputeV1alpha1InstanceFilesystemExistingFilesystemResult':
        return pulumi.get(self, "existing_filesystem")


@pulumi.output_type
class GetComputeV1alpha1InstanceFilesystemExistingFilesystemResult(dict):
    def __init__(__self__, *,
                 id: builtins.str):
        pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> builtins.str:
        return pulumi.get(self, "id")


@pulumi.output_type
class GetComputeV1alpha1InstanceGpuClusterResult(dict):
    def __init__(__self__, *,
                 id: builtins.str):
        pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> builtins.str:
        return pulumi.get(self, "id")


@pulumi.output_type
class GetComputeV1alpha1InstanceMetadataResult(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class GetComputeV1alpha1InstanceNetworkInterfaceResult(dict):
    def __init__(__self__, *,
                 ip_address: 'outputs.GetComputeV1alpha1InstanceNetworkInterfaceIpAddressResult',
                 name: builtins.str,
                 public_ip_address: 'outputs.GetComputeV1alpha1InstanceNetworkInterfacePublicIpAddressResult',
                 subnet_id: builtins.str):
        """
        :param 'GetComputeV1alpha1InstanceNetworkInterfaceIpAddressArgs' ip_address: Private IPv4 address associated with the interface.
               
               ### Inner value description
               
               Describes an IPv4 address.
        :param builtins.str name: Interface name
               Value of this field configures the name of the network interface inside VM's OS.
               Longer values will persist in the specification but will be truncated to 15 symbols before being passed to VM configuration.
        :param 'GetComputeV1alpha1InstanceNetworkInterfacePublicIpAddressArgs' public_ip_address: Public IPv4 address associated with the interface.
               
               ### Inner value description
               
               Describes a public IP address.
        :param builtins.str subnet_id: Subnet ID
        """
        pulumi.set(__self__, "ip_address", ip_address)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "public_ip_address", public_ip_address)
        pulumi.set(__self__, "subnet_id", subnet_id)

    @property
    @pulumi.getter(name="ipAddress")
    def ip_address(self) -> 'outputs.GetComputeV1alpha1InstanceNetworkInterfaceIpAddressResult':
        """
        Private IPv4 address associated with the interface.

        ### Inner value description

        Describes an IPv4 address.
        """
        return pulumi.get(self, "ip_address")

    @property
    @pulumi.getter
    def name(self) -> builtins.str:
        """
        Interface name
        Value of this field configures the name of the network interface inside VM's OS.
        Longer values will persist in the specification but will be truncated to 15 symbols before being passed to VM configuration.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="publicIpAddress")
    def public_ip_address(self) -> 'outputs.GetComputeV1alpha1InstanceNetworkInterfacePublicIpAddressResult':
        """
        Public IPv4 address associated with the interface.

        ### Inner value description

        Describes a public IP address.
        """
        return pulumi.get(self, "public_ip_address")

    @property
    @pulumi.getter(name="subnetId")
    def subnet_id(self) -> builtins.str:
        """
        Subnet ID
        """
        return pulumi.get(self, "subnet_id")


@pulumi.output_type
class GetComputeV1alpha1InstanceNetworkInterfaceIpAddressResult(dict):
    def __init__(__self__, *,
                 allocation_id: builtins.str):
        """
        :param builtins.str allocation_id: Allocation identifier if it was created before.
        """
        pulumi.set(__self__, "allocation_id", allocation_id)

    @property
    @pulumi.getter(name="allocationId")
    def allocation_id(self) -> builtins.str:
        """
        Allocation identifier if it was created before.
        """
        return pulumi.get(self, "allocation_id")


@pulumi.output_type
class GetComputeV1alpha1InstanceNetworkInterfacePublicIpAddressResult(dict):
    def __init__(__self__, *,
                 allocation_id: builtins.str,
                 static: builtins.bool):
        """
        :param builtins.str allocation_id: Allocation identifier if it was created before.
        :param builtins.bool static: If false - Lifecycle of allocation depends on NetworkInterface.Allocate/NetworkInterface.Deallocate
               If true  - Lifecycle of allocation depends on NetworkInterface.Create/NetworkInterface.Delete
               False by default
        """
        pulumi.set(__self__, "allocation_id", allocation_id)
        pulumi.set(__self__, "static", static)

    @property
    @pulumi.getter(name="allocationId")
    def allocation_id(self) -> builtins.str:
        """
        Allocation identifier if it was created before.
        """
        return pulumi.get(self, "allocation_id")

    @property
    @pulumi.getter
    def static(self) -> builtins.bool:
        """
        If false - Lifecycle of allocation depends on NetworkInterface.Allocate/NetworkInterface.Deallocate
        If true  - Lifecycle of allocation depends on NetworkInterface.Create/NetworkInterface.Delete
        False by default
        """
        return pulumi.get(self, "static")


@pulumi.output_type
class GetComputeV1alpha1InstanceResourcesResult(dict):
    def __init__(__self__, *,
                 platform: builtins.str,
                 preset: builtins.str):
        pulumi.set(__self__, "platform", platform)
        pulumi.set(__self__, "preset", preset)

    @property
    @pulumi.getter
    def platform(self) -> builtins.str:
        return pulumi.get(self, "platform")

    @property
    @pulumi.getter
    def preset(self) -> builtins.str:
        return pulumi.get(self, "preset")


@pulumi.output_type
class GetComputeV1alpha1InstanceSecondaryDiskResult(dict):
    def __init__(__self__, *,
                 attach_mode: builtins.str,
                 device_name: builtins.str,
                 existing_disk: 'outputs.GetComputeV1alpha1InstanceSecondaryDiskExistingDiskResult'):
        """
        :param builtins.str attach_mode: ### Supported values
               
               Possible values:
               
                - `UNSPECIFIED`
                - `READ_ONLY`
                - `READ_WRITE`
        :param builtins.str device_name: Specifies the user-defined identifier, allowing to use '/dev/disk/by-id/virtio-{device_name}' as a device path in mount command.
        """
        pulumi.set(__self__, "attach_mode", attach_mode)
        pulumi.set(__self__, "device_name", device_name)
        pulumi.set(__self__, "existing_disk", existing_disk)

    @property
    @pulumi.getter(name="attachMode")
    def attach_mode(self) -> builtins.str:
        """
        ### Supported values

        Possible values:

         - `UNSPECIFIED`
         - `READ_ONLY`
         - `READ_WRITE`
        """
        return pulumi.get(self, "attach_mode")

    @property
    @pulumi.getter(name="deviceName")
    def device_name(self) -> builtins.str:
        """
        Specifies the user-defined identifier, allowing to use '/dev/disk/by-id/virtio-{device_name}' as a device path in mount command.
        """
        return pulumi.get(self, "device_name")

    @property
    @pulumi.getter(name="existingDisk")
    def existing_disk(self) -> 'outputs.GetComputeV1alpha1InstanceSecondaryDiskExistingDiskResult':
        return pulumi.get(self, "existing_disk")


@pulumi.output_type
class GetComputeV1alpha1InstanceSecondaryDiskExistingDiskResult(dict):
    def __init__(__self__, *,
                 id: builtins.str):
        pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> builtins.str:
        return pulumi.get(self, "id")


@pulumi.output_type
class GetComputeV1alpha1InstanceStatusResult(dict):
    def __init__(__self__, *,
                 network_interfaces: Sequence['outputs.GetComputeV1alpha1InstanceStatusNetworkInterfaceResult'],
                 reconciling: builtins.bool,
                 state: builtins.str):
        """
        :param Sequence['GetComputeV1alpha1InstanceStatusNetworkInterfaceArgs'] network_interfaces: ### Inner value description
               
               Describes the status of a network interface.
        :param builtins.bool reconciling: Indicates whether there is an ongoing operation
        :param builtins.str state: ### Supported values
               
               Possible values:
               
                - `UNSPECIFIED`
                - `CREATING`
                - `UPDATING`
                - `STARTING`
                - `RUNNING`
                - `STOPPING`
                - `STOPPED`
                - `DELETING`
                - `ERROR`
        """
        pulumi.set(__self__, "network_interfaces", network_interfaces)
        pulumi.set(__self__, "reconciling", reconciling)
        pulumi.set(__self__, "state", state)

    @property
    @pulumi.getter(name="networkInterfaces")
    def network_interfaces(self) -> Sequence['outputs.GetComputeV1alpha1InstanceStatusNetworkInterfaceResult']:
        """
        ### Inner value description

        Describes the status of a network interface.
        """
        return pulumi.get(self, "network_interfaces")

    @property
    @pulumi.getter
    def reconciling(self) -> builtins.bool:
        """
        Indicates whether there is an ongoing operation
        """
        return pulumi.get(self, "reconciling")

    @property
    @pulumi.getter
    def state(self) -> builtins.str:
        """
        ### Supported values

        Possible values:

         - `UNSPECIFIED`
         - `CREATING`
         - `UPDATING`
         - `STARTING`
         - `RUNNING`
         - `STOPPING`
         - `STOPPED`
         - `DELETING`
         - `ERROR`
        """
        return pulumi.get(self, "state")


@pulumi.output_type
class GetComputeV1alpha1InstanceStatusNetworkInterfaceResult(dict):
    def __init__(__self__, *,
                 index: builtins.float,
                 ip_address: 'outputs.GetComputeV1alpha1InstanceStatusNetworkInterfaceIpAddressResult',
                 mac_address: builtins.str,
                 name: builtins.str,
                 public_ip_address: 'outputs.GetComputeV1alpha1InstanceStatusNetworkInterfacePublicIpAddressResult'):
        """
        :param builtins.float index: The index of the network interface
        :param 'GetComputeV1alpha1InstanceStatusNetworkInterfaceIpAddressArgs' ip_address: Effective Private IPv4 address
        :param builtins.str mac_address: MAC address
        :param builtins.str name: Name for interface.
               Unique within instance's network interfaces
        :param 'GetComputeV1alpha1InstanceStatusNetworkInterfacePublicIpAddressArgs' public_ip_address: Effective Public IPv4 address
        """
        pulumi.set(__self__, "index", index)
        pulumi.set(__self__, "ip_address", ip_address)
        pulumi.set(__self__, "mac_address", mac_address)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "public_ip_address", public_ip_address)

    @property
    @pulumi.getter
    def index(self) -> builtins.float:
        """
        The index of the network interface
        """
        return pulumi.get(self, "index")

    @property
    @pulumi.getter(name="ipAddress")
    def ip_address(self) -> 'outputs.GetComputeV1alpha1InstanceStatusNetworkInterfaceIpAddressResult':
        """
        Effective Private IPv4 address
        """
        return pulumi.get(self, "ip_address")

    @property
    @pulumi.getter(name="macAddress")
    def mac_address(self) -> builtins.str:
        """
        MAC address
        """
        return pulumi.get(self, "mac_address")

    @property
    @pulumi.getter
    def name(self) -> builtins.str:
        """
        Name for interface.
        Unique within instance's network interfaces
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="publicIpAddress")
    def public_ip_address(self) -> 'outputs.GetComputeV1alpha1InstanceStatusNetworkInterfacePublicIpAddressResult':
        """
        Effective Public IPv4 address
        """
        return pulumi.get(self, "public_ip_address")


@pulumi.output_type
class GetComputeV1alpha1InstanceStatusNetworkInterfaceIpAddressResult(dict):
    def __init__(__self__, *,
                 address: builtins.str,
                 allocation_id: builtins.str):
        """
        :param builtins.str address: Effective private IPv4 address assigned to the interface.
        :param builtins.str allocation_id: Allocation identifier.
        """
        pulumi.set(__self__, "address", address)
        pulumi.set(__self__, "allocation_id", allocation_id)

    @property
    @pulumi.getter
    def address(self) -> builtins.str:
        """
        Effective private IPv4 address assigned to the interface.
        """
        return pulumi.get(self, "address")

    @property
    @pulumi.getter(name="allocationId")
    def allocation_id(self) -> builtins.str:
        """
        Allocation identifier.
        """
        return pulumi.get(self, "allocation_id")


@pulumi.output_type
class GetComputeV1alpha1InstanceStatusNetworkInterfacePublicIpAddressResult(dict):
    def __init__(__self__, *,
                 address: builtins.str,
                 allocation_id: builtins.str):
        """
        :param builtins.str address: Effective public IPv4 address assigned to the interface.
        :param builtins.str allocation_id: Allocation identifier.
        """
        pulumi.set(__self__, "address", address)
        pulumi.set(__self__, "allocation_id", allocation_id)

    @property
    @pulumi.getter
    def address(self) -> builtins.str:
        """
        Effective public IPv4 address assigned to the interface.
        """
        return pulumi.get(self, "address")

    @property
    @pulumi.getter(name="allocationId")
    def allocation_id(self) -> builtins.str:
        """
        Allocation identifier.
        """
        return pulumi.get(self, "allocation_id")


@pulumi.output_type
class GetIamV1AccessPermitMetadataResult(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class GetIamV1AccessPermitStatusResult(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class GetIamV1AuthPublicKeyAccountResult(dict):
    def __init__(__self__, *,
                 anonymous_account: 'outputs.GetIamV1AuthPublicKeyAccountAnonymousAccountResult',
                 service_account: 'outputs.GetIamV1AuthPublicKeyAccountServiceAccountResult',
                 user_account: 'outputs.GetIamV1AuthPublicKeyAccountUserAccountResult'):
        """
        :param 'GetIamV1AuthPublicKeyAccountAnonymousAccountArgs' anonymous_account: *Cannot be set alongside  or service_account.*
        :param 'GetIamV1AuthPublicKeyAccountServiceAccountArgs' service_account: *Cannot be set alongside  or anonymous_account.*
        :param 'GetIamV1AuthPublicKeyAccountUserAccountArgs' user_account: *Cannot be set alongside  or anonymous_account.*
        """
        pulumi.set(__self__, "anonymous_account", anonymous_account)
        pulumi.set(__self__, "service_account", service_account)
        pulumi.set(__self__, "user_account", user_account)

    @property
    @pulumi.getter(name="anonymousAccount")
    def anonymous_account(self) -> 'outputs.GetIamV1AuthPublicKeyAccountAnonymousAccountResult':
        """
        *Cannot be set alongside  or service_account.*
        """
        return pulumi.get(self, "anonymous_account")

    @property
    @pulumi.getter(name="serviceAccount")
    def service_account(self) -> 'outputs.GetIamV1AuthPublicKeyAccountServiceAccountResult':
        """
        *Cannot be set alongside  or anonymous_account.*
        """
        return pulumi.get(self, "service_account")

    @property
    @pulumi.getter(name="userAccount")
    def user_account(self) -> 'outputs.GetIamV1AuthPublicKeyAccountUserAccountResult':
        """
        *Cannot be set alongside  or anonymous_account.*
        """
        return pulumi.get(self, "user_account")


@pulumi.output_type
class GetIamV1AuthPublicKeyAccountAnonymousAccountResult(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class GetIamV1AuthPublicKeyAccountServiceAccountResult(dict):
    def __init__(__self__, *,
                 id: builtins.str):
        pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> builtins.str:
        return pulumi.get(self, "id")


@pulumi.output_type
class GetIamV1AuthPublicKeyAccountUserAccountResult(dict):
    def __init__(__self__, *,
                 id: builtins.str):
        pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> builtins.str:
        return pulumi.get(self, "id")


@pulumi.output_type
class GetIamV1AuthPublicKeyMetadataResult(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class GetIamV1AuthPublicKeyStatusResult(dict):
    def __init__(__self__, *,
                 algorithm: builtins.str,
                 fingerprint: builtins.str,
                 key_size: builtins.float,
                 state: builtins.str):
        """
        :param builtins.str state: ### Supported values
               
               Possible values:
               
                - `STATE_UNSPECIFIED`
                - `ACTIVE`
                - `INACTIVE`
                - `EXPIRED`
                - `DELETING`
                - `DELETED`
        """
        pulumi.set(__self__, "algorithm", algorithm)
        pulumi.set(__self__, "fingerprint", fingerprint)
        pulumi.set(__self__, "key_size", key_size)
        pulumi.set(__self__, "state", state)

    @property
    @pulumi.getter
    def algorithm(self) -> builtins.str:
        return pulumi.get(self, "algorithm")

    @property
    @pulumi.getter
    def fingerprint(self) -> builtins.str:
        return pulumi.get(self, "fingerprint")

    @property
    @pulumi.getter(name="keySize")
    def key_size(self) -> builtins.float:
        return pulumi.get(self, "key_size")

    @property
    @pulumi.getter
    def state(self) -> builtins.str:
        """
        ### Supported values

        Possible values:

         - `STATE_UNSPECIFIED`
         - `ACTIVE`
         - `INACTIVE`
         - `EXPIRED`
         - `DELETING`
         - `DELETED`
        """
        return pulumi.get(self, "state")


@pulumi.output_type
class GetIamV1FederatedCredentialsMetadataResult(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class GetIamV1FederatedCredentialsOidcProviderResult(dict):
    def __init__(__self__, *,
                 issuer_url: builtins.str,
                 jwk_set_json: builtins.str):
        """
        :param builtins.str issuer_url: *
               It's not required provider OIDC issuer should be real OIDC provider, but should expose OIDC configuration
               with "/.well-known/openid-configuration" endpoint. Configuration should contains the "jwks_uri" endpoint
               where the JSON Web Key Set (JWKS) can be found; this set contains public keys used to verify
               JSON Web Tokens (JWTs) issued by an identity provider.
        :param builtins.str jwk_set_json: *
               Literally json, which represents JWKS with public keys for JWT verification
        """
        pulumi.set(__self__, "issuer_url", issuer_url)
        pulumi.set(__self__, "jwk_set_json", jwk_set_json)

    @property
    @pulumi.getter(name="issuerUrl")
    def issuer_url(self) -> builtins.str:
        """
        *
        It's not required provider OIDC issuer should be real OIDC provider, but should expose OIDC configuration
        with "/.well-known/openid-configuration" endpoint. Configuration should contains the "jwks_uri" endpoint
        where the JSON Web Key Set (JWKS) can be found; this set contains public keys used to verify
        JSON Web Tokens (JWTs) issued by an identity provider.
        """
        return pulumi.get(self, "issuer_url")

    @property
    @pulumi.getter(name="jwkSetJson")
    def jwk_set_json(self) -> builtins.str:
        """
        *
        Literally json, which represents JWKS with public keys for JWT verification
        """
        return pulumi.get(self, "jwk_set_json")


@pulumi.output_type
class GetIamV1FederatedCredentialsStatusResult(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class GetIamV1FederationCertificateMetadataResult(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class GetIamV1FederationCertificateStatusResult(dict):
    def __init__(__self__, *,
                 algorithm: builtins.str,
                 key_size: builtins.float,
                 not_after: builtins.str,
                 not_before: builtins.str,
                 state: builtins.str):
        """
        :param builtins.str not_after: A string representing a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ` or `YYYY-MM-DDTHH:MM:SS.SSS±HH:MM`
        :param builtins.str not_before: A string representing a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ` or `YYYY-MM-DDTHH:MM:SS.SSS±HH:MM`
        :param builtins.str state: ### Supported values
               
               Possible values:
               
                - `STATE_UNSPECIFIED`
                - `ACTIVE`
                - `EXPIRED`
        """
        pulumi.set(__self__, "algorithm", algorithm)
        pulumi.set(__self__, "key_size", key_size)
        pulumi.set(__self__, "not_after", not_after)
        pulumi.set(__self__, "not_before", not_before)
        pulumi.set(__self__, "state", state)

    @property
    @pulumi.getter
    def algorithm(self) -> builtins.str:
        return pulumi.get(self, "algorithm")

    @property
    @pulumi.getter(name="keySize")
    def key_size(self) -> builtins.float:
        return pulumi.get(self, "key_size")

    @property
    @pulumi.getter(name="notAfter")
    def not_after(self) -> builtins.str:
        """
        A string representing a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ` or `YYYY-MM-DDTHH:MM:SS.SSS±HH:MM`
        """
        return pulumi.get(self, "not_after")

    @property
    @pulumi.getter(name="notBefore")
    def not_before(self) -> builtins.str:
        """
        A string representing a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ` or `YYYY-MM-DDTHH:MM:SS.SSS±HH:MM`
        """
        return pulumi.get(self, "not_before")

    @property
    @pulumi.getter
    def state(self) -> builtins.str:
        """
        ### Supported values

        Possible values:

         - `STATE_UNSPECIFIED`
         - `ACTIVE`
         - `EXPIRED`
        """
        return pulumi.get(self, "state")


@pulumi.output_type
class GetIamV1FederationMetadataResult(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class GetIamV1FederationSamlSettingsResult(dict):
    def __init__(__self__, *,
                 force_authn: builtins.bool,
                 idp_issuer: builtins.str,
                 sso_url: builtins.str):
        """
        :param builtins.bool force_authn: if "true", the identity provider MUST authenticate the presenter directly rather than rely on a previous security context.
        """
        pulumi.set(__self__, "force_authn", force_authn)
        pulumi.set(__self__, "idp_issuer", idp_issuer)
        pulumi.set(__self__, "sso_url", sso_url)

    @property
    @pulumi.getter(name="forceAuthn")
    def force_authn(self) -> builtins.bool:
        """
        if "true", the identity provider MUST authenticate the presenter directly rather than rely on a previous security context.
        """
        return pulumi.get(self, "force_authn")

    @property
    @pulumi.getter(name="idpIssuer")
    def idp_issuer(self) -> builtins.str:
        return pulumi.get(self, "idp_issuer")

    @property
    @pulumi.getter(name="ssoUrl")
    def sso_url(self) -> builtins.str:
        return pulumi.get(self, "sso_url")


@pulumi.output_type
class GetIamV1FederationStatusResult(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class GetIamV1GroupMembershipMetadataResult(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class GetIamV1GroupMembershipStatusResult(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class GetIamV1GroupMetadataResult(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class GetIamV1GroupStatusResult(dict):
    def __init__(__self__, *,
                 members_count: builtins.float,
                 service_accounts_count: builtins.float,
                 state: builtins.str,
                 tenant_user_accounts_count: builtins.float):
        """
        :param builtins.str state: ### Supported values
               
               Possible values:
               
                - `UNSPECIFIED`
                - `ACTIVE`
        """
        pulumi.set(__self__, "members_count", members_count)
        pulumi.set(__self__, "service_accounts_count", service_accounts_count)
        pulumi.set(__self__, "state", state)
        pulumi.set(__self__, "tenant_user_accounts_count", tenant_user_accounts_count)

    @property
    @pulumi.getter(name="membersCount")
    def members_count(self) -> builtins.float:
        return pulumi.get(self, "members_count")

    @property
    @pulumi.getter(name="serviceAccountsCount")
    def service_accounts_count(self) -> builtins.float:
        return pulumi.get(self, "service_accounts_count")

    @property
    @pulumi.getter
    def state(self) -> builtins.str:
        """
        ### Supported values

        Possible values:

         - `UNSPECIFIED`
         - `ACTIVE`
        """
        return pulumi.get(self, "state")

    @property
    @pulumi.getter(name="tenantUserAccountsCount")
    def tenant_user_accounts_count(self) -> builtins.float:
        return pulumi.get(self, "tenant_user_accounts_count")


@pulumi.output_type
class GetIamV1InvitationMetadataResult(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class GetIamV1InvitationStatusResult(dict):
    def __init__(__self__, *,
                 expires_at: builtins.str,
                 state: builtins.str,
                 tenant_user_account_id: builtins.str):
        """
        :param builtins.str expires_at: A string representing a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ` or `YYYY-MM-DDTHH:MM:SS.SSS±HH:MM`
        :param builtins.str state: ### Supported values
               
               Possible values:
               
                - `UNSPECIFIED`
                - `CREATING` - contacts data is not stored in pds yet. probably will GC it later
                - `CREATED` - notification is not sent yet
                - `PENDING` - notification is sent, we are waiting for the user to approve the notification
                - `EXPIRED` - notification is expired, accept is no longer possible
                - `ACCEPTED` - notification is accepted
        """
        pulumi.set(__self__, "expires_at", expires_at)
        pulumi.set(__self__, "state", state)
        pulumi.set(__self__, "tenant_user_account_id", tenant_user_account_id)

    @property
    @pulumi.getter(name="expiresAt")
    def expires_at(self) -> builtins.str:
        """
        A string representing a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ` or `YYYY-MM-DDTHH:MM:SS.SSS±HH:MM`
        """
        return pulumi.get(self, "expires_at")

    @property
    @pulumi.getter
    def state(self) -> builtins.str:
        """
        ### Supported values

        Possible values:

         - `UNSPECIFIED`
         - `CREATING` - contacts data is not stored in pds yet. probably will GC it later
         - `CREATED` - notification is not sent yet
         - `PENDING` - notification is sent, we are waiting for the user to approve the notification
         - `EXPIRED` - notification is expired, accept is no longer possible
         - `ACCEPTED` - notification is accepted
        """
        return pulumi.get(self, "state")

    @property
    @pulumi.getter(name="tenantUserAccountId")
    def tenant_user_account_id(self) -> builtins.str:
        return pulumi.get(self, "tenant_user_account_id")


@pulumi.output_type
class GetIamV1ProjectMetadataResult(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class GetIamV1ProjectStatusResult(dict):
    def __init__(__self__, *,
                 container_state: builtins.str,
                 region: builtins.str,
                 suspension_state: builtins.str):
        """
        :param builtins.str container_state: ### Supported values
               
               Possible values:
               
                - `STATE_UNSPECIFIED`
                - `ACTIVE`
                - `SCHEDULING_FOR_DELETION`
                - `SCHEDULED_FOR_DELETION`
                - `SCHEDULING_FOR_DELETION_BY_PARENT`
                - `SCHEDULED_FOR_DELETION_BY_PARENT`
                - `UNDELETING`
                - `PURGING`
                - `PURGED`
                - `CREATING` - DRAFT = 1000;
        :param builtins.str suspension_state: ### Supported values
               
               Possible values:
               
                - `SUSPENSION_STATE_UNSPECIFIED`
                - `NONE`
                - `SUSPENDING`
                - `SUSPENDED`
                - `RESUMING`
        """
        pulumi.set(__self__, "container_state", container_state)
        pulumi.set(__self__, "region", region)
        pulumi.set(__self__, "suspension_state", suspension_state)

    @property
    @pulumi.getter(name="containerState")
    def container_state(self) -> builtins.str:
        """
        ### Supported values

        Possible values:

         - `STATE_UNSPECIFIED`
         - `ACTIVE`
         - `SCHEDULING_FOR_DELETION`
         - `SCHEDULED_FOR_DELETION`
         - `SCHEDULING_FOR_DELETION_BY_PARENT`
         - `SCHEDULED_FOR_DELETION_BY_PARENT`
         - `UNDELETING`
         - `PURGING`
         - `PURGED`
         - `CREATING` - DRAFT = 1000;
        """
        return pulumi.get(self, "container_state")

    @property
    @pulumi.getter
    def region(self) -> builtins.str:
        return pulumi.get(self, "region")

    @property
    @pulumi.getter(name="suspensionState")
    def suspension_state(self) -> builtins.str:
        """
        ### Supported values

        Possible values:

         - `SUSPENSION_STATE_UNSPECIFIED`
         - `NONE`
         - `SUSPENDING`
         - `SUSPENDED`
         - `RESUMING`
        """
        return pulumi.get(self, "suspension_state")


@pulumi.output_type
class GetIamV1ServiceAccountMetadataResult(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class GetIamV1ServiceAccountStatusResult(dict):
    def __init__(__self__, *,
                 active: builtins.bool):
        pulumi.set(__self__, "active", active)

    @property
    @pulumi.getter
    def active(self) -> builtins.bool:
        return pulumi.get(self, "active")


@pulumi.output_type
class GetIamV1TenantMetadataResult(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class GetIamV1TenantStatusResult(dict):
    def __init__(__self__, *,
                 container_state: builtins.str,
                 region: builtins.str,
                 suspension_state: builtins.str):
        """
        :param builtins.str container_state: ### Supported values
               
               Possible values:
               
                - `STATE_UNSPECIFIED`
                - `ACTIVE`
                - `SCHEDULING_FOR_DELETION`
                - `SCHEDULED_FOR_DELETION`
                - `SCHEDULING_FOR_DELETION_BY_PARENT`
                - `SCHEDULED_FOR_DELETION_BY_PARENT`
                - `UNDELETING`
                - `PURGING`
                - `PURGED`
                - `CREATING` - DRAFT = 1000;
        :param builtins.str suspension_state: ### Supported values
               
               Possible values:
               
                - `SUSPENSION_STATE_UNSPECIFIED`
                - `NONE`
                - `SUSPENDING`
                - `SUSPENDED`
                - `RESUMING`
        """
        pulumi.set(__self__, "container_state", container_state)
        pulumi.set(__self__, "region", region)
        pulumi.set(__self__, "suspension_state", suspension_state)

    @property
    @pulumi.getter(name="containerState")
    def container_state(self) -> builtins.str:
        """
        ### Supported values

        Possible values:

         - `STATE_UNSPECIFIED`
         - `ACTIVE`
         - `SCHEDULING_FOR_DELETION`
         - `SCHEDULED_FOR_DELETION`
         - `SCHEDULING_FOR_DELETION_BY_PARENT`
         - `SCHEDULED_FOR_DELETION_BY_PARENT`
         - `UNDELETING`
         - `PURGING`
         - `PURGED`
         - `CREATING` - DRAFT = 1000;
        """
        return pulumi.get(self, "container_state")

    @property
    @pulumi.getter
    def region(self) -> builtins.str:
        return pulumi.get(self, "region")

    @property
    @pulumi.getter(name="suspensionState")
    def suspension_state(self) -> builtins.str:
        """
        ### Supported values

        Possible values:

         - `SUSPENSION_STATE_UNSPECIFIED`
         - `NONE`
         - `SUSPENDING`
         - `SUSPENDED`
         - `RESUMING`
        """
        return pulumi.get(self, "suspension_state")


@pulumi.output_type
class GetIamV1TenantUserAccountMetadataResult(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class GetIamV1TenantUserAccountStatusResult(dict):
    def __init__(__self__, *,
                 federation_id: builtins.str,
                 invitation_id: builtins.str,
                 state: builtins.str):
        """
        :param builtins.str federation_id: currently can only accept the values: custom, unknown, google, github.
        :param builtins.str invitation_id: if a tenant user account is created during invitation it gets a reference to the invitation resource
               once invitation is accepted it looses this reference (and internally gets a reference to their global federated user account)
        :param builtins.str state: ### Supported values
               
               Possible values:
               
                - `STATE_UNSPECIFIED`
                - `ACTIVE`
                - `INACTIVE`
                - `BLOCKED`
        """
        pulumi.set(__self__, "federation_id", federation_id)
        pulumi.set(__self__, "invitation_id", invitation_id)
        pulumi.set(__self__, "state", state)

    @property
    @pulumi.getter(name="federationId")
    def federation_id(self) -> builtins.str:
        """
        currently can only accept the values: custom, unknown, google, github.
        """
        return pulumi.get(self, "federation_id")

    @property
    @pulumi.getter(name="invitationId")
    def invitation_id(self) -> builtins.str:
        """
        if a tenant user account is created during invitation it gets a reference to the invitation resource
        once invitation is accepted it looses this reference (and internally gets a reference to their global federated user account)
        """
        return pulumi.get(self, "invitation_id")

    @property
    @pulumi.getter
    def state(self) -> builtins.str:
        """
        ### Supported values

        Possible values:

         - `STATE_UNSPECIFIED`
         - `ACTIVE`
         - `INACTIVE`
         - `BLOCKED`
        """
        return pulumi.get(self, "state")


@pulumi.output_type
class GetIamV1TenantUserAccountVisibleAttributesResult(dict):
    def __init__(__self__, *,
                 attributes: Sequence[builtins.str]):
        pulumi.set(__self__, "attributes", attributes)

    @property
    @pulumi.getter
    def attributes(self) -> Sequence[builtins.str]:
        return pulumi.get(self, "attributes")


@pulumi.output_type
class GetIamV2AccessKeyAccountResult(dict):
    def __init__(__self__, *,
                 anonymous_account: 'outputs.GetIamV2AccessKeyAccountAnonymousAccountResult',
                 service_account: 'outputs.GetIamV2AccessKeyAccountServiceAccountResult',
                 user_account: 'outputs.GetIamV2AccessKeyAccountUserAccountResult'):
        """
        :param 'GetIamV2AccessKeyAccountAnonymousAccountArgs' anonymous_account: *Cannot be set alongside  or service_account.*
        :param 'GetIamV2AccessKeyAccountServiceAccountArgs' service_account: *Cannot be set alongside  or anonymous_account.*
        :param 'GetIamV2AccessKeyAccountUserAccountArgs' user_account: *Cannot be set alongside  or anonymous_account.*
        """
        pulumi.set(__self__, "anonymous_account", anonymous_account)
        pulumi.set(__self__, "service_account", service_account)
        pulumi.set(__self__, "user_account", user_account)

    @property
    @pulumi.getter(name="anonymousAccount")
    def anonymous_account(self) -> 'outputs.GetIamV2AccessKeyAccountAnonymousAccountResult':
        """
        *Cannot be set alongside  or service_account.*
        """
        return pulumi.get(self, "anonymous_account")

    @property
    @pulumi.getter(name="serviceAccount")
    def service_account(self) -> 'outputs.GetIamV2AccessKeyAccountServiceAccountResult':
        """
        *Cannot be set alongside  or anonymous_account.*
        """
        return pulumi.get(self, "service_account")

    @property
    @pulumi.getter(name="userAccount")
    def user_account(self) -> 'outputs.GetIamV2AccessKeyAccountUserAccountResult':
        """
        *Cannot be set alongside  or anonymous_account.*
        """
        return pulumi.get(self, "user_account")


@pulumi.output_type
class GetIamV2AccessKeyAccountAnonymousAccountResult(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class GetIamV2AccessKeyAccountServiceAccountResult(dict):
    def __init__(__self__, *,
                 id: builtins.str):
        pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> builtins.str:
        return pulumi.get(self, "id")


@pulumi.output_type
class GetIamV2AccessKeyAccountUserAccountResult(dict):
    def __init__(__self__, *,
                 id: builtins.str):
        pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> builtins.str:
        return pulumi.get(self, "id")


@pulumi.output_type
class GetIamV2AccessKeyMetadataResult(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class GetIamV2AccessKeyStatusResult(dict):
    def __init__(__self__, *,
                 algorithm: builtins.str,
                 aws_access_key_id: builtins.str,
                 fingerprint: builtins.str,
                 key_size: builtins.float,
                 secret: builtins.str,
                 state: builtins.str):
        """
        :param builtins.str state: ### Supported values
               
               Possible values:
               
                - `STATE_UNSPECIFIED`
                - `ACTIVE`
                - `INACTIVE`
                - `EXPIRED`
                - `DELETING`
                - `DELETED`
        """
        pulumi.set(__self__, "algorithm", algorithm)
        pulumi.set(__self__, "aws_access_key_id", aws_access_key_id)
        pulumi.set(__self__, "fingerprint", fingerprint)
        pulumi.set(__self__, "key_size", key_size)
        pulumi.set(__self__, "secret", secret)
        pulumi.set(__self__, "state", state)

    @property
    @pulumi.getter
    def algorithm(self) -> builtins.str:
        return pulumi.get(self, "algorithm")

    @property
    @pulumi.getter(name="awsAccessKeyId")
    def aws_access_key_id(self) -> builtins.str:
        return pulumi.get(self, "aws_access_key_id")

    @property
    @pulumi.getter
    def fingerprint(self) -> builtins.str:
        return pulumi.get(self, "fingerprint")

    @property
    @pulumi.getter(name="keySize")
    def key_size(self) -> builtins.float:
        return pulumi.get(self, "key_size")

    @property
    @pulumi.getter
    def secret(self) -> builtins.str:
        return pulumi.get(self, "secret")

    @property
    @pulumi.getter
    def state(self) -> builtins.str:
        """
        ### Supported values

        Possible values:

         - `STATE_UNSPECIFIED`
         - `ACTIVE`
         - `INACTIVE`
         - `EXPIRED`
         - `DELETING`
         - `DELETED`
        """
        return pulumi.get(self, "state")


@pulumi.output_type
class GetMk8sV1ClusterControlPlaneResult(dict):
    def __init__(__self__, *,
                 endpoints: 'outputs.GetMk8sV1ClusterControlPlaneEndpointsResult',
                 etcd_cluster_size: builtins.float,
                 subnet_id: builtins.str,
                 version: builtins.str):
        """
        :param builtins.float etcd_cluster_size: Number of instances in etcd cluster.
               3 by default.
               Control plane with `etcd_cluster_size: 3` called "Highly Available" ("HA"), because it's Kubernetes API
               will be available despite a failure of one control plane instance.
        :param builtins.str subnet_id: Nebius VPC Subnet ID where control plane instances will be located.
               Also will be default NodeGroup subnet.
        :param builtins.str version: Desired Kubernetes version of the cluster. For now only acceptable format is
               `<major>.<minor>` like "1.30". Option for patch version update will be added later.
        """
        pulumi.set(__self__, "endpoints", endpoints)
        pulumi.set(__self__, "etcd_cluster_size", etcd_cluster_size)
        pulumi.set(__self__, "subnet_id", subnet_id)
        pulumi.set(__self__, "version", version)

    @property
    @pulumi.getter
    def endpoints(self) -> 'outputs.GetMk8sV1ClusterControlPlaneEndpointsResult':
        return pulumi.get(self, "endpoints")

    @property
    @pulumi.getter(name="etcdClusterSize")
    def etcd_cluster_size(self) -> builtins.float:
        """
        Number of instances in etcd cluster.
        3 by default.
        Control plane with `etcd_cluster_size: 3` called "Highly Available" ("HA"), because it's Kubernetes API
        will be available despite a failure of one control plane instance.
        """
        return pulumi.get(self, "etcd_cluster_size")

    @property
    @pulumi.getter(name="subnetId")
    def subnet_id(self) -> builtins.str:
        """
        Nebius VPC Subnet ID where control plane instances will be located.
        Also will be default NodeGroup subnet.
        """
        return pulumi.get(self, "subnet_id")

    @property
    @pulumi.getter
    def version(self) -> builtins.str:
        """
        Desired Kubernetes version of the cluster. For now only acceptable format is
        `<major>.<minor>` like "1.30". Option for patch version update will be added later.
        """
        return pulumi.get(self, "version")


@pulumi.output_type
class GetMk8sV1ClusterControlPlaneEndpointsResult(dict):
    def __init__(__self__, *,
                 public_endpoint: 'outputs.GetMk8sV1ClusterControlPlaneEndpointsPublicEndpointResult'):
        """
        :param 'GetMk8sV1ClusterControlPlaneEndpointsPublicEndpointArgs' public_endpoint: Specification of public endpoint for control plane.
               Set value to empty, to enable it.
        """
        pulumi.set(__self__, "public_endpoint", public_endpoint)

    @property
    @pulumi.getter(name="publicEndpoint")
    def public_endpoint(self) -> 'outputs.GetMk8sV1ClusterControlPlaneEndpointsPublicEndpointResult':
        """
        Specification of public endpoint for control plane.
        Set value to empty, to enable it.
        """
        return pulumi.get(self, "public_endpoint")


@pulumi.output_type
class GetMk8sV1ClusterControlPlaneEndpointsPublicEndpointResult(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class GetMk8sV1ClusterKubeNetworkResult(dict):
    def __init__(__self__, *,
                 service_cidrs: Sequence[builtins.str]):
        """
        :param Sequence[builtins.str] service_cidrs: CIDR blocks for Service ClusterIP allocation.
               For now, only one value is supported.
               Must be a valid CIDR block or prefix length.
               In case of prefix length, certain CIDR is auto allocated.
               Specified CIDR blocks will be reserved in Cluster.spec.control_plane.subnet_id to prevent address duplication.
               Allowed prefix length is from "/12" to "/28".
               Empty value treated as ["/16"].
        """
        pulumi.set(__self__, "service_cidrs", service_cidrs)

    @property
    @pulumi.getter(name="serviceCidrs")
    def service_cidrs(self) -> Sequence[builtins.str]:
        """
        CIDR blocks for Service ClusterIP allocation.
        For now, only one value is supported.
        Must be a valid CIDR block or prefix length.
        In case of prefix length, certain CIDR is auto allocated.
        Specified CIDR blocks will be reserved in Cluster.spec.control_plane.subnet_id to prevent address duplication.
        Allowed prefix length is from "/12" to "/28".
        Empty value treated as ["/16"].
        """
        return pulumi.get(self, "service_cidrs")


@pulumi.output_type
class GetMk8sV1ClusterMetadataResult(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class GetMk8sV1ClusterStatusResult(dict):
    def __init__(__self__, *,
                 control_plane: 'outputs.GetMk8sV1ClusterStatusControlPlaneResult',
                 reconciling: builtins.bool,
                 state: builtins.str):
        """
        :param builtins.bool reconciling: Show that changes are in flight
        :param builtins.str state: ### Supported values
               
               Possible values:
               
                - `STATE_UNSPECIFIED`
                - `PROVISIONING`
                - `RUNNING`
                - `DELETING`
        """
        pulumi.set(__self__, "control_plane", control_plane)
        pulumi.set(__self__, "reconciling", reconciling)
        pulumi.set(__self__, "state", state)

    @property
    @pulumi.getter(name="controlPlane")
    def control_plane(self) -> 'outputs.GetMk8sV1ClusterStatusControlPlaneResult':
        return pulumi.get(self, "control_plane")

    @property
    @pulumi.getter
    def reconciling(self) -> builtins.bool:
        """
        Show that changes are in flight
        """
        return pulumi.get(self, "reconciling")

    @property
    @pulumi.getter
    def state(self) -> builtins.str:
        """
        ### Supported values

        Possible values:

         - `STATE_UNSPECIFIED`
         - `PROVISIONING`
         - `RUNNING`
         - `DELETING`
        """
        return pulumi.get(self, "state")


@pulumi.output_type
class GetMk8sV1ClusterStatusControlPlaneResult(dict):
    def __init__(__self__, *,
                 auth: 'outputs.GetMk8sV1ClusterStatusControlPlaneAuthResult',
                 endpoints: 'outputs.GetMk8sV1ClusterStatusControlPlaneEndpointsResult',
                 etcd_cluster_size: builtins.float,
                 version: builtins.str):
        """
        :param 'GetMk8sV1ClusterStatusControlPlaneEndpointsArgs' endpoints: ### Inner value description
               
               Endpoints of Kubernetes control plane. Kubernetes API can be accessed at `https://endpoint/`.
        :param builtins.float etcd_cluster_size: Number of instances in etcd cluster.
        :param builtins.str version: Actual Kubernetes and configuration version.
               Version have format `<major>.<minor>.<patch>-nebius-cp.<infra_version>` like "1.30.0-nebius-cp.3".
               Where <major>.<minor>.<patch> is Kubernetes version and <infra_version> is version of control plane infrastructure and configuration,
               which update may include bug fixes, security updates and new features of components running on control plane, like CCM or Cluster Autoscaler.
        """
        pulumi.set(__self__, "auth", auth)
        pulumi.set(__self__, "endpoints", endpoints)
        pulumi.set(__self__, "etcd_cluster_size", etcd_cluster_size)
        pulumi.set(__self__, "version", version)

    @property
    @pulumi.getter
    def auth(self) -> 'outputs.GetMk8sV1ClusterStatusControlPlaneAuthResult':
        return pulumi.get(self, "auth")

    @property
    @pulumi.getter
    def endpoints(self) -> 'outputs.GetMk8sV1ClusterStatusControlPlaneEndpointsResult':
        """
        ### Inner value description

        Endpoints of Kubernetes control plane. Kubernetes API can be accessed at `https://endpoint/`.
        """
        return pulumi.get(self, "endpoints")

    @property
    @pulumi.getter(name="etcdClusterSize")
    def etcd_cluster_size(self) -> builtins.float:
        """
        Number of instances in etcd cluster.
        """
        return pulumi.get(self, "etcd_cluster_size")

    @property
    @pulumi.getter
    def version(self) -> builtins.str:
        """
        Actual Kubernetes and configuration version.
        Version have format `<major>.<minor>.<patch>-nebius-cp.<infra_version>` like "1.30.0-nebius-cp.3".
        Where <major>.<minor>.<patch> is Kubernetes version and <infra_version> is version of control plane infrastructure and configuration,
        which update may include bug fixes, security updates and new features of components running on control plane, like CCM or Cluster Autoscaler.
        """
        return pulumi.get(self, "version")


@pulumi.output_type
class GetMk8sV1ClusterStatusControlPlaneAuthResult(dict):
    def __init__(__self__, *,
                 cluster_ca_certificate: builtins.str):
        """
        :param builtins.str cluster_ca_certificate: PEM with the Cluster Certificate Authority, that must be used for TLS connection to Kubernetes API.
        """
        pulumi.set(__self__, "cluster_ca_certificate", cluster_ca_certificate)

    @property
    @pulumi.getter(name="clusterCaCertificate")
    def cluster_ca_certificate(self) -> builtins.str:
        """
        PEM with the Cluster Certificate Authority, that must be used for TLS connection to Kubernetes API.
        """
        return pulumi.get(self, "cluster_ca_certificate")


@pulumi.output_type
class GetMk8sV1ClusterStatusControlPlaneEndpointsResult(dict):
    def __init__(__self__, *,
                 private_endpoint: builtins.str,
                 public_endpoint: builtins.str):
        """
        :param builtins.str private_endpoint: DNS name or IP address accessible from the user VPC.
        :param builtins.str public_endpoint: DNS name or IP address accessible from the Internet.
        """
        pulumi.set(__self__, "private_endpoint", private_endpoint)
        pulumi.set(__self__, "public_endpoint", public_endpoint)

    @property
    @pulumi.getter(name="privateEndpoint")
    def private_endpoint(self) -> builtins.str:
        """
        DNS name or IP address accessible from the user VPC.
        """
        return pulumi.get(self, "private_endpoint")

    @property
    @pulumi.getter(name="publicEndpoint")
    def public_endpoint(self) -> builtins.str:
        """
        DNS name or IP address accessible from the Internet.
        """
        return pulumi.get(self, "public_endpoint")


@pulumi.output_type
class GetMk8sV1NodeGroupAutoscalingResult(dict):
    def __init__(__self__, *,
                 max_node_count: builtins.float,
                 min_node_count: builtins.float):
        pulumi.set(__self__, "max_node_count", max_node_count)
        pulumi.set(__self__, "min_node_count", min_node_count)

    @property
    @pulumi.getter(name="maxNodeCount")
    def max_node_count(self) -> builtins.float:
        return pulumi.get(self, "max_node_count")

    @property
    @pulumi.getter(name="minNodeCount")
    def min_node_count(self) -> builtins.float:
        return pulumi.get(self, "min_node_count")


@pulumi.output_type
class GetMk8sV1NodeGroupMetadataResult(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class GetMk8sV1NodeGroupStatusResult(dict):
    def __init__(__self__, *,
                 node_count: builtins.float,
                 outdated_node_count: builtins.float,
                 ready_node_count: builtins.float,
                 reconciling: builtins.bool,
                 state: builtins.str,
                 target_node_count: builtins.float,
                 version: builtins.str):
        """
        :param builtins.float node_count: Total number of nodes that are currently in the node group.
               Both ready and not ready nodes are counted.
        :param builtins.float outdated_node_count: Total number of nodes that has outdated node configuration.
               These nodes will be replaced by new nodes with up-to-date configuration.
        :param builtins.float ready_node_count: Total number of nodes that successfully joined the cluster and are ready to serve workloads.
               Both outdated and up-to-date nodes are counted.
        :param builtins.bool reconciling: Show that there are changes are in flight.
        :param builtins.str state: ### Supported values
               
               Possible values:
               
                - `STATE_UNSPECIFIED`
                - `PROVISIONING`
                - `RUNNING`
                - `DELETING`
        :param builtins.float target_node_count: Desired total number of nodes that should be in the node group.
               It is either `NodeGroupSpec.fixed_node_count` or arbitrary number between
               `NodeGroupAutoscalingSpec.min_node_count` and `NodeGroupAutoscalingSpec.max_node_count` decided by autoscaler.
        :param builtins.str version: Actual version of NodeGroup. Have format `<major>.<minor>.<patch>-nebius-node.<infra_version>` like "1.30.0-nebius-node.10".
               Where <major>.<minor>.<patch> is Kubernetes version and <infra_version> is version of Node infrastructure and configuration,
               which update may include bug fixes, security updates and new features depending on worker node configuration.
        """
        pulumi.set(__self__, "node_count", node_count)
        pulumi.set(__self__, "outdated_node_count", outdated_node_count)
        pulumi.set(__self__, "ready_node_count", ready_node_count)
        pulumi.set(__self__, "reconciling", reconciling)
        pulumi.set(__self__, "state", state)
        pulumi.set(__self__, "target_node_count", target_node_count)
        pulumi.set(__self__, "version", version)

    @property
    @pulumi.getter(name="nodeCount")
    def node_count(self) -> builtins.float:
        """
        Total number of nodes that are currently in the node group.
        Both ready and not ready nodes are counted.
        """
        return pulumi.get(self, "node_count")

    @property
    @pulumi.getter(name="outdatedNodeCount")
    def outdated_node_count(self) -> builtins.float:
        """
        Total number of nodes that has outdated node configuration.
        These nodes will be replaced by new nodes with up-to-date configuration.
        """
        return pulumi.get(self, "outdated_node_count")

    @property
    @pulumi.getter(name="readyNodeCount")
    def ready_node_count(self) -> builtins.float:
        """
        Total number of nodes that successfully joined the cluster and are ready to serve workloads.
        Both outdated and up-to-date nodes are counted.
        """
        return pulumi.get(self, "ready_node_count")

    @property
    @pulumi.getter
    def reconciling(self) -> builtins.bool:
        """
        Show that there are changes are in flight.
        """
        return pulumi.get(self, "reconciling")

    @property
    @pulumi.getter
    def state(self) -> builtins.str:
        """
        ### Supported values

        Possible values:

         - `STATE_UNSPECIFIED`
         - `PROVISIONING`
         - `RUNNING`
         - `DELETING`
        """
        return pulumi.get(self, "state")

    @property
    @pulumi.getter(name="targetNodeCount")
    def target_node_count(self) -> builtins.float:
        """
        Desired total number of nodes that should be in the node group.
        It is either `NodeGroupSpec.fixed_node_count` or arbitrary number between
        `NodeGroupAutoscalingSpec.min_node_count` and `NodeGroupAutoscalingSpec.max_node_count` decided by autoscaler.
        """
        return pulumi.get(self, "target_node_count")

    @property
    @pulumi.getter
    def version(self) -> builtins.str:
        """
        Actual version of NodeGroup. Have format `<major>.<minor>.<patch>-nebius-node.<infra_version>` like "1.30.0-nebius-node.10".
        Where <major>.<minor>.<patch> is Kubernetes version and <infra_version> is version of Node infrastructure and configuration,
        which update may include bug fixes, security updates and new features depending on worker node configuration.
        """
        return pulumi.get(self, "version")


@pulumi.output_type
class GetMk8sV1NodeGroupStrategyResult(dict):
    def __init__(__self__, *,
                 drain_timeout: builtins.str,
                 max_surge: 'outputs.GetMk8sV1NodeGroupStrategyMaxSurgeResult',
                 max_unavailable: 'outputs.GetMk8sV1NodeGroupStrategyMaxUnavailableResult'):
        """
        :param builtins.str drain_timeout: Maximum amount of time that the service will spend on attempting gracefully draining a node (evicting it's pods), before
               falling back to pod deletion.
               By default, node can be drained unlimited time.
               Important consequence of that is if PodDisruptionBudget doesn't allow to evict a pod,
               then NodeGroup update with node re-creation will hung on that pod eviction.
               Note, that it is different from `kubectl drain --timeout`
               
               Duration as a string: possibly signed sequence of decimal numbers, each with optional fraction and a unit suffix, such as `300ms`, `-1.5h` or `2h45m`. Valid time units are `ns`, `us` (or `µs`), `ms`, `s`, `m`, `h`, `d`.
        :param 'GetMk8sV1NodeGroupStrategyMaxSurgeArgs' max_surge: The maximum number of additional nodes that can be provisioned above the desired number of nodes during the update process.
               This value can be specified either as an absolute number (for example 3) or as a percentage of the desired number of nodes (for example 5%).
               When specified as a percentage, the actual number is calculated by rounding up to the nearest whole number.
               This value cannot be 0 if `max_unavailable` is also set to 0.
               Defaults to 1.
               Example: If set to 25%, the node group can scale up by an additional 25% during the update,
               allowing new nodes to be added before old nodes are removed, which helps minimize workload disruption.
               NOTE: it is user responsibility to ensure that there are enough quota for provision nodes above the desired number.
                 Available quota effectively limits `max_surge`.
                 In case of not enough quota even for one extra node, update operation will hung because of quota exhausted error.
                 Such error will be visible in Operation.progress_data.
        :param 'GetMk8sV1NodeGroupStrategyMaxUnavailableArgs' max_unavailable: The maximum number of nodes that can be simultaneously unavailable during the update process.
               This value can be specified either as an absolute number (for example 3) or as a percentage of the desired number of nodes (for example 5%).
               When specified as a percentage, the actual number is calculated by rounding down to the nearest whole number.
               This value cannot be 0 if `max_surge` is also set to 0.
               Defaults to 0.
               Example: If set to 20%, up to 20% of the nodes can be taken offline at once during the update,
               ensuring that at least 80% of the desired nodes remain operational.
        """
        pulumi.set(__self__, "drain_timeout", drain_timeout)
        pulumi.set(__self__, "max_surge", max_surge)
        pulumi.set(__self__, "max_unavailable", max_unavailable)

    @property
    @pulumi.getter(name="drainTimeout")
    def drain_timeout(self) -> builtins.str:
        """
        Maximum amount of time that the service will spend on attempting gracefully draining a node (evicting it's pods), before
        falling back to pod deletion.
        By default, node can be drained unlimited time.
        Important consequence of that is if PodDisruptionBudget doesn't allow to evict a pod,
        then NodeGroup update with node re-creation will hung on that pod eviction.
        Note, that it is different from `kubectl drain --timeout`

        Duration as a string: possibly signed sequence of decimal numbers, each with optional fraction and a unit suffix, such as `300ms`, `-1.5h` or `2h45m`. Valid time units are `ns`, `us` (or `µs`), `ms`, `s`, `m`, `h`, `d`.
        """
        return pulumi.get(self, "drain_timeout")

    @property
    @pulumi.getter(name="maxSurge")
    def max_surge(self) -> 'outputs.GetMk8sV1NodeGroupStrategyMaxSurgeResult':
        """
        The maximum number of additional nodes that can be provisioned above the desired number of nodes during the update process.
        This value can be specified either as an absolute number (for example 3) or as a percentage of the desired number of nodes (for example 5%).
        When specified as a percentage, the actual number is calculated by rounding up to the nearest whole number.
        This value cannot be 0 if `max_unavailable` is also set to 0.
        Defaults to 1.
        Example: If set to 25%, the node group can scale up by an additional 25% during the update,
        allowing new nodes to be added before old nodes are removed, which helps minimize workload disruption.
        NOTE: it is user responsibility to ensure that there are enough quota for provision nodes above the desired number.
          Available quota effectively limits `max_surge`.
          In case of not enough quota even for one extra node, update operation will hung because of quota exhausted error.
          Such error will be visible in Operation.progress_data.
        """
        return pulumi.get(self, "max_surge")

    @property
    @pulumi.getter(name="maxUnavailable")
    def max_unavailable(self) -> 'outputs.GetMk8sV1NodeGroupStrategyMaxUnavailableResult':
        """
        The maximum number of nodes that can be simultaneously unavailable during the update process.
        This value can be specified either as an absolute number (for example 3) or as a percentage of the desired number of nodes (for example 5%).
        When specified as a percentage, the actual number is calculated by rounding down to the nearest whole number.
        This value cannot be 0 if `max_surge` is also set to 0.
        Defaults to 0.
        Example: If set to 20%, up to 20% of the nodes can be taken offline at once during the update,
        ensuring that at least 80% of the desired nodes remain operational.
        """
        return pulumi.get(self, "max_unavailable")


@pulumi.output_type
class GetMk8sV1NodeGroupStrategyMaxSurgeResult(dict):
    def __init__(__self__, *,
                 count: builtins.float,
                 percent: builtins.float):
        """
        :param builtins.float count: *Cannot be set alongside percent.*
        :param builtins.float percent: *Cannot be set alongside count.*
        """
        pulumi.set(__self__, "count", count)
        pulumi.set(__self__, "percent", percent)

    @property
    @pulumi.getter
    def count(self) -> builtins.float:
        """
        *Cannot be set alongside percent.*
        """
        return pulumi.get(self, "count")

    @property
    @pulumi.getter
    def percent(self) -> builtins.float:
        """
        *Cannot be set alongside count.*
        """
        return pulumi.get(self, "percent")


@pulumi.output_type
class GetMk8sV1NodeGroupStrategyMaxUnavailableResult(dict):
    def __init__(__self__, *,
                 count: builtins.float,
                 percent: builtins.float):
        """
        :param builtins.float count: *Cannot be set alongside percent.*
        :param builtins.float percent: *Cannot be set alongside count.*
        """
        pulumi.set(__self__, "count", count)
        pulumi.set(__self__, "percent", percent)

    @property
    @pulumi.getter
    def count(self) -> builtins.float:
        """
        *Cannot be set alongside percent.*
        """
        return pulumi.get(self, "count")

    @property
    @pulumi.getter
    def percent(self) -> builtins.float:
        """
        *Cannot be set alongside count.*
        """
        return pulumi.get(self, "percent")


@pulumi.output_type
class GetMk8sV1NodeGroupTemplateResult(dict):
    def __init__(__self__, *,
                 boot_disk: 'outputs.GetMk8sV1NodeGroupTemplateBootDiskResult',
                 cloud_init_user_data: builtins.str,
                 filesystems: Sequence['outputs.GetMk8sV1NodeGroupTemplateFilesystemResult'],
                 gpu_cluster: 'outputs.GetMk8sV1NodeGroupTemplateGpuClusterResult',
                 gpu_settings: 'outputs.GetMk8sV1NodeGroupTemplateGpuSettingsResult',
                 metadata: 'outputs.GetMk8sV1NodeGroupTemplateMetadataResult',
                 network_interfaces: Sequence['outputs.GetMk8sV1NodeGroupTemplateNetworkInterfaceResult'],
                 resources: 'outputs.GetMk8sV1NodeGroupTemplateResourcesResult',
                 service_account_id: builtins.str,
                 taints: Sequence['outputs.GetMk8sV1NodeGroupTemplateTaintResult']):
        """
        :param 'GetMk8sV1NodeGroupTemplateBootDiskArgs' boot_disk: Parameters of a Node Nebius Compute Instance boot disk.
        :param builtins.str cloud_init_user_data: cloud-init user-data
               Should contain at least one SSH key.
        :param Sequence['GetMk8sV1NodeGroupTemplateFilesystemArgs'] filesystems: Static attachments of Compute Filesystem.
               Can be used as a workaround, until CSI for Compute Disk and Filesystem will be available.
        :param 'GetMk8sV1NodeGroupTemplateGpuClusterArgs' gpu_cluster: Nebius Compute GPUCluster ID that will be attached to node.
        :param 'GetMk8sV1NodeGroupTemplateGpuSettingsArgs' gpu_settings: GPU-related settings.
               
               ### Inner value description
               
               GPU-related settings.
        :param 'GetMk8sV1NodeGroupTemplateResourcesArgs' resources: Resources that will have Nebius Compute Instance where Node kubelet will run.
        :param builtins.str service_account_id: the Nebius service account whose credentials will be available on the nodes of the group.
               With these credentials, it is possible to make `npc` or public API requests from the nodes without the need for extra authentication.
               This service account is also used to make requests to container registry.
               
               `resource.serviceaccount.issueAccessToken` permission is required to use this field.
        :param Sequence['GetMk8sV1NodeGroupTemplateTaintArgs'] taints: Kubernetes Node taints.
               For now change will not be propagated to existing nodes, so will be applied only to Kubernetes Nodes created after the field change.
               That behaviour may change later.
               So, for now you will need to manually set them to existing nodes, if that is needed.
               Field change will NOT trigger NodeGroup roll out.
               
               ### Inner value description
               
               See https://kubernetes.io/docs/concepts/scheduling-eviction/taint-and-toleration/
        """
        pulumi.set(__self__, "boot_disk", boot_disk)
        pulumi.set(__self__, "cloud_init_user_data", cloud_init_user_data)
        pulumi.set(__self__, "filesystems", filesystems)
        pulumi.set(__self__, "gpu_cluster", gpu_cluster)
        pulumi.set(__self__, "gpu_settings", gpu_settings)
        pulumi.set(__self__, "metadata", metadata)
        pulumi.set(__self__, "network_interfaces", network_interfaces)
        pulumi.set(__self__, "resources", resources)
        pulumi.set(__self__, "service_account_id", service_account_id)
        pulumi.set(__self__, "taints", taints)

    @property
    @pulumi.getter(name="bootDisk")
    def boot_disk(self) -> 'outputs.GetMk8sV1NodeGroupTemplateBootDiskResult':
        """
        Parameters of a Node Nebius Compute Instance boot disk.
        """
        return pulumi.get(self, "boot_disk")

    @property
    @pulumi.getter(name="cloudInitUserData")
    def cloud_init_user_data(self) -> builtins.str:
        """
        cloud-init user-data
        Should contain at least one SSH key.
        """
        return pulumi.get(self, "cloud_init_user_data")

    @property
    @pulumi.getter
    def filesystems(self) -> Sequence['outputs.GetMk8sV1NodeGroupTemplateFilesystemResult']:
        """
        Static attachments of Compute Filesystem.
        Can be used as a workaround, until CSI for Compute Disk and Filesystem will be available.
        """
        return pulumi.get(self, "filesystems")

    @property
    @pulumi.getter(name="gpuCluster")
    def gpu_cluster(self) -> 'outputs.GetMk8sV1NodeGroupTemplateGpuClusterResult':
        """
        Nebius Compute GPUCluster ID that will be attached to node.
        """
        return pulumi.get(self, "gpu_cluster")

    @property
    @pulumi.getter(name="gpuSettings")
    def gpu_settings(self) -> 'outputs.GetMk8sV1NodeGroupTemplateGpuSettingsResult':
        """
        GPU-related settings.

        ### Inner value description

        GPU-related settings.
        """
        return pulumi.get(self, "gpu_settings")

    @property
    @pulumi.getter
    def metadata(self) -> 'outputs.GetMk8sV1NodeGroupTemplateMetadataResult':
        return pulumi.get(self, "metadata")

    @property
    @pulumi.getter(name="networkInterfaces")
    def network_interfaces(self) -> Sequence['outputs.GetMk8sV1NodeGroupTemplateNetworkInterfaceResult']:
        return pulumi.get(self, "network_interfaces")

    @property
    @pulumi.getter
    def resources(self) -> 'outputs.GetMk8sV1NodeGroupTemplateResourcesResult':
        """
        Resources that will have Nebius Compute Instance where Node kubelet will run.
        """
        return pulumi.get(self, "resources")

    @property
    @pulumi.getter(name="serviceAccountId")
    def service_account_id(self) -> builtins.str:
        """
        the Nebius service account whose credentials will be available on the nodes of the group.
        With these credentials, it is possible to make `npc` or public API requests from the nodes without the need for extra authentication.
        This service account is also used to make requests to container registry.

        `resource.serviceaccount.issueAccessToken` permission is required to use this field.
        """
        return pulumi.get(self, "service_account_id")

    @property
    @pulumi.getter
    def taints(self) -> Sequence['outputs.GetMk8sV1NodeGroupTemplateTaintResult']:
        """
        Kubernetes Node taints.
        For now change will not be propagated to existing nodes, so will be applied only to Kubernetes Nodes created after the field change.
        That behaviour may change later.
        So, for now you will need to manually set them to existing nodes, if that is needed.
        Field change will NOT trigger NodeGroup roll out.

        ### Inner value description

        See https://kubernetes.io/docs/concepts/scheduling-eviction/taint-and-toleration/
        """
        return pulumi.get(self, "taints")


@pulumi.output_type
class GetMk8sV1NodeGroupTemplateBootDiskResult(dict):
    def __init__(__self__, *,
                 block_size_bytes: builtins.float,
                 size_bytes: builtins.float,
                 size_gibibytes: builtins.float,
                 size_kibibytes: builtins.float,
                 size_mebibytes: builtins.float,
                 type: builtins.str):
        """
        :param builtins.float size_bytes: *Cannot be set alongside size_kibibytes or size_gibibytes.*
        :param builtins.float size_gibibytes: *Cannot be set alongside size_bytes or size_mebibytes.*
        :param builtins.float size_kibibytes: *Cannot be set alongside size_bytes or size_gibibytes.*
        :param builtins.float size_mebibytes: *Cannot be set alongside size_bytes or size_gibibytes.*
        :param builtins.str type: ### Supported values
               
               Possible values:
               
                - `UNSPECIFIED`
                - `NETWORK_SSD`
                - `NETWORK_HDD`
                - `NETWORK_SSD_IO_M3`
                - `NETWORK_SSD_NON_REPLICATED`
        """
        pulumi.set(__self__, "block_size_bytes", block_size_bytes)
        pulumi.set(__self__, "size_bytes", size_bytes)
        pulumi.set(__self__, "size_gibibytes", size_gibibytes)
        pulumi.set(__self__, "size_kibibytes", size_kibibytes)
        pulumi.set(__self__, "size_mebibytes", size_mebibytes)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter(name="blockSizeBytes")
    def block_size_bytes(self) -> builtins.float:
        return pulumi.get(self, "block_size_bytes")

    @property
    @pulumi.getter(name="sizeBytes")
    def size_bytes(self) -> builtins.float:
        """
        *Cannot be set alongside size_kibibytes or size_gibibytes.*
        """
        return pulumi.get(self, "size_bytes")

    @property
    @pulumi.getter(name="sizeGibibytes")
    def size_gibibytes(self) -> builtins.float:
        """
        *Cannot be set alongside size_bytes or size_mebibytes.*
        """
        return pulumi.get(self, "size_gibibytes")

    @property
    @pulumi.getter(name="sizeKibibytes")
    def size_kibibytes(self) -> builtins.float:
        """
        *Cannot be set alongside size_bytes or size_gibibytes.*
        """
        return pulumi.get(self, "size_kibibytes")

    @property
    @pulumi.getter(name="sizeMebibytes")
    def size_mebibytes(self) -> builtins.float:
        """
        *Cannot be set alongside size_bytes or size_gibibytes.*
        """
        return pulumi.get(self, "size_mebibytes")

    @property
    @pulumi.getter
    def type(self) -> builtins.str:
        """
        ### Supported values

        Possible values:

         - `UNSPECIFIED`
         - `NETWORK_SSD`
         - `NETWORK_HDD`
         - `NETWORK_SSD_IO_M3`
         - `NETWORK_SSD_NON_REPLICATED`
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class GetMk8sV1NodeGroupTemplateFilesystemResult(dict):
    def __init__(__self__, *,
                 attach_mode: builtins.str,
                 existing_filesystem: 'outputs.GetMk8sV1NodeGroupTemplateFilesystemExistingFilesystemResult',
                 mount_tag: builtins.str):
        """
        :param builtins.str attach_mode: ### Supported values
               
               Possible values:
               
                - `UNSPECIFIED`
                - `READ_ONLY`
                - `READ_WRITE`
        :param builtins.str mount_tag: Specifies the user-defined identifier, allowing to use it as a device in mount command.
        """
        pulumi.set(__self__, "attach_mode", attach_mode)
        pulumi.set(__self__, "existing_filesystem", existing_filesystem)
        pulumi.set(__self__, "mount_tag", mount_tag)

    @property
    @pulumi.getter(name="attachMode")
    def attach_mode(self) -> builtins.str:
        """
        ### Supported values

        Possible values:

         - `UNSPECIFIED`
         - `READ_ONLY`
         - `READ_WRITE`
        """
        return pulumi.get(self, "attach_mode")

    @property
    @pulumi.getter(name="existingFilesystem")
    def existing_filesystem(self) -> 'outputs.GetMk8sV1NodeGroupTemplateFilesystemExistingFilesystemResult':
        return pulumi.get(self, "existing_filesystem")

    @property
    @pulumi.getter(name="mountTag")
    def mount_tag(self) -> builtins.str:
        """
        Specifies the user-defined identifier, allowing to use it as a device in mount command.
        """
        return pulumi.get(self, "mount_tag")


@pulumi.output_type
class GetMk8sV1NodeGroupTemplateFilesystemExistingFilesystemResult(dict):
    def __init__(__self__, *,
                 id: builtins.str):
        pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> builtins.str:
        return pulumi.get(self, "id")


@pulumi.output_type
class GetMk8sV1NodeGroupTemplateGpuClusterResult(dict):
    def __init__(__self__, *,
                 id: builtins.str):
        pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> builtins.str:
        return pulumi.get(self, "id")


@pulumi.output_type
class GetMk8sV1NodeGroupTemplateGpuSettingsResult(dict):
    def __init__(__self__, *,
                 drivers_preset: builtins.str):
        """
        :param builtins.str drivers_preset: Identifier of the predefined set of drivers included in the ComputeImage deployed on ComputeInstances that are part of the NodeGroup.
               Supported presets: cuda12
        """
        pulumi.set(__self__, "drivers_preset", drivers_preset)

    @property
    @pulumi.getter(name="driversPreset")
    def drivers_preset(self) -> builtins.str:
        """
        Identifier of the predefined set of drivers included in the ComputeImage deployed on ComputeInstances that are part of the NodeGroup.
        Supported presets: cuda12
        """
        return pulumi.get(self, "drivers_preset")


@pulumi.output_type
class GetMk8sV1NodeGroupTemplateMetadataResult(dict):
    def __init__(__self__, *,
                 labels: Mapping[str, builtins.str]):
        """
        :param Mapping[str, builtins.str] labels: Kubernetes Node labels.
               For now change will not be propagated to existing nodes, so will be applied only to Kubernetes Nodes created after the field change.
               That behaviour may change later.
               So, for now you will need to manually set them to existing nodes, if that is needed.
               
               System labels containing "kubernetes.io" and "k8s.io" will be ignored.
               Field change will NOT trigger NodeGroup roll out.
        """
        pulumi.set(__self__, "labels", labels)

    @property
    @pulumi.getter
    def labels(self) -> Mapping[str, builtins.str]:
        """
        Kubernetes Node labels.
        For now change will not be propagated to existing nodes, so will be applied only to Kubernetes Nodes created after the field change.
        That behaviour may change later.
        So, for now you will need to manually set them to existing nodes, if that is needed.

        System labels containing "kubernetes.io" and "k8s.io" will be ignored.
        Field change will NOT trigger NodeGroup roll out.
        """
        return pulumi.get(self, "labels")


@pulumi.output_type
class GetMk8sV1NodeGroupTemplateNetworkInterfaceResult(dict):
    def __init__(__self__, *,
                 public_ip_address: 'outputs.GetMk8sV1NodeGroupTemplateNetworkInterfacePublicIpAddressResult',
                 subnet_id: builtins.str):
        """
        :param 'GetMk8sV1NodeGroupTemplateNetworkInterfacePublicIpAddressArgs' public_ip_address: Parameters for Public IPv4 address associated with the interface.
               Set to empty value, to enable it.
               
               ### Inner value description
               
               Describes a public IP address.
        :param builtins.str subnet_id: Nebius VPC Subnet ID that will be attached to a node cloud instance network interface.
               By default Cluster control plane subnet_id used.
               Subnet should be located in the same network with control plane.
        """
        pulumi.set(__self__, "public_ip_address", public_ip_address)
        pulumi.set(__self__, "subnet_id", subnet_id)

    @property
    @pulumi.getter(name="publicIpAddress")
    def public_ip_address(self) -> 'outputs.GetMk8sV1NodeGroupTemplateNetworkInterfacePublicIpAddressResult':
        """
        Parameters for Public IPv4 address associated with the interface.
        Set to empty value, to enable it.

        ### Inner value description

        Describes a public IP address.
        """
        return pulumi.get(self, "public_ip_address")

    @property
    @pulumi.getter(name="subnetId")
    def subnet_id(self) -> builtins.str:
        """
        Nebius VPC Subnet ID that will be attached to a node cloud instance network interface.
        By default Cluster control plane subnet_id used.
        Subnet should be located in the same network with control plane.
        """
        return pulumi.get(self, "subnet_id")


@pulumi.output_type
class GetMk8sV1NodeGroupTemplateNetworkInterfacePublicIpAddressResult(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class GetMk8sV1NodeGroupTemplateResourcesResult(dict):
    def __init__(__self__, *,
                 platform: builtins.str,
                 preset: builtins.str):
        pulumi.set(__self__, "platform", platform)
        pulumi.set(__self__, "preset", preset)

    @property
    @pulumi.getter
    def platform(self) -> builtins.str:
        return pulumi.get(self, "platform")

    @property
    @pulumi.getter
    def preset(self) -> builtins.str:
        return pulumi.get(self, "preset")


@pulumi.output_type
class GetMk8sV1NodeGroupTemplateTaintResult(dict):
    def __init__(__self__, *,
                 effect: builtins.str,
                 key: builtins.str,
                 value: builtins.str):
        """
        :param builtins.str effect: ### Supported values
               
               Possible values:
               
                - `EFFECT_UNSPECIFIED`
                - `NO_EXECUTE`
                - `NO_SCHEDULE`
                - `PREFER_NO_SCHEDULE`
        """
        pulumi.set(__self__, "effect", effect)
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def effect(self) -> builtins.str:
        """
        ### Supported values

        Possible values:

         - `EFFECT_UNSPECIFIED`
         - `NO_EXECUTE`
         - `NO_SCHEDULE`
         - `PREFER_NO_SCHEDULE`
        """
        return pulumi.get(self, "effect")

    @property
    @pulumi.getter
    def key(self) -> builtins.str:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def value(self) -> builtins.str:
        return pulumi.get(self, "value")


@pulumi.output_type
class GetMk8sV1alpha1ClusterControlPlaneResult(dict):
    def __init__(__self__, *,
                 endpoints: 'outputs.GetMk8sV1alpha1ClusterControlPlaneEndpointsResult',
                 etcd_cluster_size: builtins.float,
                 subnet_id: builtins.str,
                 version: builtins.str):
        """
        :param builtins.float etcd_cluster_size: Number of instances in etcd cluster.
               3 by default.
               Control plane with `etcd_cluster_size: 3` called "Highly Available" ("HA"), because it's Kubernetes API
               will be available despite a failure of one control plane instance.
        :param builtins.str subnet_id: Subnet ID where control plane instances will be located.
        :param builtins.str version: Version is desired Kubernetes version of the cluster. For now only acceptable format is
               `MAJOR.MINOR` like "1.30". Option for patch version update will be added later.
        """
        pulumi.set(__self__, "endpoints", endpoints)
        pulumi.set(__self__, "etcd_cluster_size", etcd_cluster_size)
        pulumi.set(__self__, "subnet_id", subnet_id)
        pulumi.set(__self__, "version", version)

    @property
    @pulumi.getter
    def endpoints(self) -> 'outputs.GetMk8sV1alpha1ClusterControlPlaneEndpointsResult':
        return pulumi.get(self, "endpoints")

    @property
    @pulumi.getter(name="etcdClusterSize")
    def etcd_cluster_size(self) -> builtins.float:
        """
        Number of instances in etcd cluster.
        3 by default.
        Control plane with `etcd_cluster_size: 3` called "Highly Available" ("HA"), because it's Kubernetes API
        will be available despite a failure of one control plane instance.
        """
        return pulumi.get(self, "etcd_cluster_size")

    @property
    @pulumi.getter(name="subnetId")
    def subnet_id(self) -> builtins.str:
        """
        Subnet ID where control plane instances will be located.
        """
        return pulumi.get(self, "subnet_id")

    @property
    @pulumi.getter
    def version(self) -> builtins.str:
        """
        Version is desired Kubernetes version of the cluster. For now only acceptable format is
        `MAJOR.MINOR` like "1.30". Option for patch version update will be added later.
        """
        return pulumi.get(self, "version")


@pulumi.output_type
class GetMk8sV1alpha1ClusterControlPlaneEndpointsResult(dict):
    def __init__(__self__, *,
                 public_endpoint: 'outputs.GetMk8sV1alpha1ClusterControlPlaneEndpointsPublicEndpointResult'):
        """
        :param 'GetMk8sV1alpha1ClusterControlPlaneEndpointsPublicEndpointArgs' public_endpoint: PublicEndpointSpec is a specification of public endpoint for control plane.
        """
        pulumi.set(__self__, "public_endpoint", public_endpoint)

    @property
    @pulumi.getter(name="publicEndpoint")
    def public_endpoint(self) -> 'outputs.GetMk8sV1alpha1ClusterControlPlaneEndpointsPublicEndpointResult':
        """
        PublicEndpointSpec is a specification of public endpoint for control plane.
        """
        return pulumi.get(self, "public_endpoint")


@pulumi.output_type
class GetMk8sV1alpha1ClusterControlPlaneEndpointsPublicEndpointResult(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class GetMk8sV1alpha1ClusterKubeNetworkResult(dict):
    def __init__(__self__, *,
                 service_cidrs: Sequence[builtins.str]):
        """
        :param Sequence[builtins.str] service_cidrs: CIDR blocks for Service ClusterIP allocation.
               For now, only one value is supported.
               Must be a valid CIDR block or prefix length.
               In case of prefix length, certain CIDR is auto allocated.
               Specified CIDR blocks will be reserved in Cluster.spec.control_plane.subnet_id to prevent address duplication.
               Allowed prefix length is from "/12" to "/28".
               Empty value treated as ["/16"].
        """
        pulumi.set(__self__, "service_cidrs", service_cidrs)

    @property
    @pulumi.getter(name="serviceCidrs")
    def service_cidrs(self) -> Sequence[builtins.str]:
        """
        CIDR blocks for Service ClusterIP allocation.
        For now, only one value is supported.
        Must be a valid CIDR block or prefix length.
        In case of prefix length, certain CIDR is auto allocated.
        Specified CIDR blocks will be reserved in Cluster.spec.control_plane.subnet_id to prevent address duplication.
        Allowed prefix length is from "/12" to "/28".
        Empty value treated as ["/16"].
        """
        return pulumi.get(self, "service_cidrs")


@pulumi.output_type
class GetMk8sV1alpha1ClusterMetadataResult(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class GetMk8sV1alpha1ClusterStatusResult(dict):
    def __init__(__self__, *,
                 control_plane: 'outputs.GetMk8sV1alpha1ClusterStatusControlPlaneResult',
                 reconciling: builtins.bool,
                 state: builtins.str):
        """
        :param builtins.bool reconciling: Show that changes are in flight
        :param builtins.str state: ### Supported values
               
               Possible values:
               
                - `STATE_UNSPECIFIED`
                - `PROVISIONING`
                - `RUNNING`
                - `DELETING`
        """
        pulumi.set(__self__, "control_plane", control_plane)
        pulumi.set(__self__, "reconciling", reconciling)
        pulumi.set(__self__, "state", state)

    @property
    @pulumi.getter(name="controlPlane")
    def control_plane(self) -> 'outputs.GetMk8sV1alpha1ClusterStatusControlPlaneResult':
        return pulumi.get(self, "control_plane")

    @property
    @pulumi.getter
    def reconciling(self) -> builtins.bool:
        """
        Show that changes are in flight
        """
        return pulumi.get(self, "reconciling")

    @property
    @pulumi.getter
    def state(self) -> builtins.str:
        """
        ### Supported values

        Possible values:

         - `STATE_UNSPECIFIED`
         - `PROVISIONING`
         - `RUNNING`
         - `DELETING`
        """
        return pulumi.get(self, "state")


@pulumi.output_type
class GetMk8sV1alpha1ClusterStatusControlPlaneResult(dict):
    def __init__(__self__, *,
                 auth: 'outputs.GetMk8sV1alpha1ClusterStatusControlPlaneAuthResult',
                 endpoints: 'outputs.GetMk8sV1alpha1ClusterStatusControlPlaneEndpointsResult',
                 etcd_cluster_size: builtins.float,
                 version: builtins.str):
        """
        :param 'GetMk8sV1alpha1ClusterStatusControlPlaneEndpointsArgs' endpoints: ### Inner value description
               
               Endpoints of Kubernetes control plane. Kubernetes API can be accessed at `https://endpoint/`.
        :param builtins.float etcd_cluster_size: Number of instances in etcd cluster.
        :param builtins.str version: Version have format `major.minor.patch-nebius-cp.n` like "1.30.0-nebius-cp.3".
        """
        pulumi.set(__self__, "auth", auth)
        pulumi.set(__self__, "endpoints", endpoints)
        pulumi.set(__self__, "etcd_cluster_size", etcd_cluster_size)
        pulumi.set(__self__, "version", version)

    @property
    @pulumi.getter
    def auth(self) -> 'outputs.GetMk8sV1alpha1ClusterStatusControlPlaneAuthResult':
        return pulumi.get(self, "auth")

    @property
    @pulumi.getter
    def endpoints(self) -> 'outputs.GetMk8sV1alpha1ClusterStatusControlPlaneEndpointsResult':
        """
        ### Inner value description

        Endpoints of Kubernetes control plane. Kubernetes API can be accessed at `https://endpoint/`.
        """
        return pulumi.get(self, "endpoints")

    @property
    @pulumi.getter(name="etcdClusterSize")
    def etcd_cluster_size(self) -> builtins.float:
        """
        Number of instances in etcd cluster.
        """
        return pulumi.get(self, "etcd_cluster_size")

    @property
    @pulumi.getter
    def version(self) -> builtins.str:
        """
        Version have format `major.minor.patch-nebius-cp.n` like "1.30.0-nebius-cp.3".
        """
        return pulumi.get(self, "version")


@pulumi.output_type
class GetMk8sV1alpha1ClusterStatusControlPlaneAuthResult(dict):
    def __init__(__self__, *,
                 cluster_ca_certificate: builtins.str):
        pulumi.set(__self__, "cluster_ca_certificate", cluster_ca_certificate)

    @property
    @pulumi.getter(name="clusterCaCertificate")
    def cluster_ca_certificate(self) -> builtins.str:
        return pulumi.get(self, "cluster_ca_certificate")


@pulumi.output_type
class GetMk8sV1alpha1ClusterStatusControlPlaneEndpointsResult(dict):
    def __init__(__self__, *,
                 private_endpoint: builtins.str,
                 public_endpoint: builtins.str):
        """
        :param builtins.str private_endpoint: DNS name or IP address accessible from the user VPC.
        :param builtins.str public_endpoint: DNS name or IP address accessible from the Internet.
        """
        pulumi.set(__self__, "private_endpoint", private_endpoint)
        pulumi.set(__self__, "public_endpoint", public_endpoint)

    @property
    @pulumi.getter(name="privateEndpoint")
    def private_endpoint(self) -> builtins.str:
        """
        DNS name or IP address accessible from the user VPC.
        """
        return pulumi.get(self, "private_endpoint")

    @property
    @pulumi.getter(name="publicEndpoint")
    def public_endpoint(self) -> builtins.str:
        """
        DNS name or IP address accessible from the Internet.
        """
        return pulumi.get(self, "public_endpoint")


@pulumi.output_type
class GetMk8sV1alpha1NodeGroupAutoscalingResult(dict):
    def __init__(__self__, *,
                 max_node_count: builtins.float,
                 min_node_count: builtins.float):
        pulumi.set(__self__, "max_node_count", max_node_count)
        pulumi.set(__self__, "min_node_count", min_node_count)

    @property
    @pulumi.getter(name="maxNodeCount")
    def max_node_count(self) -> builtins.float:
        return pulumi.get(self, "max_node_count")

    @property
    @pulumi.getter(name="minNodeCount")
    def min_node_count(self) -> builtins.float:
        return pulumi.get(self, "min_node_count")


@pulumi.output_type
class GetMk8sV1alpha1NodeGroupMetadataResult(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class GetMk8sV1alpha1NodeGroupStatusResult(dict):
    def __init__(__self__, *,
                 node_count: builtins.float,
                 outdated_node_count: builtins.float,
                 ready_node_count: builtins.float,
                 reconciling: builtins.bool,
                 state: builtins.str,
                 target_node_count: builtins.float,
                 version: builtins.str):
        """
        :param builtins.float node_count: Total number of nodes that are currently in the node group.
               Both ready and not ready nodes are counted.
        :param builtins.float outdated_node_count: Total number of nodes that has outdated node configuration.
               These nodes will be replaced by new nodes with up-to-date configuration.
        :param builtins.float ready_node_count: Total number of nodes that successfully joined the cluster and are ready to serve workloads.
               Both outdated and up-to-date nodes are counted.
        :param builtins.bool reconciling: Show that changes are in flight
        :param builtins.str state: ### Supported values
               
               Possible values:
               
                - `STATE_UNSPECIFIED`
                - `PROVISIONING`
                - `RUNNING`
                - `DELETING`
        :param builtins.float target_node_count: Desired total number of nodes that should be in the node group.
               It is either fixed_node_count or arbitrary number between min_node_count and max_node_count decided by autoscaler.
        :param builtins.str version: Version have format `MAJOR.MINOR.PATCH-nebius-node.n` like "1.30.0-nebius-node.10".
        """
        pulumi.set(__self__, "node_count", node_count)
        pulumi.set(__self__, "outdated_node_count", outdated_node_count)
        pulumi.set(__self__, "ready_node_count", ready_node_count)
        pulumi.set(__self__, "reconciling", reconciling)
        pulumi.set(__self__, "state", state)
        pulumi.set(__self__, "target_node_count", target_node_count)
        pulumi.set(__self__, "version", version)

    @property
    @pulumi.getter(name="nodeCount")
    def node_count(self) -> builtins.float:
        """
        Total number of nodes that are currently in the node group.
        Both ready and not ready nodes are counted.
        """
        return pulumi.get(self, "node_count")

    @property
    @pulumi.getter(name="outdatedNodeCount")
    def outdated_node_count(self) -> builtins.float:
        """
        Total number of nodes that has outdated node configuration.
        These nodes will be replaced by new nodes with up-to-date configuration.
        """
        return pulumi.get(self, "outdated_node_count")

    @property
    @pulumi.getter(name="readyNodeCount")
    def ready_node_count(self) -> builtins.float:
        """
        Total number of nodes that successfully joined the cluster and are ready to serve workloads.
        Both outdated and up-to-date nodes are counted.
        """
        return pulumi.get(self, "ready_node_count")

    @property
    @pulumi.getter
    def reconciling(self) -> builtins.bool:
        """
        Show that changes are in flight
        """
        return pulumi.get(self, "reconciling")

    @property
    @pulumi.getter
    def state(self) -> builtins.str:
        """
        ### Supported values

        Possible values:

         - `STATE_UNSPECIFIED`
         - `PROVISIONING`
         - `RUNNING`
         - `DELETING`
        """
        return pulumi.get(self, "state")

    @property
    @pulumi.getter(name="targetNodeCount")
    def target_node_count(self) -> builtins.float:
        """
        Desired total number of nodes that should be in the node group.
        It is either fixed_node_count or arbitrary number between min_node_count and max_node_count decided by autoscaler.
        """
        return pulumi.get(self, "target_node_count")

    @property
    @pulumi.getter
    def version(self) -> builtins.str:
        """
        Version have format `MAJOR.MINOR.PATCH-nebius-node.n` like "1.30.0-nebius-node.10".
        """
        return pulumi.get(self, "version")


@pulumi.output_type
class GetMk8sV1alpha1NodeGroupStrategyResult(dict):
    def __init__(__self__, *,
                 drain_timeout: builtins.str,
                 max_surge: 'outputs.GetMk8sV1alpha1NodeGroupStrategyMaxSurgeResult',
                 max_unavailable: 'outputs.GetMk8sV1alpha1NodeGroupStrategyMaxUnavailableResult'):
        """
        :param builtins.str drain_timeout: DrainTimeout is the total amount of time that the service will spend on draining a node.
               By default, node can be drained without any time limitations.
               NOTE: NodeDrainTimeout is different from `kubectl drain --timeout`
               
               Duration as a string: possibly signed sequence of decimal numbers, each with optional fraction and a unit suffix, such as `300ms`, `-1.5h` or `2h45m`. Valid time units are `ns`, `us` (or `µs`), `ms`, `s`, `m`, `h`, `d`.
        :param 'GetMk8sV1alpha1NodeGroupStrategyMaxSurgeArgs' max_surge: The maximum number of machines that can be scheduled above the
               desired number of machines.
               Value can be an absolute number (ex: 5) or a percentage of
               desired machines (ex: 10%).
               This can not be 0 if MaxUnavailable is 0.
               Absolute number is calculated from percentage by rounding up.
               Defaults to 1.
               Example: when this is set to 30%, the new MachineSet can be scaled
               up immediately when the rolling update starts, such that the total
               number of old and new machines do not exceed 130% of desired
               machines. Once old machines have been killed, new MachineSet can
               be scaled up further, ensuring that total number of machines running
               at any time during the update is at most 130% of desired machines.
        :param 'GetMk8sV1alpha1NodeGroupStrategyMaxUnavailableArgs' max_unavailable: The maximum number of machines that can be unavailable during the update.
               Value can be an absolute number (ex: 5) or a percentage of desired
               machines (ex: 10%).
               Absolute number is calculated from percentage by rounding down.
               This can not be 0 if MaxSurge is 0.
               Defaults to 0.
               Example: when this is set to 30%, the old MachineSet can be scaled
               down to 70% of desired machines immediately when the rolling update
               starts. Once new machines are ready, old MachineSet can be scaled
               down further, followed by scaling up the new MachineSet, ensuring
               that the total number of machines available at all times
               during the update is at least 70% of desired machines.
        """
        pulumi.set(__self__, "drain_timeout", drain_timeout)
        pulumi.set(__self__, "max_surge", max_surge)
        pulumi.set(__self__, "max_unavailable", max_unavailable)

    @property
    @pulumi.getter(name="drainTimeout")
    def drain_timeout(self) -> builtins.str:
        """
        DrainTimeout is the total amount of time that the service will spend on draining a node.
        By default, node can be drained without any time limitations.
        NOTE: NodeDrainTimeout is different from `kubectl drain --timeout`

        Duration as a string: possibly signed sequence of decimal numbers, each with optional fraction and a unit suffix, such as `300ms`, `-1.5h` or `2h45m`. Valid time units are `ns`, `us` (or `µs`), `ms`, `s`, `m`, `h`, `d`.
        """
        return pulumi.get(self, "drain_timeout")

    @property
    @pulumi.getter(name="maxSurge")
    def max_surge(self) -> 'outputs.GetMk8sV1alpha1NodeGroupStrategyMaxSurgeResult':
        """
        The maximum number of machines that can be scheduled above the
        desired number of machines.
        Value can be an absolute number (ex: 5) or a percentage of
        desired machines (ex: 10%).
        This can not be 0 if MaxUnavailable is 0.
        Absolute number is calculated from percentage by rounding up.
        Defaults to 1.
        Example: when this is set to 30%, the new MachineSet can be scaled
        up immediately when the rolling update starts, such that the total
        number of old and new machines do not exceed 130% of desired
        machines. Once old machines have been killed, new MachineSet can
        be scaled up further, ensuring that total number of machines running
        at any time during the update is at most 130% of desired machines.
        """
        return pulumi.get(self, "max_surge")

    @property
    @pulumi.getter(name="maxUnavailable")
    def max_unavailable(self) -> 'outputs.GetMk8sV1alpha1NodeGroupStrategyMaxUnavailableResult':
        """
        The maximum number of machines that can be unavailable during the update.
        Value can be an absolute number (ex: 5) or a percentage of desired
        machines (ex: 10%).
        Absolute number is calculated from percentage by rounding down.
        This can not be 0 if MaxSurge is 0.
        Defaults to 0.
        Example: when this is set to 30%, the old MachineSet can be scaled
        down to 70% of desired machines immediately when the rolling update
        starts. Once new machines are ready, old MachineSet can be scaled
        down further, followed by scaling up the new MachineSet, ensuring
        that the total number of machines available at all times
        during the update is at least 70% of desired machines.
        """
        return pulumi.get(self, "max_unavailable")


@pulumi.output_type
class GetMk8sV1alpha1NodeGroupStrategyMaxSurgeResult(dict):
    def __init__(__self__, *,
                 count: builtins.float,
                 percent: builtins.float):
        """
        :param builtins.float count: *Cannot be set alongside percent.*
        :param builtins.float percent: *Cannot be set alongside count.*
        """
        pulumi.set(__self__, "count", count)
        pulumi.set(__self__, "percent", percent)

    @property
    @pulumi.getter
    def count(self) -> builtins.float:
        """
        *Cannot be set alongside percent.*
        """
        return pulumi.get(self, "count")

    @property
    @pulumi.getter
    def percent(self) -> builtins.float:
        """
        *Cannot be set alongside count.*
        """
        return pulumi.get(self, "percent")


@pulumi.output_type
class GetMk8sV1alpha1NodeGroupStrategyMaxUnavailableResult(dict):
    def __init__(__self__, *,
                 count: builtins.float,
                 percent: builtins.float):
        """
        :param builtins.float count: *Cannot be set alongside percent.*
        :param builtins.float percent: *Cannot be set alongside count.*
        """
        pulumi.set(__self__, "count", count)
        pulumi.set(__self__, "percent", percent)

    @property
    @pulumi.getter
    def count(self) -> builtins.float:
        """
        *Cannot be set alongside percent.*
        """
        return pulumi.get(self, "count")

    @property
    @pulumi.getter
    def percent(self) -> builtins.float:
        """
        *Cannot be set alongside count.*
        """
        return pulumi.get(self, "percent")


@pulumi.output_type
class GetMk8sV1alpha1NodeGroupTemplateResult(dict):
    def __init__(__self__, *,
                 boot_disk: 'outputs.GetMk8sV1alpha1NodeGroupTemplateBootDiskResult',
                 cloud_init_user_data: builtins.str,
                 filesystems: Sequence['outputs.GetMk8sV1alpha1NodeGroupTemplateFilesystemResult'],
                 gpu_cluster: 'outputs.GetMk8sV1alpha1NodeGroupTemplateGpuClusterResult',
                 gpu_settings: 'outputs.GetMk8sV1alpha1NodeGroupTemplateGpuSettingsResult',
                 metadata: 'outputs.GetMk8sV1alpha1NodeGroupTemplateMetadataResult',
                 network_interfaces: Sequence['outputs.GetMk8sV1alpha1NodeGroupTemplateNetworkInterfaceResult'],
                 resources: 'outputs.GetMk8sV1alpha1NodeGroupTemplateResourcesResult',
                 service_account_id: builtins.str,
                 taints: Sequence['outputs.GetMk8sV1alpha1NodeGroupTemplateTaintResult']):
        """
        :param builtins.str cloud_init_user_data: cloud-init user-data. Must contain at least one SSH key.
        :param 'GetMk8sV1alpha1NodeGroupTemplateGpuSettingsArgs' gpu_settings: GPU-related settings.
               
               ### Inner value description
               
               GPU-related settings.
        :param builtins.str service_account_id: the Nebius service account whose credentials will be available on the nodes of the group.
               With these credentials, it is possible to make `npc` or public API requests from the nodes without the need for extra authentication.
               This service account is also used to make requests to container registry.
               
               `resource.serviceaccount.issueAccessToken` permission is required to use this field.
        :param Sequence['GetMk8sV1alpha1NodeGroupTemplateTaintArgs'] taints: ### Inner value description
               
               See https://kubernetes.io/docs/concepts/scheduling-eviction/taint-and-toleration/
        """
        pulumi.set(__self__, "boot_disk", boot_disk)
        pulumi.set(__self__, "cloud_init_user_data", cloud_init_user_data)
        pulumi.set(__self__, "filesystems", filesystems)
        pulumi.set(__self__, "gpu_cluster", gpu_cluster)
        pulumi.set(__self__, "gpu_settings", gpu_settings)
        pulumi.set(__self__, "metadata", metadata)
        pulumi.set(__self__, "network_interfaces", network_interfaces)
        pulumi.set(__self__, "resources", resources)
        pulumi.set(__self__, "service_account_id", service_account_id)
        pulumi.set(__self__, "taints", taints)

    @property
    @pulumi.getter(name="bootDisk")
    def boot_disk(self) -> 'outputs.GetMk8sV1alpha1NodeGroupTemplateBootDiskResult':
        return pulumi.get(self, "boot_disk")

    @property
    @pulumi.getter(name="cloudInitUserData")
    def cloud_init_user_data(self) -> builtins.str:
        """
        cloud-init user-data. Must contain at least one SSH key.
        """
        return pulumi.get(self, "cloud_init_user_data")

    @property
    @pulumi.getter
    def filesystems(self) -> Sequence['outputs.GetMk8sV1alpha1NodeGroupTemplateFilesystemResult']:
        return pulumi.get(self, "filesystems")

    @property
    @pulumi.getter(name="gpuCluster")
    def gpu_cluster(self) -> 'outputs.GetMk8sV1alpha1NodeGroupTemplateGpuClusterResult':
        return pulumi.get(self, "gpu_cluster")

    @property
    @pulumi.getter(name="gpuSettings")
    def gpu_settings(self) -> 'outputs.GetMk8sV1alpha1NodeGroupTemplateGpuSettingsResult':
        """
        GPU-related settings.

        ### Inner value description

        GPU-related settings.
        """
        return pulumi.get(self, "gpu_settings")

    @property
    @pulumi.getter
    def metadata(self) -> 'outputs.GetMk8sV1alpha1NodeGroupTemplateMetadataResult':
        return pulumi.get(self, "metadata")

    @property
    @pulumi.getter(name="networkInterfaces")
    def network_interfaces(self) -> Sequence['outputs.GetMk8sV1alpha1NodeGroupTemplateNetworkInterfaceResult']:
        return pulumi.get(self, "network_interfaces")

    @property
    @pulumi.getter
    def resources(self) -> 'outputs.GetMk8sV1alpha1NodeGroupTemplateResourcesResult':
        return pulumi.get(self, "resources")

    @property
    @pulumi.getter(name="serviceAccountId")
    def service_account_id(self) -> builtins.str:
        """
        the Nebius service account whose credentials will be available on the nodes of the group.
        With these credentials, it is possible to make `npc` or public API requests from the nodes without the need for extra authentication.
        This service account is also used to make requests to container registry.

        `resource.serviceaccount.issueAccessToken` permission is required to use this field.
        """
        return pulumi.get(self, "service_account_id")

    @property
    @pulumi.getter
    def taints(self) -> Sequence['outputs.GetMk8sV1alpha1NodeGroupTemplateTaintResult']:
        """
        ### Inner value description

        See https://kubernetes.io/docs/concepts/scheduling-eviction/taint-and-toleration/
        """
        return pulumi.get(self, "taints")


@pulumi.output_type
class GetMk8sV1alpha1NodeGroupTemplateBootDiskResult(dict):
    def __init__(__self__, *,
                 block_size_bytes: builtins.float,
                 size_bytes: builtins.float,
                 size_gibibytes: builtins.float,
                 size_kibibytes: builtins.float,
                 size_mebibytes: builtins.float,
                 type: builtins.str):
        """
        :param builtins.float size_bytes: *Cannot be set alongside size_kibibytes or size_gibibytes.*
        :param builtins.float size_gibibytes: *Cannot be set alongside size_bytes or size_mebibytes.*
        :param builtins.float size_kibibytes: *Cannot be set alongside size_bytes or size_gibibytes.*
        :param builtins.float size_mebibytes: *Cannot be set alongside size_bytes or size_gibibytes.*
        :param builtins.str type: ### Supported values
               
               Possible values:
               
                - `UNSPECIFIED`
                - `NETWORK_SSD` - the list of available types will be clarified later, it is not final version
                - `NETWORK_HDD`
                - `NETWORK_SSD_IO_M3`
                - `NETWORK_SSD_NON_REPLICATED`
        """
        pulumi.set(__self__, "block_size_bytes", block_size_bytes)
        pulumi.set(__self__, "size_bytes", size_bytes)
        pulumi.set(__self__, "size_gibibytes", size_gibibytes)
        pulumi.set(__self__, "size_kibibytes", size_kibibytes)
        pulumi.set(__self__, "size_mebibytes", size_mebibytes)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter(name="blockSizeBytes")
    def block_size_bytes(self) -> builtins.float:
        return pulumi.get(self, "block_size_bytes")

    @property
    @pulumi.getter(name="sizeBytes")
    def size_bytes(self) -> builtins.float:
        """
        *Cannot be set alongside size_kibibytes or size_gibibytes.*
        """
        return pulumi.get(self, "size_bytes")

    @property
    @pulumi.getter(name="sizeGibibytes")
    def size_gibibytes(self) -> builtins.float:
        """
        *Cannot be set alongside size_bytes or size_mebibytes.*
        """
        return pulumi.get(self, "size_gibibytes")

    @property
    @pulumi.getter(name="sizeKibibytes")
    def size_kibibytes(self) -> builtins.float:
        """
        *Cannot be set alongside size_bytes or size_gibibytes.*
        """
        return pulumi.get(self, "size_kibibytes")

    @property
    @pulumi.getter(name="sizeMebibytes")
    def size_mebibytes(self) -> builtins.float:
        """
        *Cannot be set alongside size_bytes or size_gibibytes.*
        """
        return pulumi.get(self, "size_mebibytes")

    @property
    @pulumi.getter
    def type(self) -> builtins.str:
        """
        ### Supported values

        Possible values:

         - `UNSPECIFIED`
         - `NETWORK_SSD` - the list of available types will be clarified later, it is not final version
         - `NETWORK_HDD`
         - `NETWORK_SSD_IO_M3`
         - `NETWORK_SSD_NON_REPLICATED`
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class GetMk8sV1alpha1NodeGroupTemplateFilesystemResult(dict):
    def __init__(__self__, *,
                 attach_mode: builtins.str,
                 device_name: builtins.str,
                 existing_filesystem: 'outputs.GetMk8sV1alpha1NodeGroupTemplateFilesystemExistingFilesystemResult'):
        """
        :param builtins.str attach_mode: ### Supported values
               
               Possible values:
               
                - `UNSPECIFIED`
                - `READ_ONLY`
                - `READ_WRITE`
        """
        pulumi.set(__self__, "attach_mode", attach_mode)
        pulumi.set(__self__, "device_name", device_name)
        pulumi.set(__self__, "existing_filesystem", existing_filesystem)

    @property
    @pulumi.getter(name="attachMode")
    def attach_mode(self) -> builtins.str:
        """
        ### Supported values

        Possible values:

         - `UNSPECIFIED`
         - `READ_ONLY`
         - `READ_WRITE`
        """
        return pulumi.get(self, "attach_mode")

    @property
    @pulumi.getter(name="deviceName")
    def device_name(self) -> builtins.str:
        return pulumi.get(self, "device_name")

    @property
    @pulumi.getter(name="existingFilesystem")
    def existing_filesystem(self) -> 'outputs.GetMk8sV1alpha1NodeGroupTemplateFilesystemExistingFilesystemResult':
        return pulumi.get(self, "existing_filesystem")


@pulumi.output_type
class GetMk8sV1alpha1NodeGroupTemplateFilesystemExistingFilesystemResult(dict):
    def __init__(__self__, *,
                 id: builtins.str):
        pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> builtins.str:
        return pulumi.get(self, "id")


@pulumi.output_type
class GetMk8sV1alpha1NodeGroupTemplateGpuClusterResult(dict):
    def __init__(__self__, *,
                 id: builtins.str):
        pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> builtins.str:
        return pulumi.get(self, "id")


@pulumi.output_type
class GetMk8sV1alpha1NodeGroupTemplateGpuSettingsResult(dict):
    def __init__(__self__, *,
                 drivers_preset: builtins.str):
        """
        :param builtins.str drivers_preset: Identifier of the predefined set of drivers included in the ComputeImage deployed on ComputeInstances that are part of the NodeGroup.
               Supported presets: cuda12
        """
        pulumi.set(__self__, "drivers_preset", drivers_preset)

    @property
    @pulumi.getter(name="driversPreset")
    def drivers_preset(self) -> builtins.str:
        """
        Identifier of the predefined set of drivers included in the ComputeImage deployed on ComputeInstances that are part of the NodeGroup.
        Supported presets: cuda12
        """
        return pulumi.get(self, "drivers_preset")


@pulumi.output_type
class GetMk8sV1alpha1NodeGroupTemplateMetadataResult(dict):
    def __init__(__self__, *,
                 labels: Mapping[str, builtins.str]):
        """
        :param Mapping[str, builtins.str] labels: Labels will be propagated into nodes metadata.
               System labels containing "kubernetes.io" and "k8s.io" will not be propagated.
               On update labels they will not be updated in nodes right away, only on node group update.
        """
        pulumi.set(__self__, "labels", labels)

    @property
    @pulumi.getter
    def labels(self) -> Mapping[str, builtins.str]:
        """
        Labels will be propagated into nodes metadata.
        System labels containing "kubernetes.io" and "k8s.io" will not be propagated.
        On update labels they will not be updated in nodes right away, only on node group update.
        """
        return pulumi.get(self, "labels")


@pulumi.output_type
class GetMk8sV1alpha1NodeGroupTemplateNetworkInterfaceResult(dict):
    def __init__(__self__, *,
                 public_ip_address: 'outputs.GetMk8sV1alpha1NodeGroupTemplateNetworkInterfacePublicIpAddressResult',
                 subnet_id: builtins.str):
        """
        :param 'GetMk8sV1alpha1NodeGroupTemplateNetworkInterfacePublicIpAddressArgs' public_ip_address: Public IPv4 address associated with the interface.
               
               ### Inner value description
               
               Describes a public IP address.
        :param builtins.str subnet_id: Subnet ID that will be attached to a node cloud intstance network interface.
               By default control plane subnet_id used.
               Subnet should be located in the same network with control plane and have same parent ID as cluster.
        """
        pulumi.set(__self__, "public_ip_address", public_ip_address)
        pulumi.set(__self__, "subnet_id", subnet_id)

    @property
    @pulumi.getter(name="publicIpAddress")
    def public_ip_address(self) -> 'outputs.GetMk8sV1alpha1NodeGroupTemplateNetworkInterfacePublicIpAddressResult':
        """
        Public IPv4 address associated with the interface.

        ### Inner value description

        Describes a public IP address.
        """
        return pulumi.get(self, "public_ip_address")

    @property
    @pulumi.getter(name="subnetId")
    def subnet_id(self) -> builtins.str:
        """
        Subnet ID that will be attached to a node cloud intstance network interface.
        By default control plane subnet_id used.
        Subnet should be located in the same network with control plane and have same parent ID as cluster.
        """
        return pulumi.get(self, "subnet_id")


@pulumi.output_type
class GetMk8sV1alpha1NodeGroupTemplateNetworkInterfacePublicIpAddressResult(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class GetMk8sV1alpha1NodeGroupTemplateResourcesResult(dict):
    def __init__(__self__, *,
                 platform: builtins.str,
                 preset: builtins.str):
        pulumi.set(__self__, "platform", platform)
        pulumi.set(__self__, "preset", preset)

    @property
    @pulumi.getter
    def platform(self) -> builtins.str:
        return pulumi.get(self, "platform")

    @property
    @pulumi.getter
    def preset(self) -> builtins.str:
        return pulumi.get(self, "preset")


@pulumi.output_type
class GetMk8sV1alpha1NodeGroupTemplateTaintResult(dict):
    def __init__(__self__, *,
                 effect: builtins.str,
                 key: builtins.str,
                 value: builtins.str):
        """
        :param builtins.str effect: ### Supported values
               
               Possible values:
               
                - `EFFECT_UNSPECIFIED`
                - `NO_EXECUTE`
                - `NO_SCHEDULE`
                - `PREFER_NO_SCHEDULE`
        """
        pulumi.set(__self__, "effect", effect)
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def effect(self) -> builtins.str:
        """
        ### Supported values

        Possible values:

         - `EFFECT_UNSPECIFIED`
         - `NO_EXECUTE`
         - `NO_SCHEDULE`
         - `PREFER_NO_SCHEDULE`
        """
        return pulumi.get(self, "effect")

    @property
    @pulumi.getter
    def key(self) -> builtins.str:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def value(self) -> builtins.str:
        return pulumi.get(self, "value")


@pulumi.output_type
class GetMspMlflowV1alpha1ClusterMetadataResult(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class GetMspMlflowV1alpha1ClusterStatusResult(dict):
    def __init__(__self__, *,
                 effective_storage_bucket_name: builtins.str,
                 experiments_count: builtins.float,
                 mlflow_version: builtins.str,
                 phase: builtins.str,
                 state: builtins.str,
                 tracking_endpoint: builtins.str,
                 tracking_endpoints: 'outputs.GetMspMlflowV1alpha1ClusterStatusTrackingEndpointsResult'):
        """
        :param builtins.str effective_storage_bucket_name: Name of the Nebius S3 bucket for MLflow artifacts.
        :param builtins.float experiments_count: Count of experiments in the MLflow cluster
        :param builtins.str mlflow_version: MLflow version
        :param builtins.str phase: Current phase of the cluster.
               
               ### Supported values
               
               Possible values:
               
                - `PHASE_UNSPECIFIED`
                - `PHASE_PROVISIONING`
                - `PHASE_RUNNING`
                - `PHASE_UPDATING`
                - `PHASE_DELETING`
                - `PHASE_DELETED`
                - `PHASE_PURGING`
                - `PHASE_STOPPING`
                - `PHASE_RESUMING`
        :param builtins.str state: State reflects substatus of the phase to define whether it's healthy or not.
               
               ### Supported values
               
               Possible values:
               
                - `STATE_UNSPECIFIED`
                - `STATE_IN_PROGRESS`
                - `STATE_FINISHED`
                - `STATE_ERROR`
                - `STATE_DEGRADED`
                - `STATE_SCHEDULED`
        :param builtins.str tracking_endpoint: Tracking endpoint url.
               Will be removed soon in favor of private_tracking_endpoint and public_tracking_endpoint.
        :param 'GetMspMlflowV1alpha1ClusterStatusTrackingEndpointsArgs' tracking_endpoints: Public and private tracking endpoints
        """
        pulumi.set(__self__, "effective_storage_bucket_name", effective_storage_bucket_name)
        pulumi.set(__self__, "experiments_count", experiments_count)
        pulumi.set(__self__, "mlflow_version", mlflow_version)
        pulumi.set(__self__, "phase", phase)
        pulumi.set(__self__, "state", state)
        pulumi.set(__self__, "tracking_endpoint", tracking_endpoint)
        pulumi.set(__self__, "tracking_endpoints", tracking_endpoints)

    @property
    @pulumi.getter(name="effectiveStorageBucketName")
    def effective_storage_bucket_name(self) -> builtins.str:
        """
        Name of the Nebius S3 bucket for MLflow artifacts.
        """
        return pulumi.get(self, "effective_storage_bucket_name")

    @property
    @pulumi.getter(name="experimentsCount")
    def experiments_count(self) -> builtins.float:
        """
        Count of experiments in the MLflow cluster
        """
        return pulumi.get(self, "experiments_count")

    @property
    @pulumi.getter(name="mlflowVersion")
    def mlflow_version(self) -> builtins.str:
        """
        MLflow version
        """
        return pulumi.get(self, "mlflow_version")

    @property
    @pulumi.getter
    def phase(self) -> builtins.str:
        """
        Current phase of the cluster.

        ### Supported values

        Possible values:

         - `PHASE_UNSPECIFIED`
         - `PHASE_PROVISIONING`
         - `PHASE_RUNNING`
         - `PHASE_UPDATING`
         - `PHASE_DELETING`
         - `PHASE_DELETED`
         - `PHASE_PURGING`
         - `PHASE_STOPPING`
         - `PHASE_RESUMING`
        """
        return pulumi.get(self, "phase")

    @property
    @pulumi.getter
    def state(self) -> builtins.str:
        """
        State reflects substatus of the phase to define whether it's healthy or not.

        ### Supported values

        Possible values:

         - `STATE_UNSPECIFIED`
         - `STATE_IN_PROGRESS`
         - `STATE_FINISHED`
         - `STATE_ERROR`
         - `STATE_DEGRADED`
         - `STATE_SCHEDULED`
        """
        return pulumi.get(self, "state")

    @property
    @pulumi.getter(name="trackingEndpoint")
    def tracking_endpoint(self) -> builtins.str:
        """
        Tracking endpoint url.
        Will be removed soon in favor of private_tracking_endpoint and public_tracking_endpoint.
        """
        return pulumi.get(self, "tracking_endpoint")

    @property
    @pulumi.getter(name="trackingEndpoints")
    def tracking_endpoints(self) -> 'outputs.GetMspMlflowV1alpha1ClusterStatusTrackingEndpointsResult':
        """
        Public and private tracking endpoints
        """
        return pulumi.get(self, "tracking_endpoints")


@pulumi.output_type
class GetMspMlflowV1alpha1ClusterStatusTrackingEndpointsResult(dict):
    def __init__(__self__, *,
                 private: builtins.str,
                 public: builtins.str):
        """
        :param builtins.str private: Private endpoint
        :param builtins.str public: Public endpoint
        """
        pulumi.set(__self__, "private", private)
        pulumi.set(__self__, "public", public)

    @property
    @pulumi.getter
    def private(self) -> builtins.str:
        """
        Private endpoint
        """
        return pulumi.get(self, "private")

    @property
    @pulumi.getter
    def public(self) -> builtins.str:
        """
        Public endpoint
        """
        return pulumi.get(self, "public")


@pulumi.output_type
class GetMspPostgresqlV1alpha1ClusterBackupResult(dict):
    def __init__(__self__, *,
                 backup_window_start: builtins.str,
                 retention_policy: builtins.str):
        """
        :param builtins.str backup_window_start: Backup window start in "HH:MM:SS" format (UTC Time)
        :param builtins.str retention_policy: Retention policy to be used for backups and WALs (i.e. '7d')
        """
        pulumi.set(__self__, "backup_window_start", backup_window_start)
        pulumi.set(__self__, "retention_policy", retention_policy)

    @property
    @pulumi.getter(name="backupWindowStart")
    def backup_window_start(self) -> builtins.str:
        """
        Backup window start in "HH:MM:SS" format (UTC Time)
        """
        return pulumi.get(self, "backup_window_start")

    @property
    @pulumi.getter(name="retentionPolicy")
    def retention_policy(self) -> builtins.str:
        """
        Retention policy to be used for backups and WALs (i.e. '7d')
        """
        return pulumi.get(self, "retention_policy")


@pulumi.output_type
class GetMspPostgresqlV1alpha1ClusterBootstrapResult(dict):
    def __init__(__self__, *,
                 db_name: builtins.str,
                 user_name: builtins.str,
                 user_password: builtins.str):
        """
        :param builtins.str db_name: Name of the PostgreSQL database. 1-63 characters long.
        :param builtins.str user_name: Name of the bootstrap PostgreSQL user.
        :param builtins.str user_password: Password of the bootstrap PostgreSQL user.
        """
        pulumi.set(__self__, "db_name", db_name)
        pulumi.set(__self__, "user_name", user_name)
        pulumi.set(__self__, "user_password", user_password)

    @property
    @pulumi.getter(name="dbName")
    def db_name(self) -> builtins.str:
        """
        Name of the PostgreSQL database. 1-63 characters long.
        """
        return pulumi.get(self, "db_name")

    @property
    @pulumi.getter(name="userName")
    def user_name(self) -> builtins.str:
        """
        Name of the bootstrap PostgreSQL user.
        """
        return pulumi.get(self, "user_name")

    @property
    @pulumi.getter(name="userPassword")
    def user_password(self) -> builtins.str:
        """
        Password of the bootstrap PostgreSQL user.
        """
        return pulumi.get(self, "user_password")


@pulumi.output_type
class GetMspPostgresqlV1alpha1ClusterConfigResult(dict):
    def __init__(__self__, *,
                 pooler_config: 'outputs.GetMspPostgresqlV1alpha1ClusterConfigPoolerConfigResult',
                 postgresql_config16: 'outputs.GetMspPostgresqlV1alpha1ClusterConfigPostgresqlConfig16Result',
                 public_access: builtins.bool,
                 template: 'outputs.GetMspPostgresqlV1alpha1ClusterConfigTemplateResult',
                 version: builtins.str):
        """
        :param 'GetMspPostgresqlV1alpha1ClusterConfigPoolerConfigArgs' pooler_config: Configuration of the connection pooler.
        :param 'GetMspPostgresqlV1alpha1ClusterConfigPostgresqlConfig16Args' postgresql_config16: Configuration parameters for postgres
        :param builtins.bool public_access: Either make cluster public accessible or accessible only via private VPC.
        :param 'GetMspPostgresqlV1alpha1ClusterConfigTemplateArgs' template: Resources allocated to PostgreSQL hosts.
        :param builtins.str version: Version of PostgreSQL used in the cluster.
               Possible values: `16`
        """
        pulumi.set(__self__, "pooler_config", pooler_config)
        pulumi.set(__self__, "postgresql_config16", postgresql_config16)
        pulumi.set(__self__, "public_access", public_access)
        pulumi.set(__self__, "template", template)
        pulumi.set(__self__, "version", version)

    @property
    @pulumi.getter(name="poolerConfig")
    def pooler_config(self) -> 'outputs.GetMspPostgresqlV1alpha1ClusterConfigPoolerConfigResult':
        """
        Configuration of the connection pooler.
        """
        return pulumi.get(self, "pooler_config")

    @property
    @pulumi.getter(name="postgresqlConfig16")
    def postgresql_config16(self) -> 'outputs.GetMspPostgresqlV1alpha1ClusterConfigPostgresqlConfig16Result':
        """
        Configuration parameters for postgres
        """
        return pulumi.get(self, "postgresql_config16")

    @property
    @pulumi.getter(name="publicAccess")
    def public_access(self) -> builtins.bool:
        """
        Either make cluster public accessible or accessible only via private VPC.
        """
        return pulumi.get(self, "public_access")

    @property
    @pulumi.getter
    def template(self) -> 'outputs.GetMspPostgresqlV1alpha1ClusterConfigTemplateResult':
        """
        Resources allocated to PostgreSQL hosts.
        """
        return pulumi.get(self, "template")

    @property
    @pulumi.getter
    def version(self) -> builtins.str:
        """
        Version of PostgreSQL used in the cluster.
        Possible values: `16`
        """
        return pulumi.get(self, "version")


@pulumi.output_type
class GetMspPostgresqlV1alpha1ClusterConfigPoolerConfigResult(dict):
    def __init__(__self__, *,
                 max_pool_size: builtins.float,
                 pooling_mode: builtins.str):
        """
        :param builtins.float max_pool_size: Maximum number of connections in the pool for a single database.
        :param builtins.str pooling_mode: Mode that the connection pooler is working in.
               
               ### Supported values
               
               Possible values:
               
                - `POOLING_MODE_UNSPECIFIED`
                - `SESSION` - Session pooling mode.
                - `TRANSACTION` - Transaction pooling mode.
        """
        pulumi.set(__self__, "max_pool_size", max_pool_size)
        pulumi.set(__self__, "pooling_mode", pooling_mode)

    @property
    @pulumi.getter(name="maxPoolSize")
    def max_pool_size(self) -> builtins.float:
        """
        Maximum number of connections in the pool for a single database.
        """
        return pulumi.get(self, "max_pool_size")

    @property
    @pulumi.getter(name="poolingMode")
    def pooling_mode(self) -> builtins.str:
        """
        Mode that the connection pooler is working in.

        ### Supported values

        Possible values:

         - `POOLING_MODE_UNSPECIFIED`
         - `SESSION` - Session pooling mode.
         - `TRANSACTION` - Transaction pooling mode.
        """
        return pulumi.get(self, "pooling_mode")


@pulumi.output_type
class GetMspPostgresqlV1alpha1ClusterConfigPostgresqlConfig16Result(dict):
    def __init__(__self__, *,
                 autovacuum_analyze_scale_factor: builtins.float,
                 autovacuum_naptime: builtins.float,
                 autovacuum_vacuum_cost_delay: builtins.float,
                 autovacuum_vacuum_cost_limit: builtins.float,
                 autovacuum_vacuum_scale_factor: builtins.float,
                 autovacuum_work_mem: builtins.float,
                 default_transaction_read_only: builtins.bool,
                 idle_in_transaction_session_timeout: builtins.float,
                 max_connections: builtins.float,
                 search_path: builtins.str,
                 shared_buffers: builtins.float,
                 statement_timeout: builtins.float):
        """
        :param builtins.float autovacuum_naptime: in seconds.
        :param builtins.float autovacuum_vacuum_cost_delay: in milliseconds.
        :param builtins.float autovacuum_work_mem: in kilobytes.
        :param builtins.float idle_in_transaction_session_timeout: in milliseconds.
        :param builtins.float shared_buffers: in kilobytes.
        :param builtins.float statement_timeout: in milliseconds.
        """
        pulumi.set(__self__, "autovacuum_analyze_scale_factor", autovacuum_analyze_scale_factor)
        pulumi.set(__self__, "autovacuum_naptime", autovacuum_naptime)
        pulumi.set(__self__, "autovacuum_vacuum_cost_delay", autovacuum_vacuum_cost_delay)
        pulumi.set(__self__, "autovacuum_vacuum_cost_limit", autovacuum_vacuum_cost_limit)
        pulumi.set(__self__, "autovacuum_vacuum_scale_factor", autovacuum_vacuum_scale_factor)
        pulumi.set(__self__, "autovacuum_work_mem", autovacuum_work_mem)
        pulumi.set(__self__, "default_transaction_read_only", default_transaction_read_only)
        pulumi.set(__self__, "idle_in_transaction_session_timeout", idle_in_transaction_session_timeout)
        pulumi.set(__self__, "max_connections", max_connections)
        pulumi.set(__self__, "search_path", search_path)
        pulumi.set(__self__, "shared_buffers", shared_buffers)
        pulumi.set(__self__, "statement_timeout", statement_timeout)

    @property
    @pulumi.getter(name="autovacuumAnalyzeScaleFactor")
    def autovacuum_analyze_scale_factor(self) -> builtins.float:
        return pulumi.get(self, "autovacuum_analyze_scale_factor")

    @property
    @pulumi.getter(name="autovacuumNaptime")
    def autovacuum_naptime(self) -> builtins.float:
        """
        in seconds.
        """
        return pulumi.get(self, "autovacuum_naptime")

    @property
    @pulumi.getter(name="autovacuumVacuumCostDelay")
    def autovacuum_vacuum_cost_delay(self) -> builtins.float:
        """
        in milliseconds.
        """
        return pulumi.get(self, "autovacuum_vacuum_cost_delay")

    @property
    @pulumi.getter(name="autovacuumVacuumCostLimit")
    def autovacuum_vacuum_cost_limit(self) -> builtins.float:
        return pulumi.get(self, "autovacuum_vacuum_cost_limit")

    @property
    @pulumi.getter(name="autovacuumVacuumScaleFactor")
    def autovacuum_vacuum_scale_factor(self) -> builtins.float:
        return pulumi.get(self, "autovacuum_vacuum_scale_factor")

    @property
    @pulumi.getter(name="autovacuumWorkMem")
    def autovacuum_work_mem(self) -> builtins.float:
        """
        in kilobytes.
        """
        return pulumi.get(self, "autovacuum_work_mem")

    @property
    @pulumi.getter(name="defaultTransactionReadOnly")
    def default_transaction_read_only(self) -> builtins.bool:
        return pulumi.get(self, "default_transaction_read_only")

    @property
    @pulumi.getter(name="idleInTransactionSessionTimeout")
    def idle_in_transaction_session_timeout(self) -> builtins.float:
        """
        in milliseconds.
        """
        return pulumi.get(self, "idle_in_transaction_session_timeout")

    @property
    @pulumi.getter(name="maxConnections")
    def max_connections(self) -> builtins.float:
        return pulumi.get(self, "max_connections")

    @property
    @pulumi.getter(name="searchPath")
    def search_path(self) -> builtins.str:
        return pulumi.get(self, "search_path")

    @property
    @pulumi.getter(name="sharedBuffers")
    def shared_buffers(self) -> builtins.float:
        """
        in kilobytes.
        """
        return pulumi.get(self, "shared_buffers")

    @property
    @pulumi.getter(name="statementTimeout")
    def statement_timeout(self) -> builtins.float:
        """
        in milliseconds.
        """
        return pulumi.get(self, "statement_timeout")


@pulumi.output_type
class GetMspPostgresqlV1alpha1ClusterConfigTemplateResult(dict):
    def __init__(__self__, *,
                 disk: 'outputs.GetMspPostgresqlV1alpha1ClusterConfigTemplateDiskResult',
                 hosts: 'outputs.GetMspPostgresqlV1alpha1ClusterConfigTemplateHostsResult',
                 resources: 'outputs.GetMspPostgresqlV1alpha1ClusterConfigTemplateResourcesResult'):
        """
        :param 'GetMspPostgresqlV1alpha1ClusterConfigTemplateResourcesArgs' resources: reduced msp.v1alpha1.resource.TemplateSpec
        """
        pulumi.set(__self__, "disk", disk)
        pulumi.set(__self__, "hosts", hosts)
        pulumi.set(__self__, "resources", resources)

    @property
    @pulumi.getter
    def disk(self) -> 'outputs.GetMspPostgresqlV1alpha1ClusterConfigTemplateDiskResult':
        return pulumi.get(self, "disk")

    @property
    @pulumi.getter
    def hosts(self) -> 'outputs.GetMspPostgresqlV1alpha1ClusterConfigTemplateHostsResult':
        return pulumi.get(self, "hosts")

    @property
    @pulumi.getter
    def resources(self) -> 'outputs.GetMspPostgresqlV1alpha1ClusterConfigTemplateResourcesResult':
        """
        reduced msp.v1alpha1.resource.TemplateSpec
        """
        return pulumi.get(self, "resources")


@pulumi.output_type
class GetMspPostgresqlV1alpha1ClusterConfigTemplateDiskResult(dict):
    def __init__(__self__, *,
                 size_gibibytes: builtins.float,
                 type: builtins.str):
        pulumi.set(__self__, "size_gibibytes", size_gibibytes)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter(name="sizeGibibytes")
    def size_gibibytes(self) -> builtins.float:
        return pulumi.get(self, "size_gibibytes")

    @property
    @pulumi.getter
    def type(self) -> builtins.str:
        return pulumi.get(self, "type")


@pulumi.output_type
class GetMspPostgresqlV1alpha1ClusterConfigTemplateHostsResult(dict):
    def __init__(__self__, *,
                 count: builtins.float):
        pulumi.set(__self__, "count", count)

    @property
    @pulumi.getter
    def count(self) -> builtins.float:
        return pulumi.get(self, "count")


@pulumi.output_type
class GetMspPostgresqlV1alpha1ClusterConfigTemplateResourcesResult(dict):
    def __init__(__self__, *,
                 platform: builtins.str,
                 preset: builtins.str):
        pulumi.set(__self__, "platform", platform)
        pulumi.set(__self__, "preset", preset)

    @property
    @pulumi.getter
    def platform(self) -> builtins.str:
        return pulumi.get(self, "platform")

    @property
    @pulumi.getter
    def preset(self) -> builtins.str:
        return pulumi.get(self, "preset")


@pulumi.output_type
class GetMspPostgresqlV1alpha1ClusterMetadataResult(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class GetMspPostgresqlV1alpha1ClusterStatusResult(dict):
    def __init__(__self__, *,
                 connection_endpoints: 'outputs.GetMspPostgresqlV1alpha1ClusterStatusConnectionEndpointsResult',
                 phase: builtins.str,
                 preset_details: 'outputs.GetMspPostgresqlV1alpha1ClusterStatusPresetDetailsResult',
                 state: builtins.str):
        """
        :param 'GetMspPostgresqlV1alpha1ClusterStatusConnectionEndpointsArgs' connection_endpoints: Connection endpoints of the PostgreSQL cluster.
        :param builtins.str phase: Current phase of the cluster.
               
               ### Supported values
               
               Possible values:
               
                - `PHASE_UNSPECIFIED`
                - `PHASE_PROVISIONING`
                - `PHASE_RUNNING`
                - `PHASE_UPDATING`
                - `PHASE_DELETING`
                - `PHASE_DELETED`
                - `PHASE_PURGING`
                - `PHASE_STOPPING`
                - `PHASE_RESUMING`
        :param 'GetMspPostgresqlV1alpha1ClusterStatusPresetDetailsArgs' preset_details: Cluster resource preset details
        :param builtins.str state: State reflects substatus of the phase to define whether it's healthy or not.
               
               ### Supported values
               
               Possible values:
               
                - `STATE_UNSPECIFIED`
                - `STATE_IN_PROGRESS`
                - `STATE_FINISHED`
                - `STATE_ERROR`
                - `STATE_DEGRADED`
                - `STATE_SCHEDULED`
        """
        pulumi.set(__self__, "connection_endpoints", connection_endpoints)
        pulumi.set(__self__, "phase", phase)
        pulumi.set(__self__, "preset_details", preset_details)
        pulumi.set(__self__, "state", state)

    @property
    @pulumi.getter(name="connectionEndpoints")
    def connection_endpoints(self) -> 'outputs.GetMspPostgresqlV1alpha1ClusterStatusConnectionEndpointsResult':
        """
        Connection endpoints of the PostgreSQL cluster.
        """
        return pulumi.get(self, "connection_endpoints")

    @property
    @pulumi.getter
    def phase(self) -> builtins.str:
        """
        Current phase of the cluster.

        ### Supported values

        Possible values:

         - `PHASE_UNSPECIFIED`
         - `PHASE_PROVISIONING`
         - `PHASE_RUNNING`
         - `PHASE_UPDATING`
         - `PHASE_DELETING`
         - `PHASE_DELETED`
         - `PHASE_PURGING`
         - `PHASE_STOPPING`
         - `PHASE_RESUMING`
        """
        return pulumi.get(self, "phase")

    @property
    @pulumi.getter(name="presetDetails")
    def preset_details(self) -> 'outputs.GetMspPostgresqlV1alpha1ClusterStatusPresetDetailsResult':
        """
        Cluster resource preset details
        """
        return pulumi.get(self, "preset_details")

    @property
    @pulumi.getter
    def state(self) -> builtins.str:
        """
        State reflects substatus of the phase to define whether it's healthy or not.

        ### Supported values

        Possible values:

         - `STATE_UNSPECIFIED`
         - `STATE_IN_PROGRESS`
         - `STATE_FINISHED`
         - `STATE_ERROR`
         - `STATE_DEGRADED`
         - `STATE_SCHEDULED`
        """
        return pulumi.get(self, "state")


@pulumi.output_type
class GetMspPostgresqlV1alpha1ClusterStatusConnectionEndpointsResult(dict):
    def __init__(__self__, *,
                 private_read_only: builtins.str,
                 private_read_write: builtins.str,
                 public_read_only: builtins.str,
                 public_read_write: builtins.str):
        """
        :param builtins.str private_read_only: Read only endpoint of the PostgreSQL cluster accessible from the private VPC.
        :param builtins.str private_read_write: Read write endpoint of the PostgreSQL cluster accessible from the private VPC.
        :param builtins.str public_read_only: Read only endpoint of the PostgreSQL cluster accessible from the internet.
        :param builtins.str public_read_write: Read write endpoint of the PostgreSQL cluster accessible from the internet.
        """
        pulumi.set(__self__, "private_read_only", private_read_only)
        pulumi.set(__self__, "private_read_write", private_read_write)
        pulumi.set(__self__, "public_read_only", public_read_only)
        pulumi.set(__self__, "public_read_write", public_read_write)

    @property
    @pulumi.getter(name="privateReadOnly")
    def private_read_only(self) -> builtins.str:
        """
        Read only endpoint of the PostgreSQL cluster accessible from the private VPC.
        """
        return pulumi.get(self, "private_read_only")

    @property
    @pulumi.getter(name="privateReadWrite")
    def private_read_write(self) -> builtins.str:
        """
        Read write endpoint of the PostgreSQL cluster accessible from the private VPC.
        """
        return pulumi.get(self, "private_read_write")

    @property
    @pulumi.getter(name="publicReadOnly")
    def public_read_only(self) -> builtins.str:
        """
        Read only endpoint of the PostgreSQL cluster accessible from the internet.
        """
        return pulumi.get(self, "public_read_only")

    @property
    @pulumi.getter(name="publicReadWrite")
    def public_read_write(self) -> builtins.str:
        """
        Read write endpoint of the PostgreSQL cluster accessible from the internet.
        """
        return pulumi.get(self, "public_read_write")


@pulumi.output_type
class GetMspPostgresqlV1alpha1ClusterStatusPresetDetailsResult(dict):
    def __init__(__self__, *,
                 cpu_count: builtins.float,
                 gpu_count: builtins.float,
                 memory_gibibytes: builtins.float):
        pulumi.set(__self__, "cpu_count", cpu_count)
        pulumi.set(__self__, "gpu_count", gpu_count)
        pulumi.set(__self__, "memory_gibibytes", memory_gibibytes)

    @property
    @pulumi.getter(name="cpuCount")
    def cpu_count(self) -> builtins.float:
        return pulumi.get(self, "cpu_count")

    @property
    @pulumi.getter(name="gpuCount")
    def gpu_count(self) -> builtins.float:
        return pulumi.get(self, "gpu_count")

    @property
    @pulumi.getter(name="memoryGibibytes")
    def memory_gibibytes(self) -> builtins.float:
        return pulumi.get(self, "memory_gibibytes")


@pulumi.output_type
class GetMspSparkV1alpha1ClusterAuthorizationResult(dict):
    def __init__(__self__, *,
                 password: builtins.str):
        pulumi.set(__self__, "password", password)

    @property
    @pulumi.getter
    def password(self) -> builtins.str:
        return pulumi.get(self, "password")


@pulumi.output_type
class GetMspSparkV1alpha1ClusterLimitsResult(dict):
    def __init__(__self__, *,
                 cpu: builtins.float,
                 memory_gibibytes: builtins.float):
        pulumi.set(__self__, "cpu", cpu)
        pulumi.set(__self__, "memory_gibibytes", memory_gibibytes)

    @property
    @pulumi.getter
    def cpu(self) -> builtins.float:
        return pulumi.get(self, "cpu")

    @property
    @pulumi.getter(name="memoryGibibytes")
    def memory_gibibytes(self) -> builtins.float:
        return pulumi.get(self, "memory_gibibytes")


@pulumi.output_type
class GetMspSparkV1alpha1ClusterMetadataResult(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class GetMspSparkV1alpha1ClusterStatusResult(dict):
    def __init__(__self__, *,
                 history_server_endpoint: builtins.str,
                 phase: builtins.str,
                 state: builtins.str):
        """
        :param builtins.str history_server_endpoint: History Server WebUI endpoint
        :param builtins.str phase: Current phase (or stage) of the cluster.
               
               ### Supported values
               
               Possible values:
               
                - `PHASE_UNSPECIFIED`
                - `PHASE_PROVISIONING`
                - `PHASE_RUNNING`
                - `PHASE_UPDATING`
                - `PHASE_DELETING`
                - `PHASE_DELETED`
                - `PHASE_PURGING`
                - `PHASE_STOPPING`
                - `PHASE_RESUMING`
        :param builtins.str state: State reflects substatus of the stage to define whether it's healthy or not.
               
               ### Supported values
               
               Possible values:
               
                - `STATE_UNSPECIFIED`
                - `STATE_IN_PROGRESS`
                - `STATE_FINISHED`
                - `STATE_ERROR`
                - `STATE_DEGRADED`
                - `STATE_SCHEDULED`
        """
        pulumi.set(__self__, "history_server_endpoint", history_server_endpoint)
        pulumi.set(__self__, "phase", phase)
        pulumi.set(__self__, "state", state)

    @property
    @pulumi.getter(name="historyServerEndpoint")
    def history_server_endpoint(self) -> builtins.str:
        """
        History Server WebUI endpoint
        """
        return pulumi.get(self, "history_server_endpoint")

    @property
    @pulumi.getter
    def phase(self) -> builtins.str:
        """
        Current phase (or stage) of the cluster.

        ### Supported values

        Possible values:

         - `PHASE_UNSPECIFIED`
         - `PHASE_PROVISIONING`
         - `PHASE_RUNNING`
         - `PHASE_UPDATING`
         - `PHASE_DELETING`
         - `PHASE_DELETED`
         - `PHASE_PURGING`
         - `PHASE_STOPPING`
         - `PHASE_RESUMING`
        """
        return pulumi.get(self, "phase")

    @property
    @pulumi.getter
    def state(self) -> builtins.str:
        """
        State reflects substatus of the stage to define whether it's healthy or not.

        ### Supported values

        Possible values:

         - `STATE_UNSPECIFIED`
         - `STATE_IN_PROGRESS`
         - `STATE_FINISHED`
         - `STATE_ERROR`
         - `STATE_DEGRADED`
         - `STATE_SCHEDULED`
        """
        return pulumi.get(self, "state")


@pulumi.output_type
class GetMspSparkV1alpha1SessionDriverResult(dict):
    def __init__(__self__, *,
                 disk: 'outputs.GetMspSparkV1alpha1SessionDriverDiskResult',
                 resources: 'outputs.GetMspSparkV1alpha1SessionDriverResourcesResult'):
        pulumi.set(__self__, "disk", disk)
        pulumi.set(__self__, "resources", resources)

    @property
    @pulumi.getter
    def disk(self) -> 'outputs.GetMspSparkV1alpha1SessionDriverDiskResult':
        return pulumi.get(self, "disk")

    @property
    @pulumi.getter
    def resources(self) -> 'outputs.GetMspSparkV1alpha1SessionDriverResourcesResult':
        return pulumi.get(self, "resources")


@pulumi.output_type
class GetMspSparkV1alpha1SessionDriverDiskResult(dict):
    def __init__(__self__, *,
                 size_gibibytes: builtins.float,
                 type: builtins.str):
        pulumi.set(__self__, "size_gibibytes", size_gibibytes)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter(name="sizeGibibytes")
    def size_gibibytes(self) -> builtins.float:
        return pulumi.get(self, "size_gibibytes")

    @property
    @pulumi.getter
    def type(self) -> builtins.str:
        return pulumi.get(self, "type")


@pulumi.output_type
class GetMspSparkV1alpha1SessionDriverResourcesResult(dict):
    def __init__(__self__, *,
                 platform: builtins.str,
                 preset: builtins.str):
        pulumi.set(__self__, "platform", platform)
        pulumi.set(__self__, "preset", preset)

    @property
    @pulumi.getter
    def platform(self) -> builtins.str:
        return pulumi.get(self, "platform")

    @property
    @pulumi.getter
    def preset(self) -> builtins.str:
        return pulumi.get(self, "preset")


@pulumi.output_type
class GetMspSparkV1alpha1SessionExecutorResult(dict):
    def __init__(__self__, *,
                 disk: 'outputs.GetMspSparkV1alpha1SessionExecutorDiskResult',
                 hosts: 'outputs.GetMspSparkV1alpha1SessionExecutorHostsResult',
                 hosts_dynamic_allocation: 'outputs.GetMspSparkV1alpha1SessionExecutorHostsDynamicAllocationResult',
                 resources: 'outputs.GetMspSparkV1alpha1SessionExecutorResourcesResult'):
        """
        :param 'GetMspSparkV1alpha1SessionExecutorHostsArgs' hosts: *Cannot be set alongside hosts_dynamic_allocation.*
        :param 'GetMspSparkV1alpha1SessionExecutorHostsDynamicAllocationArgs' hosts_dynamic_allocation: *Cannot be set alongside hosts.*
        """
        pulumi.set(__self__, "disk", disk)
        pulumi.set(__self__, "hosts", hosts)
        pulumi.set(__self__, "hosts_dynamic_allocation", hosts_dynamic_allocation)
        pulumi.set(__self__, "resources", resources)

    @property
    @pulumi.getter
    def disk(self) -> 'outputs.GetMspSparkV1alpha1SessionExecutorDiskResult':
        return pulumi.get(self, "disk")

    @property
    @pulumi.getter
    def hosts(self) -> 'outputs.GetMspSparkV1alpha1SessionExecutorHostsResult':
        """
        *Cannot be set alongside hosts_dynamic_allocation.*
        """
        return pulumi.get(self, "hosts")

    @property
    @pulumi.getter(name="hostsDynamicAllocation")
    def hosts_dynamic_allocation(self) -> 'outputs.GetMspSparkV1alpha1SessionExecutorHostsDynamicAllocationResult':
        """
        *Cannot be set alongside hosts.*
        """
        return pulumi.get(self, "hosts_dynamic_allocation")

    @property
    @pulumi.getter
    def resources(self) -> 'outputs.GetMspSparkV1alpha1SessionExecutorResourcesResult':
        return pulumi.get(self, "resources")


@pulumi.output_type
class GetMspSparkV1alpha1SessionExecutorDiskResult(dict):
    def __init__(__self__, *,
                 size_gibibytes: builtins.float,
                 type: builtins.str):
        pulumi.set(__self__, "size_gibibytes", size_gibibytes)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter(name="sizeGibibytes")
    def size_gibibytes(self) -> builtins.float:
        return pulumi.get(self, "size_gibibytes")

    @property
    @pulumi.getter
    def type(self) -> builtins.str:
        return pulumi.get(self, "type")


@pulumi.output_type
class GetMspSparkV1alpha1SessionExecutorHostsResult(dict):
    def __init__(__self__, *,
                 count: builtins.float):
        pulumi.set(__self__, "count", count)

    @property
    @pulumi.getter
    def count(self) -> builtins.float:
        return pulumi.get(self, "count")


@pulumi.output_type
class GetMspSparkV1alpha1SessionExecutorHostsDynamicAllocationResult(dict):
    def __init__(__self__, *,
                 max: builtins.float,
                 min: builtins.float):
        pulumi.set(__self__, "max", max)
        pulumi.set(__self__, "min", min)

    @property
    @pulumi.getter
    def max(self) -> builtins.float:
        return pulumi.get(self, "max")

    @property
    @pulumi.getter
    def min(self) -> builtins.float:
        return pulumi.get(self, "min")


@pulumi.output_type
class GetMspSparkV1alpha1SessionExecutorResourcesResult(dict):
    def __init__(__self__, *,
                 platform: builtins.str,
                 preset: builtins.str):
        pulumi.set(__self__, "platform", platform)
        pulumi.set(__self__, "preset", preset)

    @property
    @pulumi.getter
    def platform(self) -> builtins.str:
        return pulumi.get(self, "platform")

    @property
    @pulumi.getter
    def preset(self) -> builtins.str:
        return pulumi.get(self, "preset")


@pulumi.output_type
class GetMspSparkV1alpha1SessionMetadataResult(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class GetMspSparkV1alpha1SessionPythonResult(dict):
    def __init__(__self__, *,
                 file_uris: Sequence[builtins.str],
                 requirements: Sequence[builtins.str]):
        """
        :param Sequence[builtins.str] file_uris: S3 URIs of files to be placed in PYTHONPATH of driver and executors for python applications (.py, .zip, .egg)
        :param Sequence[builtins.str] requirements: Python requirements
        """
        pulumi.set(__self__, "file_uris", file_uris)
        pulumi.set(__self__, "requirements", requirements)

    @property
    @pulumi.getter(name="fileUris")
    def file_uris(self) -> Sequence[builtins.str]:
        """
        S3 URIs of files to be placed in PYTHONPATH of driver and executors for python applications (.py, .zip, .egg)
        """
        return pulumi.get(self, "file_uris")

    @property
    @pulumi.getter
    def requirements(self) -> Sequence[builtins.str]:
        """
        Python requirements
        """
        return pulumi.get(self, "requirements")


@pulumi.output_type
class GetMspSparkV1alpha1SessionStatusResult(dict):
    def __init__(__self__, *,
                 driver_preset_details: 'outputs.GetMspSparkV1alpha1SessionStatusDriverPresetDetailsResult',
                 executor_preset_details: 'outputs.GetMspSparkV1alpha1SessionStatusExecutorPresetDetailsResult',
                 phase: builtins.str,
                 spark_connect_endpoint: builtins.str,
                 state: builtins.str):
        """
        :param 'GetMspSparkV1alpha1SessionStatusDriverPresetDetailsArgs' driver_preset_details: Session driver resource preset details
        :param 'GetMspSparkV1alpha1SessionStatusExecutorPresetDetailsArgs' executor_preset_details: Session executor resource preset details
        :param builtins.str phase: Current phase (or stage) of the cluster.
               
               ### Supported values
               
               Possible values:
               
                - `PHASE_UNSPECIFIED`
                - `PHASE_PROVISIONING`
                - `PHASE_RUNNING`
                - `PHASE_UPDATING`
                - `PHASE_DELETING`
                - `PHASE_DELETED`
                - `PHASE_PURGING`
                - `PHASE_STOPPING`
                - `PHASE_RESUMING`
        :param builtins.str spark_connect_endpoint: Spark Connect endpoint
        :param builtins.str state: State reflects substatus of the stage to define whether it's healthy or not.
               
               ### Supported values
               
               Possible values:
               
                - `STATE_UNSPECIFIED`
                - `STATE_IN_PROGRESS`
                - `STATE_FINISHED`
                - `STATE_ERROR`
                - `STATE_DEGRADED`
                - `STATE_SCHEDULED`
        """
        pulumi.set(__self__, "driver_preset_details", driver_preset_details)
        pulumi.set(__self__, "executor_preset_details", executor_preset_details)
        pulumi.set(__self__, "phase", phase)
        pulumi.set(__self__, "spark_connect_endpoint", spark_connect_endpoint)
        pulumi.set(__self__, "state", state)

    @property
    @pulumi.getter(name="driverPresetDetails")
    def driver_preset_details(self) -> 'outputs.GetMspSparkV1alpha1SessionStatusDriverPresetDetailsResult':
        """
        Session driver resource preset details
        """
        return pulumi.get(self, "driver_preset_details")

    @property
    @pulumi.getter(name="executorPresetDetails")
    def executor_preset_details(self) -> 'outputs.GetMspSparkV1alpha1SessionStatusExecutorPresetDetailsResult':
        """
        Session executor resource preset details
        """
        return pulumi.get(self, "executor_preset_details")

    @property
    @pulumi.getter
    def phase(self) -> builtins.str:
        """
        Current phase (or stage) of the cluster.

        ### Supported values

        Possible values:

         - `PHASE_UNSPECIFIED`
         - `PHASE_PROVISIONING`
         - `PHASE_RUNNING`
         - `PHASE_UPDATING`
         - `PHASE_DELETING`
         - `PHASE_DELETED`
         - `PHASE_PURGING`
         - `PHASE_STOPPING`
         - `PHASE_RESUMING`
        """
        return pulumi.get(self, "phase")

    @property
    @pulumi.getter(name="sparkConnectEndpoint")
    def spark_connect_endpoint(self) -> builtins.str:
        """
        Spark Connect endpoint
        """
        return pulumi.get(self, "spark_connect_endpoint")

    @property
    @pulumi.getter
    def state(self) -> builtins.str:
        """
        State reflects substatus of the stage to define whether it's healthy or not.

        ### Supported values

        Possible values:

         - `STATE_UNSPECIFIED`
         - `STATE_IN_PROGRESS`
         - `STATE_FINISHED`
         - `STATE_ERROR`
         - `STATE_DEGRADED`
         - `STATE_SCHEDULED`
        """
        return pulumi.get(self, "state")


@pulumi.output_type
class GetMspSparkV1alpha1SessionStatusDriverPresetDetailsResult(dict):
    def __init__(__self__, *,
                 cpu_count: builtins.float,
                 gpu_count: builtins.float,
                 memory_gibibytes: builtins.float):
        pulumi.set(__self__, "cpu_count", cpu_count)
        pulumi.set(__self__, "gpu_count", gpu_count)
        pulumi.set(__self__, "memory_gibibytes", memory_gibibytes)

    @property
    @pulumi.getter(name="cpuCount")
    def cpu_count(self) -> builtins.float:
        return pulumi.get(self, "cpu_count")

    @property
    @pulumi.getter(name="gpuCount")
    def gpu_count(self) -> builtins.float:
        return pulumi.get(self, "gpu_count")

    @property
    @pulumi.getter(name="memoryGibibytes")
    def memory_gibibytes(self) -> builtins.float:
        return pulumi.get(self, "memory_gibibytes")


@pulumi.output_type
class GetMspSparkV1alpha1SessionStatusExecutorPresetDetailsResult(dict):
    def __init__(__self__, *,
                 cpu_count: builtins.float,
                 gpu_count: builtins.float,
                 memory_gibibytes: builtins.float):
        pulumi.set(__self__, "cpu_count", cpu_count)
        pulumi.set(__self__, "gpu_count", gpu_count)
        pulumi.set(__self__, "memory_gibibytes", memory_gibibytes)

    @property
    @pulumi.getter(name="cpuCount")
    def cpu_count(self) -> builtins.float:
        return pulumi.get(self, "cpu_count")

    @property
    @pulumi.getter(name="gpuCount")
    def gpu_count(self) -> builtins.float:
        return pulumi.get(self, "gpu_count")

    @property
    @pulumi.getter(name="memoryGibibytes")
    def memory_gibibytes(self) -> builtins.float:
        return pulumi.get(self, "memory_gibibytes")


@pulumi.output_type
class GetRegistryV1RegistryMetadataResult(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class GetRegistryV1RegistryStatusResult(dict):
    def __init__(__self__, *,
                 images_count: builtins.float,
                 registry_fqdn: builtins.str,
                 state: builtins.str):
        """
        :param builtins.str registry_fqdn: regional fqdn "cr.eu-north1.nebius.cloud"
        :param builtins.str state: ### Supported values
               
               Possible values:
               
                - `CREATING`
                - `ACTIVE`
                - `DELETING`
                - `SUSPENDED`
        """
        pulumi.set(__self__, "images_count", images_count)
        pulumi.set(__self__, "registry_fqdn", registry_fqdn)
        pulumi.set(__self__, "state", state)

    @property
    @pulumi.getter(name="imagesCount")
    def images_count(self) -> builtins.float:
        return pulumi.get(self, "images_count")

    @property
    @pulumi.getter(name="registryFqdn")
    def registry_fqdn(self) -> builtins.str:
        """
        regional fqdn "cr.eu-north1.nebius.cloud"
        """
        return pulumi.get(self, "registry_fqdn")

    @property
    @pulumi.getter
    def state(self) -> builtins.str:
        """
        ### Supported values

        Possible values:

         - `CREATING`
         - `ACTIVE`
         - `DELETING`
         - `SUSPENDED`
        """
        return pulumi.get(self, "state")


@pulumi.output_type
class GetStorageV1BucketLifecycleConfigurationResult(dict):
    def __init__(__self__, *,
                 rules: Sequence['outputs.GetStorageV1BucketLifecycleConfigurationRuleResult']):
        pulumi.set(__self__, "rules", rules)

    @property
    @pulumi.getter
    def rules(self) -> Sequence['outputs.GetStorageV1BucketLifecycleConfigurationRuleResult']:
        return pulumi.get(self, "rules")


@pulumi.output_type
class GetStorageV1BucketLifecycleConfigurationRuleResult(dict):
    def __init__(__self__, *,
                 abort_incomplete_multipart_upload: 'outputs.GetStorageV1BucketLifecycleConfigurationRuleAbortIncompleteMultipartUploadResult',
                 expiration: 'outputs.GetStorageV1BucketLifecycleConfigurationRuleExpirationResult',
                 filter: 'outputs.GetStorageV1BucketLifecycleConfigurationRuleFilterResult',
                 id: builtins.str,
                 noncurrent_version_expiration: 'outputs.GetStorageV1BucketLifecycleConfigurationRuleNoncurrentVersionExpirationResult',
                 status: builtins.str):
        """
        :param 'GetStorageV1BucketLifecycleConfigurationRuleAbortIncompleteMultipartUploadArgs' abort_incomplete_multipart_upload: Specifies the days since the initiation of an incomplete multipart upload that
               the system will wait before permanently removing all parts of the upload.
        :param 'GetStorageV1BucketLifecycleConfigurationRuleExpirationArgs' expiration: Specifies the expiration for the lifecycle of the object in the form of date, days and,
               whether the object has a delete marker.
        :param 'GetStorageV1BucketLifecycleConfigurationRuleFilterArgs' filter: The Filter is used to identify objects that a Lifecycle Rule applies to.
               The Lifecycle Rule will apply to any object matching all of the predicates
               configured inside (using logical AND).
        :param builtins.str id: Unique identifier for the rule per configuration.
               The value cannot be longer than 255 characters.
        :param 'GetStorageV1BucketLifecycleConfigurationRuleNoncurrentVersionExpirationArgs' noncurrent_version_expiration: Specifies when noncurrent object versions expire.
               It works only on a bucket that has versioning enabled (or suspended).
        :param builtins.str status: ### Supported values
               
               Possible values:
               
                - `STATUS_UNSPECIFIED`
                - `ENABLED`
                - `DISABLED`
        """
        pulumi.set(__self__, "abort_incomplete_multipart_upload", abort_incomplete_multipart_upload)
        pulumi.set(__self__, "expiration", expiration)
        pulumi.set(__self__, "filter", filter)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "noncurrent_version_expiration", noncurrent_version_expiration)
        pulumi.set(__self__, "status", status)

    @property
    @pulumi.getter(name="abortIncompleteMultipartUpload")
    def abort_incomplete_multipart_upload(self) -> 'outputs.GetStorageV1BucketLifecycleConfigurationRuleAbortIncompleteMultipartUploadResult':
        """
        Specifies the days since the initiation of an incomplete multipart upload that
        the system will wait before permanently removing all parts of the upload.
        """
        return pulumi.get(self, "abort_incomplete_multipart_upload")

    @property
    @pulumi.getter
    def expiration(self) -> 'outputs.GetStorageV1BucketLifecycleConfigurationRuleExpirationResult':
        """
        Specifies the expiration for the lifecycle of the object in the form of date, days and,
        whether the object has a delete marker.
        """
        return pulumi.get(self, "expiration")

    @property
    @pulumi.getter
    def filter(self) -> 'outputs.GetStorageV1BucketLifecycleConfigurationRuleFilterResult':
        """
        The Filter is used to identify objects that a Lifecycle Rule applies to.
        The Lifecycle Rule will apply to any object matching all of the predicates
        configured inside (using logical AND).
        """
        return pulumi.get(self, "filter")

    @property
    @pulumi.getter
    def id(self) -> builtins.str:
        """
        Unique identifier for the rule per configuration.
        The value cannot be longer than 255 characters.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="noncurrentVersionExpiration")
    def noncurrent_version_expiration(self) -> 'outputs.GetStorageV1BucketLifecycleConfigurationRuleNoncurrentVersionExpirationResult':
        """
        Specifies when noncurrent object versions expire.
        It works only on a bucket that has versioning enabled (or suspended).
        """
        return pulumi.get(self, "noncurrent_version_expiration")

    @property
    @pulumi.getter
    def status(self) -> builtins.str:
        """
        ### Supported values

        Possible values:

         - `STATUS_UNSPECIFIED`
         - `ENABLED`
         - `DISABLED`
        """
        return pulumi.get(self, "status")


@pulumi.output_type
class GetStorageV1BucketLifecycleConfigurationRuleAbortIncompleteMultipartUploadResult(dict):
    def __init__(__self__, *,
                 days_after_initiation: builtins.float):
        """
        :param builtins.float days_after_initiation: Specifies the days since the initiation of an incomplete multipart upload that
               the system will wait before permanently removing all parts of the upload.
        """
        pulumi.set(__self__, "days_after_initiation", days_after_initiation)

    @property
    @pulumi.getter(name="daysAfterInitiation")
    def days_after_initiation(self) -> builtins.float:
        """
        Specifies the days since the initiation of an incomplete multipart upload that
        the system will wait before permanently removing all parts of the upload.
        """
        return pulumi.get(self, "days_after_initiation")


@pulumi.output_type
class GetStorageV1BucketLifecycleConfigurationRuleExpirationResult(dict):
    def __init__(__self__, *,
                 date: builtins.str,
                 days: builtins.float,
                 expired_object_delete_marker: builtins.bool):
        """
        :param builtins.str date: Indicates at what date the object will be deleted. The time is always midnight UTC.
               
               A string representing a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ` or `YYYY-MM-DDTHH:MM:SS.SSS±HH:MM`
               
               *Cannot be set alongside days.*
        :param builtins.float days: Indicates the lifetime, in days, of the objects that are subject to the rule.
               The value must be a non-zero positive integer.
               
               *Cannot be set alongside date.*
        :param builtins.bool expired_object_delete_marker: Indicates whether the system will remove a "delete marker" with no noncurrent versions.
               If set to true, the "delete marker" will be permanently removed.
               If set to false the policy takes no action.
               This cannot be specified with Days or Date in a LifecycleExpiration Policy.
        """
        pulumi.set(__self__, "date", date)
        pulumi.set(__self__, "days", days)
        pulumi.set(__self__, "expired_object_delete_marker", expired_object_delete_marker)

    @property
    @pulumi.getter
    def date(self) -> builtins.str:
        """
        Indicates at what date the object will be deleted. The time is always midnight UTC.

        A string representing a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ` or `YYYY-MM-DDTHH:MM:SS.SSS±HH:MM`

        *Cannot be set alongside days.*
        """
        return pulumi.get(self, "date")

    @property
    @pulumi.getter
    def days(self) -> builtins.float:
        """
        Indicates the lifetime, in days, of the objects that are subject to the rule.
        The value must be a non-zero positive integer.

        *Cannot be set alongside date.*
        """
        return pulumi.get(self, "days")

    @property
    @pulumi.getter(name="expiredObjectDeleteMarker")
    def expired_object_delete_marker(self) -> builtins.bool:
        """
        Indicates whether the system will remove a "delete marker" with no noncurrent versions.
        If set to true, the "delete marker" will be permanently removed.
        If set to false the policy takes no action.
        This cannot be specified with Days or Date in a LifecycleExpiration Policy.
        """
        return pulumi.get(self, "expired_object_delete_marker")


@pulumi.output_type
class GetStorageV1BucketLifecycleConfigurationRuleFilterResult(dict):
    def __init__(__self__, *,
                 object_size_greater_than_bytes: builtins.float,
                 object_size_less_than_bytes: builtins.float,
                 prefix: builtins.str):
        """
        :param builtins.float object_size_greater_than_bytes: Minimum object size to which the rule applies.
        :param builtins.float object_size_less_than_bytes: Maximum object size to which the rule applies.
        :param builtins.str prefix: Prefix identifying one or more objects to which the rule applies.
               If prefix is empty, the rule applies to all objects in the bucket.
        """
        pulumi.set(__self__, "object_size_greater_than_bytes", object_size_greater_than_bytes)
        pulumi.set(__self__, "object_size_less_than_bytes", object_size_less_than_bytes)
        pulumi.set(__self__, "prefix", prefix)

    @property
    @pulumi.getter(name="objectSizeGreaterThanBytes")
    def object_size_greater_than_bytes(self) -> builtins.float:
        """
        Minimum object size to which the rule applies.
        """
        return pulumi.get(self, "object_size_greater_than_bytes")

    @property
    @pulumi.getter(name="objectSizeLessThanBytes")
    def object_size_less_than_bytes(self) -> builtins.float:
        """
        Maximum object size to which the rule applies.
        """
        return pulumi.get(self, "object_size_less_than_bytes")

    @property
    @pulumi.getter
    def prefix(self) -> builtins.str:
        """
        Prefix identifying one or more objects to which the rule applies.
        If prefix is empty, the rule applies to all objects in the bucket.
        """
        return pulumi.get(self, "prefix")


@pulumi.output_type
class GetStorageV1BucketLifecycleConfigurationRuleNoncurrentVersionExpirationResult(dict):
    def __init__(__self__, *,
                 newer_noncurrent_versions: builtins.float,
                 noncurrent_days: builtins.float):
        """
        :param builtins.float newer_noncurrent_versions: Specifies how many noncurrent versions the system will retain.
        :param builtins.float noncurrent_days: Specifies the number of days an object is noncurrent before the system will expire it.
        """
        pulumi.set(__self__, "newer_noncurrent_versions", newer_noncurrent_versions)
        pulumi.set(__self__, "noncurrent_days", noncurrent_days)

    @property
    @pulumi.getter(name="newerNoncurrentVersions")
    def newer_noncurrent_versions(self) -> builtins.float:
        """
        Specifies how many noncurrent versions the system will retain.
        """
        return pulumi.get(self, "newer_noncurrent_versions")

    @property
    @pulumi.getter(name="noncurrentDays")
    def noncurrent_days(self) -> builtins.float:
        """
        Specifies the number of days an object is noncurrent before the system will expire it.
        """
        return pulumi.get(self, "noncurrent_days")


@pulumi.output_type
class GetStorageV1BucketMetadataResult(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class GetStorageV1BucketStatusResult(dict):
    def __init__(__self__, *,
                 counters: Sequence['outputs.GetStorageV1BucketStatusCounterResult'],
                 deleted_at: builtins.str,
                 domain_name: builtins.str,
                 purge_at: builtins.str,
                 region: builtins.str,
                 state: builtins.str,
                 suspension_state: builtins.str):
        """
        :param builtins.str deleted_at: The time when the bucket was deleted (or scheduled for deletion).
               It resets to null if the bucket is undeleted.
               
               A string representing a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ` or `YYYY-MM-DDTHH:MM:SS.SSS±HH:MM`
        :param builtins.str domain_name: The domain of the endpoint where the bucket can be accessed. It omits the scheme (HTTPS) and the port (443)
               and contains only the FQDN address.
        :param builtins.str purge_at: The time when the bucket will be automatically purged in case it was soft-deleted.
               
               A string representing a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ` or `YYYY-MM-DDTHH:MM:SS.SSS±HH:MM`
        :param builtins.str region: The name of the region where the bucket is located for use with S3 clients, i.e. "eu-west1".
        :param builtins.str state: ### Supported values
               
               Possible values:
               
                - `STATE_UNSPECIFIED`
                - `CREATING` - Bucket is under creation and cannot be used yet.
                - `ACTIVE` - Bucket is active and ready for usage.
                - `UPDATING` - Bucket is being updated.
               It can be used, but some settings are being modified and you can observe their inconsistency.
                - `SCHEDULED_FOR_DELETION` - Bucket is scheduled for deletion.
               It cannot be used in s3 api anymore.
        :param builtins.str suspension_state: ### Supported values
               
               Possible values:
               
                - `SUSPENSION_STATE_UNSPECIFIED`
                - `NOT_SUSPENDED`
                - `SUSPENDED`
        """
        pulumi.set(__self__, "counters", counters)
        pulumi.set(__self__, "deleted_at", deleted_at)
        pulumi.set(__self__, "domain_name", domain_name)
        pulumi.set(__self__, "purge_at", purge_at)
        pulumi.set(__self__, "region", region)
        pulumi.set(__self__, "state", state)
        pulumi.set(__self__, "suspension_state", suspension_state)

    @property
    @pulumi.getter
    def counters(self) -> Sequence['outputs.GetStorageV1BucketStatusCounterResult']:
        return pulumi.get(self, "counters")

    @property
    @pulumi.getter(name="deletedAt")
    def deleted_at(self) -> builtins.str:
        """
        The time when the bucket was deleted (or scheduled for deletion).
        It resets to null if the bucket is undeleted.

        A string representing a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ` or `YYYY-MM-DDTHH:MM:SS.SSS±HH:MM`
        """
        return pulumi.get(self, "deleted_at")

    @property
    @pulumi.getter(name="domainName")
    def domain_name(self) -> builtins.str:
        """
        The domain of the endpoint where the bucket can be accessed. It omits the scheme (HTTPS) and the port (443)
        and contains only the FQDN address.
        """
        return pulumi.get(self, "domain_name")

    @property
    @pulumi.getter(name="purgeAt")
    def purge_at(self) -> builtins.str:
        """
        The time when the bucket will be automatically purged in case it was soft-deleted.

        A string representing a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ` or `YYYY-MM-DDTHH:MM:SS.SSS±HH:MM`
        """
        return pulumi.get(self, "purge_at")

    @property
    @pulumi.getter
    def region(self) -> builtins.str:
        """
        The name of the region where the bucket is located for use with S3 clients, i.e. "eu-west1".
        """
        return pulumi.get(self, "region")

    @property
    @pulumi.getter
    def state(self) -> builtins.str:
        """
        ### Supported values

        Possible values:

         - `STATE_UNSPECIFIED`
         - `CREATING` - Bucket is under creation and cannot be used yet.
         - `ACTIVE` - Bucket is active and ready for usage.
         - `UPDATING` - Bucket is being updated.
        It can be used, but some settings are being modified and you can observe their inconsistency.
         - `SCHEDULED_FOR_DELETION` - Bucket is scheduled for deletion.
        It cannot be used in s3 api anymore.
        """
        return pulumi.get(self, "state")

    @property
    @pulumi.getter(name="suspensionState")
    def suspension_state(self) -> builtins.str:
        """
        ### Supported values

        Possible values:

         - `SUSPENSION_STATE_UNSPECIFIED`
         - `NOT_SUSPENDED`
         - `SUSPENDED`
        """
        return pulumi.get(self, "suspension_state")


@pulumi.output_type
class GetStorageV1BucketStatusCounterResult(dict):
    def __init__(__self__, *,
                 counters: 'outputs.GetStorageV1BucketStatusCounterCountersResult',
                 non_current_counters: 'outputs.GetStorageV1BucketStatusCounterNonCurrentCountersResult',
                 storage_class: builtins.str):
        """
        :param 'GetStorageV1BucketStatusCounterNonCurrentCountersArgs' non_current_counters: ### Inner value description
               
               Counters for non-current object versions (for versioning buckets).
        :param builtins.str storage_class: ### Supported values
               
               Possible values:
               
                - `STORAGE_CLASS_UNSPECIFIED`
                - `STANDARD`
                - `ENHANCED_THROUGHPUT`
        """
        pulumi.set(__self__, "counters", counters)
        pulumi.set(__self__, "non_current_counters", non_current_counters)
        pulumi.set(__self__, "storage_class", storage_class)

    @property
    @pulumi.getter
    def counters(self) -> 'outputs.GetStorageV1BucketStatusCounterCountersResult':
        return pulumi.get(self, "counters")

    @property
    @pulumi.getter(name="nonCurrentCounters")
    def non_current_counters(self) -> 'outputs.GetStorageV1BucketStatusCounterNonCurrentCountersResult':
        """
        ### Inner value description

        Counters for non-current object versions (for versioning buckets).
        """
        return pulumi.get(self, "non_current_counters")

    @property
    @pulumi.getter(name="storageClass")
    def storage_class(self) -> builtins.str:
        """
        ### Supported values

        Possible values:

         - `STORAGE_CLASS_UNSPECIFIED`
         - `STANDARD`
         - `ENHANCED_THROUGHPUT`
        """
        return pulumi.get(self, "storage_class")


@pulumi.output_type
class GetStorageV1BucketStatusCounterCountersResult(dict):
    def __init__(__self__, *,
                 inflight_parts_quantity: builtins.float,
                 inflight_parts_size: builtins.float,
                 multipart_objects_quantity: builtins.float,
                 multipart_objects_size: builtins.float,
                 multipart_uploads_quantity: builtins.float,
                 simple_objects_quantity: builtins.float,
                 simple_objects_size: builtins.float):
        pulumi.set(__self__, "inflight_parts_quantity", inflight_parts_quantity)
        pulumi.set(__self__, "inflight_parts_size", inflight_parts_size)
        pulumi.set(__self__, "multipart_objects_quantity", multipart_objects_quantity)
        pulumi.set(__self__, "multipart_objects_size", multipart_objects_size)
        pulumi.set(__self__, "multipart_uploads_quantity", multipart_uploads_quantity)
        pulumi.set(__self__, "simple_objects_quantity", simple_objects_quantity)
        pulumi.set(__self__, "simple_objects_size", simple_objects_size)

    @property
    @pulumi.getter(name="inflightPartsQuantity")
    def inflight_parts_quantity(self) -> builtins.float:
        return pulumi.get(self, "inflight_parts_quantity")

    @property
    @pulumi.getter(name="inflightPartsSize")
    def inflight_parts_size(self) -> builtins.float:
        return pulumi.get(self, "inflight_parts_size")

    @property
    @pulumi.getter(name="multipartObjectsQuantity")
    def multipart_objects_quantity(self) -> builtins.float:
        return pulumi.get(self, "multipart_objects_quantity")

    @property
    @pulumi.getter(name="multipartObjectsSize")
    def multipart_objects_size(self) -> builtins.float:
        return pulumi.get(self, "multipart_objects_size")

    @property
    @pulumi.getter(name="multipartUploadsQuantity")
    def multipart_uploads_quantity(self) -> builtins.float:
        return pulumi.get(self, "multipart_uploads_quantity")

    @property
    @pulumi.getter(name="simpleObjectsQuantity")
    def simple_objects_quantity(self) -> builtins.float:
        return pulumi.get(self, "simple_objects_quantity")

    @property
    @pulumi.getter(name="simpleObjectsSize")
    def simple_objects_size(self) -> builtins.float:
        return pulumi.get(self, "simple_objects_size")


@pulumi.output_type
class GetStorageV1BucketStatusCounterNonCurrentCountersResult(dict):
    def __init__(__self__, *,
                 multipart_objects_quantity: builtins.float,
                 multipart_objects_size: builtins.float,
                 simple_objects_quantity: builtins.float,
                 simple_objects_size: builtins.float):
        pulumi.set(__self__, "multipart_objects_quantity", multipart_objects_quantity)
        pulumi.set(__self__, "multipart_objects_size", multipart_objects_size)
        pulumi.set(__self__, "simple_objects_quantity", simple_objects_quantity)
        pulumi.set(__self__, "simple_objects_size", simple_objects_size)

    @property
    @pulumi.getter(name="multipartObjectsQuantity")
    def multipart_objects_quantity(self) -> builtins.float:
        return pulumi.get(self, "multipart_objects_quantity")

    @property
    @pulumi.getter(name="multipartObjectsSize")
    def multipart_objects_size(self) -> builtins.float:
        return pulumi.get(self, "multipart_objects_size")

    @property
    @pulumi.getter(name="simpleObjectsQuantity")
    def simple_objects_quantity(self) -> builtins.float:
        return pulumi.get(self, "simple_objects_quantity")

    @property
    @pulumi.getter(name="simpleObjectsSize")
    def simple_objects_size(self) -> builtins.float:
        return pulumi.get(self, "simple_objects_size")


@pulumi.output_type
class GetVpcV1AllocationIpv4PrivateResult(dict):
    def __init__(__self__, *,
                 cidr: builtins.str,
                 pool_id: builtins.str,
                 subnet_id: builtins.str):
        """
        :param builtins.str cidr: CIDR block for IPv4 Allocation.
               May be a single IP address (such as 10.2.3.4),
               a prefix length (such as /24) or a CIDR-formatted string (such as 10.1.2.0/24).
               Random address (/32) from pool would be allocated if field is omitted.
        :param builtins.str pool_id: Pool for the IPv4 private allocation.
               
               *Cannot be set alongside subnet_id.*
        :param builtins.str subnet_id: Subnet ID.
               Required same subnet to use allocation in subnet-resources (e.g. Network Interface)
               
               *Cannot be set alongside pool_id.*
        """
        pulumi.set(__self__, "cidr", cidr)
        pulumi.set(__self__, "pool_id", pool_id)
        pulumi.set(__self__, "subnet_id", subnet_id)

    @property
    @pulumi.getter
    def cidr(self) -> builtins.str:
        """
        CIDR block for IPv4 Allocation.
        May be a single IP address (such as 10.2.3.4),
        a prefix length (such as /24) or a CIDR-formatted string (such as 10.1.2.0/24).
        Random address (/32) from pool would be allocated if field is omitted.
        """
        return pulumi.get(self, "cidr")

    @property
    @pulumi.getter(name="poolId")
    def pool_id(self) -> builtins.str:
        """
        Pool for the IPv4 private allocation.

        *Cannot be set alongside subnet_id.*
        """
        return pulumi.get(self, "pool_id")

    @property
    @pulumi.getter(name="subnetId")
    def subnet_id(self) -> builtins.str:
        """
        Subnet ID.
        Required same subnet to use allocation in subnet-resources (e.g. Network Interface)

        *Cannot be set alongside pool_id.*
        """
        return pulumi.get(self, "subnet_id")


@pulumi.output_type
class GetVpcV1AllocationIpv4PublicResult(dict):
    def __init__(__self__, *,
                 cidr: builtins.str,
                 pool_id: builtins.str,
                 subnet_id: builtins.str):
        """
        :param builtins.str cidr: CIDR block for IPv4 Allocation.
               May be a single IP address (such as 10.2.3.4),
               a prefix length (such as /32) or a CIDR-formatted string (such as 10.1.2.0/32).
               Random address (/32) from pool would be allocated if field is omitted.
        :param builtins.str pool_id: Pool for the IPv4 public allocation.
               
               *Cannot be set alongside subnet_id.*
        :param builtins.str subnet_id: Subnet ID.
               Required same subnet to use allocation in subnet-resources (e.g. Network Interface)
               
               *Cannot be set alongside pool_id.*
        """
        pulumi.set(__self__, "cidr", cidr)
        pulumi.set(__self__, "pool_id", pool_id)
        pulumi.set(__self__, "subnet_id", subnet_id)

    @property
    @pulumi.getter
    def cidr(self) -> builtins.str:
        """
        CIDR block for IPv4 Allocation.
        May be a single IP address (such as 10.2.3.4),
        a prefix length (such as /32) or a CIDR-formatted string (such as 10.1.2.0/32).
        Random address (/32) from pool would be allocated if field is omitted.
        """
        return pulumi.get(self, "cidr")

    @property
    @pulumi.getter(name="poolId")
    def pool_id(self) -> builtins.str:
        """
        Pool for the IPv4 public allocation.

        *Cannot be set alongside subnet_id.*
        """
        return pulumi.get(self, "pool_id")

    @property
    @pulumi.getter(name="subnetId")
    def subnet_id(self) -> builtins.str:
        """
        Subnet ID.
        Required same subnet to use allocation in subnet-resources (e.g. Network Interface)

        *Cannot be set alongside pool_id.*
        """
        return pulumi.get(self, "subnet_id")


@pulumi.output_type
class GetVpcV1AllocationMetadataResult(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class GetVpcV1AllocationStatusResult(dict):
    def __init__(__self__, *,
                 assignment: 'outputs.GetVpcV1AllocationStatusAssignmentResult',
                 details: 'outputs.GetVpcV1AllocationStatusDetailsResult',
                 state: builtins.str,
                 static: builtins.bool):
        """
        :param 'GetVpcV1AllocationStatusAssignmentArgs' assignment: Information about the assignment associated with the allocation,
               such as network interface or load balancer assignment.
        :param 'GetVpcV1AllocationStatusDetailsArgs' details: Detailed information about the allocation status,
               including the allocated CIDR, pool ID and IP version.
        :param builtins.str state: This field represents the current state of the allocation.
               
               ### Supported values
               
               Enumeration of possible states of the Allocation.
               Possible values:
               
                - `STATE_UNSPECIFIED` - Default state, unspecified.
                - `CREATING` - Allocation is being created.
                - `ALLOCATED` - Allocation is ready for use.
                - `ASSIGNED` - Allocation is used.
                - `DELETING` - Allocation is being deleted.
        :param builtins.bool static: If false - Lifecycle of allocation depends on resource that using it.
        """
        pulumi.set(__self__, "assignment", assignment)
        pulumi.set(__self__, "details", details)
        pulumi.set(__self__, "state", state)
        pulumi.set(__self__, "static", static)

    @property
    @pulumi.getter
    def assignment(self) -> 'outputs.GetVpcV1AllocationStatusAssignmentResult':
        """
        Information about the assignment associated with the allocation,
        such as network interface or load balancer assignment.
        """
        return pulumi.get(self, "assignment")

    @property
    @pulumi.getter
    def details(self) -> 'outputs.GetVpcV1AllocationStatusDetailsResult':
        """
        Detailed information about the allocation status,
        including the allocated CIDR, pool ID and IP version.
        """
        return pulumi.get(self, "details")

    @property
    @pulumi.getter
    def state(self) -> builtins.str:
        """
        This field represents the current state of the allocation.

        ### Supported values

        Enumeration of possible states of the Allocation.
        Possible values:

         - `STATE_UNSPECIFIED` - Default state, unspecified.
         - `CREATING` - Allocation is being created.
         - `ALLOCATED` - Allocation is ready for use.
         - `ASSIGNED` - Allocation is used.
         - `DELETING` - Allocation is being deleted.
        """
        return pulumi.get(self, "state")

    @property
    @pulumi.getter
    def static(self) -> builtins.bool:
        """
        If false - Lifecycle of allocation depends on resource that using it.
        """
        return pulumi.get(self, "static")


@pulumi.output_type
class GetVpcV1AllocationStatusAssignmentResult(dict):
    def __init__(__self__, *,
                 load_balancer: 'outputs.GetVpcV1AllocationStatusAssignmentLoadBalancerResult',
                 network_interface: 'outputs.GetVpcV1AllocationStatusAssignmentNetworkInterfaceResult'):
        """
        :param 'GetVpcV1AllocationStatusAssignmentLoadBalancerArgs' load_balancer: *Cannot be set alongside network_interface.*
        :param 'GetVpcV1AllocationStatusAssignmentNetworkInterfaceArgs' network_interface: *Cannot be set alongside load_balancer.*
        """
        pulumi.set(__self__, "load_balancer", load_balancer)
        pulumi.set(__self__, "network_interface", network_interface)

    @property
    @pulumi.getter(name="loadBalancer")
    def load_balancer(self) -> 'outputs.GetVpcV1AllocationStatusAssignmentLoadBalancerResult':
        """
        *Cannot be set alongside network_interface.*
        """
        return pulumi.get(self, "load_balancer")

    @property
    @pulumi.getter(name="networkInterface")
    def network_interface(self) -> 'outputs.GetVpcV1AllocationStatusAssignmentNetworkInterfaceResult':
        """
        *Cannot be set alongside load_balancer.*
        """
        return pulumi.get(self, "network_interface")


@pulumi.output_type
class GetVpcV1AllocationStatusAssignmentLoadBalancerResult(dict):
    def __init__(__self__, *,
                 id: builtins.str):
        """
        :param builtins.str id: ID of the Load Balancer.
        """
        pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> builtins.str:
        """
        ID of the Load Balancer.
        """
        return pulumi.get(self, "id")


@pulumi.output_type
class GetVpcV1AllocationStatusAssignmentNetworkInterfaceResult(dict):
    def __init__(__self__, *,
                 instance_id: builtins.str,
                 name: builtins.str):
        """
        :param builtins.str instance_id: ID of the Compute instance network interface belongs to.
        :param builtins.str name: Network interface name
        """
        pulumi.set(__self__, "instance_id", instance_id)
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter(name="instanceId")
    def instance_id(self) -> builtins.str:
        """
        ID of the Compute instance network interface belongs to.
        """
        return pulumi.get(self, "instance_id")

    @property
    @pulumi.getter
    def name(self) -> builtins.str:
        """
        Network interface name
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetVpcV1AllocationStatusDetailsResult(dict):
    def __init__(__self__, *,
                 allocated_cidr: builtins.str,
                 pool_id: builtins.str,
                 version: builtins.str):
        """
        :param builtins.str allocated_cidr: The actual CIDR block that has been allocated.
        :param builtins.str pool_id: ID of the pool from which this allocation was made.
        :param builtins.str version: The IP version of this allocation (IPv4 or IPv6).
               
               ### Supported values
               
               Possible values:
               
                - `IP_VERSION_UNSPECIFIED` - Default, unspecified IP version.
                - `IPV4` - IPv4 address.
                - `IPV6` - IPv6 address.
        """
        pulumi.set(__self__, "allocated_cidr", allocated_cidr)
        pulumi.set(__self__, "pool_id", pool_id)
        pulumi.set(__self__, "version", version)

    @property
    @pulumi.getter(name="allocatedCidr")
    def allocated_cidr(self) -> builtins.str:
        """
        The actual CIDR block that has been allocated.
        """
        return pulumi.get(self, "allocated_cidr")

    @property
    @pulumi.getter(name="poolId")
    def pool_id(self) -> builtins.str:
        """
        ID of the pool from which this allocation was made.
        """
        return pulumi.get(self, "pool_id")

    @property
    @pulumi.getter
    def version(self) -> builtins.str:
        """
        The IP version of this allocation (IPv4 or IPv6).

        ### Supported values

        Possible values:

         - `IP_VERSION_UNSPECIFIED` - Default, unspecified IP version.
         - `IPV4` - IPv4 address.
         - `IPV6` - IPv6 address.
        """
        return pulumi.get(self, "version")


@pulumi.output_type
class GetVpcV1NetworkIpv4PrivatePoolsResult(dict):
    def __init__(__self__, *,
                 pools: Sequence['outputs.GetVpcV1NetworkIpv4PrivatePoolsPoolResult']):
        pulumi.set(__self__, "pools", pools)

    @property
    @pulumi.getter
    def pools(self) -> Sequence['outputs.GetVpcV1NetworkIpv4PrivatePoolsPoolResult']:
        return pulumi.get(self, "pools")


@pulumi.output_type
class GetVpcV1NetworkIpv4PrivatePoolsPoolResult(dict):
    def __init__(__self__, *,
                 id: builtins.str):
        """
        :param builtins.str id: ID of the IP address pool.
        """
        pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> builtins.str:
        """
        ID of the IP address pool.
        """
        return pulumi.get(self, "id")


@pulumi.output_type
class GetVpcV1NetworkIpv4PublicPoolsResult(dict):
    def __init__(__self__, *,
                 pools: Sequence['outputs.GetVpcV1NetworkIpv4PublicPoolsPoolResult']):
        pulumi.set(__self__, "pools", pools)

    @property
    @pulumi.getter
    def pools(self) -> Sequence['outputs.GetVpcV1NetworkIpv4PublicPoolsPoolResult']:
        return pulumi.get(self, "pools")


@pulumi.output_type
class GetVpcV1NetworkIpv4PublicPoolsPoolResult(dict):
    def __init__(__self__, *,
                 id: builtins.str):
        """
        :param builtins.str id: ID of the IP address pool.
        """
        pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> builtins.str:
        """
        ID of the IP address pool.
        """
        return pulumi.get(self, "id")


@pulumi.output_type
class GetVpcV1NetworkMetadataResult(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class GetVpcV1NetworkStatusResult(dict):
    def __init__(__self__, *,
                 state: builtins.str):
        """
        :param builtins.str state: Current state of the network.
               
               ### Supported values
               
               Enumeration of possible states of the network.
               Possible values:
               
                - `STATE_UNSPECIFIED` - Default state, unspecified.
                - `CREATING` - Network is being created.
                - `READY` - Network is ready for use.
                - `DELETING` - Network is being deleted.
        """
        pulumi.set(__self__, "state", state)

    @property
    @pulumi.getter
    def state(self) -> builtins.str:
        """
        Current state of the network.

        ### Supported values

        Enumeration of possible states of the network.
        Possible values:

         - `STATE_UNSPECIFIED` - Default state, unspecified.
         - `CREATING` - Network is being created.
         - `READY` - Network is ready for use.
         - `DELETING` - Network is being deleted.
        """
        return pulumi.get(self, "state")


@pulumi.output_type
class GetVpcV1PoolCidrResult(dict):
    def __init__(__self__, *,
                 cidr: builtins.str,
                 max_mask_length: builtins.float,
                 state: builtins.str):
        """
        :param builtins.str cidr: CIDR block.
               May be a prefix length (such as /24) for non-top-level pools
               or a CIDR-formatted string (such as 10.1.2.0/24).
        :param builtins.float max_mask_length: Maximum mask length for allocation from this cidr including creation of sub-pools
               Default max_mask_length is 32 for IPv4 and 128 for IPv6
        :param builtins.str state: State of the Cidr.
               Default state is AVAILABLE
               
               ### Supported values
               
               Possible values:
               
                - `STATE_UNSPECIFIED` - Default, unspecified state.
                - `AVAILABLE` - Allocation from range is available.
                - `DISABLED` - New allocation would not be created.
        """
        pulumi.set(__self__, "cidr", cidr)
        pulumi.set(__self__, "max_mask_length", max_mask_length)
        pulumi.set(__self__, "state", state)

    @property
    @pulumi.getter
    def cidr(self) -> builtins.str:
        """
        CIDR block.
        May be a prefix length (such as /24) for non-top-level pools
        or a CIDR-formatted string (such as 10.1.2.0/24).
        """
        return pulumi.get(self, "cidr")

    @property
    @pulumi.getter(name="maxMaskLength")
    def max_mask_length(self) -> builtins.float:
        """
        Maximum mask length for allocation from this cidr including creation of sub-pools
        Default max_mask_length is 32 for IPv4 and 128 for IPv6
        """
        return pulumi.get(self, "max_mask_length")

    @property
    @pulumi.getter
    def state(self) -> builtins.str:
        """
        State of the Cidr.
        Default state is AVAILABLE

        ### Supported values

        Possible values:

         - `STATE_UNSPECIFIED` - Default, unspecified state.
         - `AVAILABLE` - Allocation from range is available.
         - `DISABLED` - New allocation would not be created.
        """
        return pulumi.get(self, "state")


@pulumi.output_type
class GetVpcV1PoolMetadataResult(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class GetVpcV1PoolStatusResult(dict):
    def __init__(__self__, *,
                 assignment: 'outputs.GetVpcV1PoolStatusAssignmentResult',
                 cidrs: Sequence[builtins.str],
                 scope_id: builtins.str,
                 state: builtins.str):
        """
        :param 'GetVpcV1PoolStatusAssignmentArgs' assignment: Assignment details for this Pool
        :param Sequence[builtins.str] cidrs: CIDR blocks.
        :param builtins.str scope_id: Scope is the unique identifier for single pool tree.
        :param builtins.str state: Current state of the Pool.
               
               ### Supported values
               
               Possible states of the Pool.
               Possible values:
               
                - `STATE_UNSPECIFIED` - Default, unspecified state.
                - `CREATING` - Pool is being created.
                - `READY` - Pool is ready for use.
                - `DELETING` - Pool is being deleted.
        """
        pulumi.set(__self__, "assignment", assignment)
        pulumi.set(__self__, "cidrs", cidrs)
        pulumi.set(__self__, "scope_id", scope_id)
        pulumi.set(__self__, "state", state)

    @property
    @pulumi.getter
    def assignment(self) -> 'outputs.GetVpcV1PoolStatusAssignmentResult':
        """
        Assignment details for this Pool
        """
        return pulumi.get(self, "assignment")

    @property
    @pulumi.getter
    def cidrs(self) -> Sequence[builtins.str]:
        """
        CIDR blocks.
        """
        return pulumi.get(self, "cidrs")

    @property
    @pulumi.getter(name="scopeId")
    def scope_id(self) -> builtins.str:
        """
        Scope is the unique identifier for single pool tree.
        """
        return pulumi.get(self, "scope_id")

    @property
    @pulumi.getter
    def state(self) -> builtins.str:
        """
        Current state of the Pool.

        ### Supported values

        Possible states of the Pool.
        Possible values:

         - `STATE_UNSPECIFIED` - Default, unspecified state.
         - `CREATING` - Pool is being created.
         - `READY` - Pool is ready for use.
         - `DELETING` - Pool is being deleted.
        """
        return pulumi.get(self, "state")


@pulumi.output_type
class GetVpcV1PoolStatusAssignmentResult(dict):
    def __init__(__self__, *,
                 networks: Sequence[builtins.str],
                 subnets: Sequence[builtins.str]):
        """
        :param Sequence[builtins.str] networks: IDs of Networks to which the Pool is assigned.
        :param Sequence[builtins.str] subnets: IDs of Subnets to which the Pool is assigned.
        """
        pulumi.set(__self__, "networks", networks)
        pulumi.set(__self__, "subnets", subnets)

    @property
    @pulumi.getter
    def networks(self) -> Sequence[builtins.str]:
        """
        IDs of Networks to which the Pool is assigned.
        """
        return pulumi.get(self, "networks")

    @property
    @pulumi.getter
    def subnets(self) -> Sequence[builtins.str]:
        """
        IDs of Subnets to which the Pool is assigned.
        """
        return pulumi.get(self, "subnets")


@pulumi.output_type
class GetVpcV1SubnetIpv4PrivatePoolsResult(dict):
    def __init__(__self__, *,
                 pools: Sequence['outputs.GetVpcV1SubnetIpv4PrivatePoolsPoolResult'],
                 use_network_pools: builtins.bool):
        """
        :param Sequence['GetVpcV1SubnetIpv4PrivatePoolsPoolArgs'] pools: Pools for private ipv4 allocations in subnet
               Must be empty if 'use_network_pools = true'
        :param builtins.bool use_network_pools: Allow using of private ipv4 pools which are specified in network
               Must be false if 'pools' is not empty
        """
        pulumi.set(__self__, "pools", pools)
        pulumi.set(__self__, "use_network_pools", use_network_pools)

    @property
    @pulumi.getter
    def pools(self) -> Sequence['outputs.GetVpcV1SubnetIpv4PrivatePoolsPoolResult']:
        """
        Pools for private ipv4 allocations in subnet
        Must be empty if 'use_network_pools = true'
        """
        return pulumi.get(self, "pools")

    @property
    @pulumi.getter(name="useNetworkPools")
    def use_network_pools(self) -> builtins.bool:
        """
        Allow using of private ipv4 pools which are specified in network
        Must be false if 'pools' is not empty
        """
        return pulumi.get(self, "use_network_pools")


@pulumi.output_type
class GetVpcV1SubnetIpv4PrivatePoolsPoolResult(dict):
    def __init__(__self__, *,
                 cidrs: Sequence['outputs.GetVpcV1SubnetIpv4PrivatePoolsPoolCidrResult']):
        pulumi.set(__self__, "cidrs", cidrs)

    @property
    @pulumi.getter
    def cidrs(self) -> Sequence['outputs.GetVpcV1SubnetIpv4PrivatePoolsPoolCidrResult']:
        return pulumi.get(self, "cidrs")


@pulumi.output_type
class GetVpcV1SubnetIpv4PrivatePoolsPoolCidrResult(dict):
    def __init__(__self__, *,
                 cidr: builtins.str,
                 max_mask_length: builtins.float,
                 state: builtins.str):
        """
        :param builtins.str cidr: CIDR block.
               May be a prefix length (such as /24) or a CIDR-formatted string (such as 10.1.2.0/24).
        :param builtins.float max_mask_length: Maximum mask length for allocation from this cidr
               Default max_mask_length is 32 for IPv4 and 128 for IPv6
        :param builtins.str state: State of the Cidr.
               Default state is AVAILABLE
               
               ### Supported values
               
               Possible values:
               
                - `STATE_UNSPECIFIED` - Default, unspecified state.
                - `AVAILABLE` - Allocation from range is available.
                - `DISABLED` - New allocation would not be created.
        """
        pulumi.set(__self__, "cidr", cidr)
        pulumi.set(__self__, "max_mask_length", max_mask_length)
        pulumi.set(__self__, "state", state)

    @property
    @pulumi.getter
    def cidr(self) -> builtins.str:
        """
        CIDR block.
        May be a prefix length (such as /24) or a CIDR-formatted string (such as 10.1.2.0/24).
        """
        return pulumi.get(self, "cidr")

    @property
    @pulumi.getter(name="maxMaskLength")
    def max_mask_length(self) -> builtins.float:
        """
        Maximum mask length for allocation from this cidr
        Default max_mask_length is 32 for IPv4 and 128 for IPv6
        """
        return pulumi.get(self, "max_mask_length")

    @property
    @pulumi.getter
    def state(self) -> builtins.str:
        """
        State of the Cidr.
        Default state is AVAILABLE

        ### Supported values

        Possible values:

         - `STATE_UNSPECIFIED` - Default, unspecified state.
         - `AVAILABLE` - Allocation from range is available.
         - `DISABLED` - New allocation would not be created.
        """
        return pulumi.get(self, "state")


@pulumi.output_type
class GetVpcV1SubnetIpv4PublicPoolsResult(dict):
    def __init__(__self__, *,
                 pools: Sequence['outputs.GetVpcV1SubnetIpv4PublicPoolsPoolResult'],
                 use_network_pools: builtins.bool):
        """
        :param Sequence['GetVpcV1SubnetIpv4PublicPoolsPoolArgs'] pools: Pools for public ipv4 allocations in subnet
               Must be empty if 'use_network_pools = true'
        :param builtins.bool use_network_pools: Allow using of public ipv4 pools which are specified in network
               Must be false if 'pools' is not empty
        """
        pulumi.set(__self__, "pools", pools)
        pulumi.set(__self__, "use_network_pools", use_network_pools)

    @property
    @pulumi.getter
    def pools(self) -> Sequence['outputs.GetVpcV1SubnetIpv4PublicPoolsPoolResult']:
        """
        Pools for public ipv4 allocations in subnet
        Must be empty if 'use_network_pools = true'
        """
        return pulumi.get(self, "pools")

    @property
    @pulumi.getter(name="useNetworkPools")
    def use_network_pools(self) -> builtins.bool:
        """
        Allow using of public ipv4 pools which are specified in network
        Must be false if 'pools' is not empty
        """
        return pulumi.get(self, "use_network_pools")


@pulumi.output_type
class GetVpcV1SubnetIpv4PublicPoolsPoolResult(dict):
    def __init__(__self__, *,
                 cidrs: Sequence['outputs.GetVpcV1SubnetIpv4PublicPoolsPoolCidrResult']):
        pulumi.set(__self__, "cidrs", cidrs)

    @property
    @pulumi.getter
    def cidrs(self) -> Sequence['outputs.GetVpcV1SubnetIpv4PublicPoolsPoolCidrResult']:
        return pulumi.get(self, "cidrs")


@pulumi.output_type
class GetVpcV1SubnetIpv4PublicPoolsPoolCidrResult(dict):
    def __init__(__self__, *,
                 cidr: builtins.str,
                 max_mask_length: builtins.float,
                 state: builtins.str):
        """
        :param builtins.str cidr: CIDR block.
               May be a prefix length (such as /24) or a CIDR-formatted string (such as 10.1.2.0/24).
        :param builtins.float max_mask_length: Maximum mask length for allocation from this cidr
               Default max_mask_length is 32 for IPv4 and 128 for IPv6
        :param builtins.str state: State of the Cidr.
               Default state is AVAILABLE
               
               ### Supported values
               
               Possible values:
               
                - `STATE_UNSPECIFIED` - Default, unspecified state.
                - `AVAILABLE` - Allocation from range is available.
                - `DISABLED` - New allocation would not be created.
        """
        pulumi.set(__self__, "cidr", cidr)
        pulumi.set(__self__, "max_mask_length", max_mask_length)
        pulumi.set(__self__, "state", state)

    @property
    @pulumi.getter
    def cidr(self) -> builtins.str:
        """
        CIDR block.
        May be a prefix length (such as /24) or a CIDR-formatted string (such as 10.1.2.0/24).
        """
        return pulumi.get(self, "cidr")

    @property
    @pulumi.getter(name="maxMaskLength")
    def max_mask_length(self) -> builtins.float:
        """
        Maximum mask length for allocation from this cidr
        Default max_mask_length is 32 for IPv4 and 128 for IPv6
        """
        return pulumi.get(self, "max_mask_length")

    @property
    @pulumi.getter
    def state(self) -> builtins.str:
        """
        State of the Cidr.
        Default state is AVAILABLE

        ### Supported values

        Possible values:

         - `STATE_UNSPECIFIED` - Default, unspecified state.
         - `AVAILABLE` - Allocation from range is available.
         - `DISABLED` - New allocation would not be created.
        """
        return pulumi.get(self, "state")


@pulumi.output_type
class GetVpcV1SubnetMetadataResult(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class GetVpcV1SubnetStatusResult(dict):
    def __init__(__self__, *,
                 ipv4_private_cidrs: Sequence[builtins.str],
                 ipv4_public_cidrs: Sequence[builtins.str],
                 state: builtins.str):
        """
        :param Sequence[builtins.str] ipv4_private_cidrs: CIDR blocks.
        :param Sequence[builtins.str] ipv4_public_cidrs: CIDR blocks.
        :param builtins.str state: Current state of the subnet.
               
               ### Supported values
               
               Enumeration of possible states of the subnet.
               Possible values:
               
                - `STATE_UNSPECIFIED` - Default state, unspecified.
                - `CREATING` - Subnet is being created.
                - `READY` - Subnet is ready for use.
                - `DELETING` - Subnet is being deleted.
        """
        pulumi.set(__self__, "ipv4_private_cidrs", ipv4_private_cidrs)
        pulumi.set(__self__, "ipv4_public_cidrs", ipv4_public_cidrs)
        pulumi.set(__self__, "state", state)

    @property
    @pulumi.getter(name="ipv4PrivateCidrs")
    def ipv4_private_cidrs(self) -> Sequence[builtins.str]:
        """
        CIDR blocks.
        """
        return pulumi.get(self, "ipv4_private_cidrs")

    @property
    @pulumi.getter(name="ipv4PublicCidrs")
    def ipv4_public_cidrs(self) -> Sequence[builtins.str]:
        """
        CIDR blocks.
        """
        return pulumi.get(self, "ipv4_public_cidrs")

    @property
    @pulumi.getter
    def state(self) -> builtins.str:
        """
        Current state of the subnet.

        ### Supported values

        Enumeration of possible states of the subnet.
        Possible values:

         - `STATE_UNSPECIFIED` - Default state, unspecified.
         - `CREATING` - Subnet is being created.
         - `READY` - Subnet is ready for use.
         - `DELETING` - Subnet is being deleted.
        """
        return pulumi.get(self, "state")


@pulumi.output_type
class GetVpcV1alpha1AllocationIpv4PrivateResult(dict):
    def __init__(__self__, *,
                 cidr: builtins.str,
                 pool_id: builtins.str,
                 subnet_id: builtins.str):
        """
        :param builtins.str cidr: CIDR block for IPv4 Allocation.
               May be a single IP address (such as 10.2.3.4),
               a prefix length (such as /24) or a CIDR-formatted string (such as 10.1.2.0/24).
               Random address (/32) from pool would be allocated if field is omitted.
        :param builtins.str pool_id: Pool for the IPv4 private allocation.
               
               *Cannot be set alongside subnet_id.*
        :param builtins.str subnet_id: Subnet ID.
               Required same subnet to use allocation in subnet-resources (e.g. Network Interface)
               
               *Cannot be set alongside pool_id.*
        """
        pulumi.set(__self__, "cidr", cidr)
        pulumi.set(__self__, "pool_id", pool_id)
        pulumi.set(__self__, "subnet_id", subnet_id)

    @property
    @pulumi.getter
    def cidr(self) -> builtins.str:
        """
        CIDR block for IPv4 Allocation.
        May be a single IP address (such as 10.2.3.4),
        a prefix length (such as /24) or a CIDR-formatted string (such as 10.1.2.0/24).
        Random address (/32) from pool would be allocated if field is omitted.
        """
        return pulumi.get(self, "cidr")

    @property
    @pulumi.getter(name="poolId")
    def pool_id(self) -> builtins.str:
        """
        Pool for the IPv4 private allocation.

        *Cannot be set alongside subnet_id.*
        """
        return pulumi.get(self, "pool_id")

    @property
    @pulumi.getter(name="subnetId")
    def subnet_id(self) -> builtins.str:
        """
        Subnet ID.
        Required same subnet to use allocation in subnet-resources (e.g. Network Interface)

        *Cannot be set alongside pool_id.*
        """
        return pulumi.get(self, "subnet_id")


@pulumi.output_type
class GetVpcV1alpha1AllocationIpv4PublicResult(dict):
    def __init__(__self__, *,
                 cidr: builtins.str,
                 pool_id: builtins.str):
        """
        :param builtins.str cidr: CIDR block for IPv4 Allocation.
               May be a single IP address (such as 10.2.3.4),
               a prefix length (such as /32) or a CIDR-formatted string (such as 10.1.2.0/32).
               Random address (/32) from pool would be allocated if field is omitted.
        :param builtins.str pool_id: Pool for the IPv4 public allocation.
        """
        pulumi.set(__self__, "cidr", cidr)
        pulumi.set(__self__, "pool_id", pool_id)

    @property
    @pulumi.getter
    def cidr(self) -> builtins.str:
        """
        CIDR block for IPv4 Allocation.
        May be a single IP address (such as 10.2.3.4),
        a prefix length (such as /32) or a CIDR-formatted string (such as 10.1.2.0/32).
        Random address (/32) from pool would be allocated if field is omitted.
        """
        return pulumi.get(self, "cidr")

    @property
    @pulumi.getter(name="poolId")
    def pool_id(self) -> builtins.str:
        """
        Pool for the IPv4 public allocation.
        """
        return pulumi.get(self, "pool_id")


@pulumi.output_type
class GetVpcV1alpha1AllocationMetadataResult(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class GetVpcV1alpha1AllocationStatusResult(dict):
    def __init__(__self__, *,
                 assignment: 'outputs.GetVpcV1alpha1AllocationStatusAssignmentResult',
                 details: 'outputs.GetVpcV1alpha1AllocationStatusDetailsResult',
                 state: builtins.str,
                 static: builtins.bool):
        """
        :param 'GetVpcV1alpha1AllocationStatusAssignmentArgs' assignment: Information about the assignment associated with the allocation,
               such as network interface or load balancer assignment.
        :param 'GetVpcV1alpha1AllocationStatusDetailsArgs' details: Detailed information about the allocation status,
               including the allocated CIDR, pool ID, scope type, and IP version.
        :param builtins.str state: This field represents the current state of the allocation.
               
               ### Supported values
               
               Enumeration of possible states of the Allocation.
               Possible values:
               
                - `STATE_UNSPECIFIED` - Default state, unspecified.
                - `CREATING` - Allocation is being created.
                - `ALLOCATED` - Allocation is ready for use.
                - `ASSIGNED` - Allocation is used.
                - `DELETING` - Allocation is being deleted.
        :param builtins.bool static: If false - Lifecycle of allocation depends on resource that using it.
        """
        pulumi.set(__self__, "assignment", assignment)
        pulumi.set(__self__, "details", details)
        pulumi.set(__self__, "state", state)
        pulumi.set(__self__, "static", static)

    @property
    @pulumi.getter
    def assignment(self) -> 'outputs.GetVpcV1alpha1AllocationStatusAssignmentResult':
        """
        Information about the assignment associated with the allocation,
        such as network interface or load balancer assignment.
        """
        return pulumi.get(self, "assignment")

    @property
    @pulumi.getter
    def details(self) -> 'outputs.GetVpcV1alpha1AllocationStatusDetailsResult':
        """
        Detailed information about the allocation status,
        including the allocated CIDR, pool ID, scope type, and IP version.
        """
        return pulumi.get(self, "details")

    @property
    @pulumi.getter
    def state(self) -> builtins.str:
        """
        This field represents the current state of the allocation.

        ### Supported values

        Enumeration of possible states of the Allocation.
        Possible values:

         - `STATE_UNSPECIFIED` - Default state, unspecified.
         - `CREATING` - Allocation is being created.
         - `ALLOCATED` - Allocation is ready for use.
         - `ASSIGNED` - Allocation is used.
         - `DELETING` - Allocation is being deleted.
        """
        return pulumi.get(self, "state")

    @property
    @pulumi.getter
    def static(self) -> builtins.bool:
        """
        If false - Lifecycle of allocation depends on resource that using it.
        """
        return pulumi.get(self, "static")


@pulumi.output_type
class GetVpcV1alpha1AllocationStatusAssignmentResult(dict):
    def __init__(__self__, *,
                 load_balancer: 'outputs.GetVpcV1alpha1AllocationStatusAssignmentLoadBalancerResult',
                 network_interface: 'outputs.GetVpcV1alpha1AllocationStatusAssignmentNetworkInterfaceResult'):
        """
        :param 'GetVpcV1alpha1AllocationStatusAssignmentLoadBalancerArgs' load_balancer: *Cannot be set alongside network_interface.*
        :param 'GetVpcV1alpha1AllocationStatusAssignmentNetworkInterfaceArgs' network_interface: *Cannot be set alongside load_balancer.*
        """
        pulumi.set(__self__, "load_balancer", load_balancer)
        pulumi.set(__self__, "network_interface", network_interface)

    @property
    @pulumi.getter(name="loadBalancer")
    def load_balancer(self) -> 'outputs.GetVpcV1alpha1AllocationStatusAssignmentLoadBalancerResult':
        """
        *Cannot be set alongside network_interface.*
        """
        return pulumi.get(self, "load_balancer")

    @property
    @pulumi.getter(name="networkInterface")
    def network_interface(self) -> 'outputs.GetVpcV1alpha1AllocationStatusAssignmentNetworkInterfaceResult':
        """
        *Cannot be set alongside load_balancer.*
        """
        return pulumi.get(self, "network_interface")


@pulumi.output_type
class GetVpcV1alpha1AllocationStatusAssignmentLoadBalancerResult(dict):
    def __init__(__self__, *,
                 id: builtins.str):
        """
        :param builtins.str id: ID of the Load Balancer.
        """
        pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> builtins.str:
        """
        ID of the Load Balancer.
        """
        return pulumi.get(self, "id")


@pulumi.output_type
class GetVpcV1alpha1AllocationStatusAssignmentNetworkInterfaceResult(dict):
    def __init__(__self__, *,
                 instance_id: builtins.str,
                 name: builtins.str):
        """
        :param builtins.str instance_id: ID of the Compute instance network interface belongs to.
        :param builtins.str name: Network interface name
        """
        pulumi.set(__self__, "instance_id", instance_id)
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter(name="instanceId")
    def instance_id(self) -> builtins.str:
        """
        ID of the Compute instance network interface belongs to.
        """
        return pulumi.get(self, "instance_id")

    @property
    @pulumi.getter
    def name(self) -> builtins.str:
        """
        Network interface name
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetVpcV1alpha1AllocationStatusDetailsResult(dict):
    def __init__(__self__, *,
                 allocated_cidr: builtins.str,
                 pool_id: builtins.str,
                 version: builtins.str):
        """
        :param builtins.str version: ### Supported values
               
               Possible values:
               
                - `IP_VERSION_UNSPECIFIED` - Default, unspecified IP version.
                - `IPV4` - IPv4 address.
                - `IPV6` - IPv6 address.
        """
        pulumi.set(__self__, "allocated_cidr", allocated_cidr)
        pulumi.set(__self__, "pool_id", pool_id)
        pulumi.set(__self__, "version", version)

    @property
    @pulumi.getter(name="allocatedCidr")
    def allocated_cidr(self) -> builtins.str:
        return pulumi.get(self, "allocated_cidr")

    @property
    @pulumi.getter(name="poolId")
    def pool_id(self) -> builtins.str:
        return pulumi.get(self, "pool_id")

    @property
    @pulumi.getter
    def version(self) -> builtins.str:
        """
        ### Supported values

        Possible values:

         - `IP_VERSION_UNSPECIFIED` - Default, unspecified IP version.
         - `IPV4` - IPv4 address.
         - `IPV6` - IPv6 address.
        """
        return pulumi.get(self, "version")


@pulumi.output_type
class GetVpcV1alpha1NetworkMetadataResult(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class GetVpcV1alpha1NetworkPoolResult(dict):
    def __init__(__self__, *,
                 pool_id: builtins.str):
        pulumi.set(__self__, "pool_id", pool_id)

    @property
    @pulumi.getter(name="poolId")
    def pool_id(self) -> builtins.str:
        return pulumi.get(self, "pool_id")


@pulumi.output_type
class GetVpcV1alpha1NetworkStatusResult(dict):
    def __init__(__self__, *,
                 scope_id: builtins.str,
                 state: builtins.str):
        """
        :param builtins.str scope_id: Scope ID of all pools
        :param builtins.str state: Current state of the network.
               
               ### Supported values
               
               Enumeration of possible states of the network.
               Possible values:
               
                - `STATE_UNSPECIFIED` - Default state, unspecified.
                - `CREATING` - Network is being created.
                - `READY` - Network is ready for use.
                - `DELETING` - Network is being deleted.
        """
        pulumi.set(__self__, "scope_id", scope_id)
        pulumi.set(__self__, "state", state)

    @property
    @pulumi.getter(name="scopeId")
    def scope_id(self) -> builtins.str:
        """
        Scope ID of all pools
        """
        return pulumi.get(self, "scope_id")

    @property
    @pulumi.getter
    def state(self) -> builtins.str:
        """
        Current state of the network.

        ### Supported values

        Enumeration of possible states of the network.
        Possible values:

         - `STATE_UNSPECIFIED` - Default state, unspecified.
         - `CREATING` - Network is being created.
         - `READY` - Network is ready for use.
         - `DELETING` - Network is being deleted.
        """
        return pulumi.get(self, "state")


@pulumi.output_type
class GetVpcV1alpha1PoolCidrResult(dict):
    def __init__(__self__, *,
                 allowed_mask: builtins.float,
                 cidr: builtins.str,
                 state: builtins.str):
        """
        :param builtins.float allowed_mask: Maximum mask length for allocation from this IP pool including creation of sub-pools
        :param builtins.str cidr: CIDR block.
               May be a prefix length (such as /24) for non-top-level pools
               or a CIDR-formatted string (such as 10.1.2.0/24).
        :param builtins.str state: State of the Cidr.
               
               ### Supported values
               
               Possible values:
               
                - `STATE_UNSPECIFIED` - Default, unspecified state.
                - `AVAILABLE` - Allocation from range is available.
                - `DISABLED` - New allocation would not be created.
        """
        pulumi.set(__self__, "allowed_mask", allowed_mask)
        pulumi.set(__self__, "cidr", cidr)
        pulumi.set(__self__, "state", state)

    @property
    @pulumi.getter(name="allowedMask")
    def allowed_mask(self) -> builtins.float:
        """
        Maximum mask length for allocation from this IP pool including creation of sub-pools
        """
        return pulumi.get(self, "allowed_mask")

    @property
    @pulumi.getter
    def cidr(self) -> builtins.str:
        """
        CIDR block.
        May be a prefix length (such as /24) for non-top-level pools
        or a CIDR-formatted string (such as 10.1.2.0/24).
        """
        return pulumi.get(self, "cidr")

    @property
    @pulumi.getter
    def state(self) -> builtins.str:
        """
        State of the Cidr.

        ### Supported values

        Possible values:

         - `STATE_UNSPECIFIED` - Default, unspecified state.
         - `AVAILABLE` - Allocation from range is available.
         - `DISABLED` - New allocation would not be created.
        """
        return pulumi.get(self, "state")


@pulumi.output_type
class GetVpcV1alpha1PoolMetadataResult(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class GetVpcV1alpha1PoolStatusResult(dict):
    def __init__(__self__, *,
                 cidrs: Sequence[builtins.str],
                 scope_id: builtins.str,
                 state: builtins.str):
        """
        :param Sequence[builtins.str] cidrs: CIDR blocks.
        :param builtins.str scope_id: ID of the scope
        :param builtins.str state: Current state of the Pool.
               
               ### Supported values
               
               Possible states of the Pool.
               Possible values:
               
                - `STATE_UNSPECIFIED` - Default, unspecified state.
                - `CREATING` - Pool is being created.
                - `READY` - Pool is ready for use.
                - `DELETING` - Pool is being deleted.
        """
        pulumi.set(__self__, "cidrs", cidrs)
        pulumi.set(__self__, "scope_id", scope_id)
        pulumi.set(__self__, "state", state)

    @property
    @pulumi.getter
    def cidrs(self) -> Sequence[builtins.str]:
        """
        CIDR blocks.
        """
        return pulumi.get(self, "cidrs")

    @property
    @pulumi.getter(name="scopeId")
    def scope_id(self) -> builtins.str:
        """
        ID of the scope
        """
        return pulumi.get(self, "scope_id")

    @property
    @pulumi.getter
    def state(self) -> builtins.str:
        """
        Current state of the Pool.

        ### Supported values

        Possible states of the Pool.
        Possible values:

         - `STATE_UNSPECIFIED` - Default, unspecified state.
         - `CREATING` - Pool is being created.
         - `READY` - Pool is ready for use.
         - `DELETING` - Pool is being deleted.
        """
        return pulumi.get(self, "state")


@pulumi.output_type
class GetVpcV1alpha1ScopeMetadataResult(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class GetVpcV1alpha1ScopeStatusResult(dict):
    def __init__(__self__, *,
                 state: builtins.str):
        """
        :param builtins.str state: Current state of the Scope.
               
               ### Supported values
               
               Possible states of the Scope.
               Possible values:
               
                - `STATE_UNSPECIFIED` - Default, unspecified state.
                - `CREATING` - Scope is being created.
                - `READY` - Scope is ready for use.
                - `DELETING` - Scope is being deleted.
        """
        pulumi.set(__self__, "state", state)

    @property
    @pulumi.getter
    def state(self) -> builtins.str:
        """
        Current state of the Scope.

        ### Supported values

        Possible states of the Scope.
        Possible values:

         - `STATE_UNSPECIFIED` - Default, unspecified state.
         - `CREATING` - Scope is being created.
         - `READY` - Scope is ready for use.
         - `DELETING` - Scope is being deleted.
        """
        return pulumi.get(self, "state")


@pulumi.output_type
class GetVpcV1alpha1SubnetMetadataResult(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class GetVpcV1alpha1SubnetPoolResult(dict):
    def __init__(__self__, *,
                 pool_id: builtins.str,
                 spec: 'outputs.GetVpcV1alpha1SubnetPoolSpecResult'):
        """
        :param builtins.str pool_id: *Cannot be set alongside spec.*
        :param 'GetVpcV1alpha1SubnetPoolSpecArgs' spec: *Cannot be set alongside pool_id.*
        """
        pulumi.set(__self__, "pool_id", pool_id)
        pulumi.set(__self__, "spec", spec)

    @property
    @pulumi.getter(name="poolId")
    def pool_id(self) -> builtins.str:
        """
        *Cannot be set alongside spec.*
        """
        return pulumi.get(self, "pool_id")

    @property
    @pulumi.getter
    def spec(self) -> 'outputs.GetVpcV1alpha1SubnetPoolSpecResult':
        """
        *Cannot be set alongside pool_id.*
        """
        return pulumi.get(self, "spec")


@pulumi.output_type
class GetVpcV1alpha1SubnetPoolSpecResult(dict):
    def __init__(__self__, *,
                 cidrs: Sequence['outputs.GetVpcV1alpha1SubnetPoolSpecCidrResult'],
                 version: builtins.str):
        """
        :param builtins.str version: ### Supported values
               
               Possible values:
               
                - `IP_VERSION_UNSPECIFIED` - Default, unspecified IP version.
                - `IPV4` - IPv4 address.
                - `IPV6` - IPv6 address.
        """
        pulumi.set(__self__, "cidrs", cidrs)
        pulumi.set(__self__, "version", version)

    @property
    @pulumi.getter
    def cidrs(self) -> Sequence['outputs.GetVpcV1alpha1SubnetPoolSpecCidrResult']:
        return pulumi.get(self, "cidrs")

    @property
    @pulumi.getter
    def version(self) -> builtins.str:
        """
        ### Supported values

        Possible values:

         - `IP_VERSION_UNSPECIFIED` - Default, unspecified IP version.
         - `IPV4` - IPv4 address.
         - `IPV6` - IPv6 address.
        """
        return pulumi.get(self, "version")


@pulumi.output_type
class GetVpcV1alpha1SubnetPoolSpecCidrResult(dict):
    def __init__(__self__, *,
                 allowed_mask: builtins.float,
                 cidr: builtins.str,
                 state: builtins.str):
        """
        :param builtins.float allowed_mask: Maximum mask length for allocation from this cidr
        :param builtins.str cidr: CIDR block.
               May be a prefix length (such as /24) or a CIDR-formatted string (such as 10.1.2.0/24).
        :param builtins.str state: State of the Cidr.
               
               ### Supported values
               
               Possible values:
               
                - `STATE_UNSPECIFIED` - Default, unspecified state.
                - `AVAILABLE` - Allocation from range is available.
                - `DISABLED` - New allocation would not be created.
        """
        pulumi.set(__self__, "allowed_mask", allowed_mask)
        pulumi.set(__self__, "cidr", cidr)
        pulumi.set(__self__, "state", state)

    @property
    @pulumi.getter(name="allowedMask")
    def allowed_mask(self) -> builtins.float:
        """
        Maximum mask length for allocation from this cidr
        """
        return pulumi.get(self, "allowed_mask")

    @property
    @pulumi.getter
    def cidr(self) -> builtins.str:
        """
        CIDR block.
        May be a prefix length (such as /24) or a CIDR-formatted string (such as 10.1.2.0/24).
        """
        return pulumi.get(self, "cidr")

    @property
    @pulumi.getter
    def state(self) -> builtins.str:
        """
        State of the Cidr.

        ### Supported values

        Possible values:

         - `STATE_UNSPECIFIED` - Default, unspecified state.
         - `AVAILABLE` - Allocation from range is available.
         - `DISABLED` - New allocation would not be created.
        """
        return pulumi.get(self, "state")


@pulumi.output_type
class GetVpcV1alpha1SubnetStatusResult(dict):
    def __init__(__self__, *,
                 ipv4_cidrs: Sequence[builtins.str],
                 state: builtins.str):
        """
        :param Sequence[builtins.str] ipv4_cidrs: CIDR blocks.
        :param builtins.str state: Current state of the subnet.
               
               ### Supported values
               
               Enumeration of possible states of the subnet.
               Possible values:
               
                - `STATE_UNSPECIFIED` - Default state, unspecified.
                - `CREATING` - Subnet is being created.
                - `READY` - Subnet is ready for use.
                - `DELETING` - Subnet is being deleted.
        """
        pulumi.set(__self__, "ipv4_cidrs", ipv4_cidrs)
        pulumi.set(__self__, "state", state)

    @property
    @pulumi.getter(name="ipv4Cidrs")
    def ipv4_cidrs(self) -> Sequence[builtins.str]:
        """
        CIDR blocks.
        """
        return pulumi.get(self, "ipv4_cidrs")

    @property
    @pulumi.getter
    def state(self) -> builtins.str:
        """
        Current state of the subnet.

        ### Supported values

        Enumeration of possible states of the subnet.
        Possible values:

         - `STATE_UNSPECIFIED` - Default state, unspecified.
         - `CREATING` - Subnet is being created.
         - `READY` - Subnet is ready for use.
         - `DELETING` - Subnet is being deleted.
        """
        return pulumi.get(self, "state")


